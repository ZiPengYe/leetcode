# [menu](https://leetcode.com/problemset/all/)
- [x] [#1 Two Sum](#1-two-sum)
- [x] [#2 Add Two Numbers](#2-add-two-numbers)
- [x] [#3 Longest Substring Without Repeating Characters](#3-longest-substring-without-repeating-characters)
- [x] [#4 Median of Two Sorted Arrays](#4-median-of-two-sorted-arrays)
- [x] [#5 Longest Palindromic Substring](#5-longest-palindromic-substring)
- [x] [#6 ZigZag Conversion](#6-zigzag-conversion)
- [x] [#7 Reverse Integer](#7-reverse-integer)
- [x] [#9 Palindrome Number](#9-palindrome-number)
- [x] [#13 Roman to Integer](#13-roman-to-integer)
- [x] [#14 Longest Common Prefix](#14-longest-common-prefix)
- [x] [#15 3Sum](#15-3sum)
- [x] [#17 Letter Combinations of a Phone Number](#17-letter-combinations-of-a-phone-number)
- [x] [#19 Remove Nth Node From End of List](#19-remove-nth-node-from-end-of-list)
- [x] [#20 Valid Parentheses](#20-valid-parentheses)
- [x] [#21 Merge Two Sorted Lists](#21-merge-two-sorted-lists)
- [x] [#26 Remove Duplicates from Sorted Array](#26-remove-duplicates-from-sorted-array)
- [x] [#27 Remove Element](#27-remove-element)
- [x] [#28 Implement strStr()](#28-implement-strstr)
- [x] [#33 Search in Rotated Sorted Array](#33-search-in-rotated-sorted-array)
- [x] [#34 Find First and Last Position of Element in Sorted Array](#34-find-first-and-last-position-of-element-in-sorted-array)
- [x] [#35 Search Insert Position](#35-search-insert-position)
- [x] [#38 Count and Say](#38-count-and-say)
- [x] [#46 Permutations](#46-permutations)
- [x] [#49 Group Anagrams](#49-group-anagrams)
- [x] [#53 Maximum Subarray](#53-maximum-subarray)
- [x] [#55 Jump Game](#55-jump-game)
- [x] [#58 Length of Last Word](#58-length-of-last-word)
- [x] [#64 Minimum Path Sum](#64-minimum-path-sum)
- [x] [#66 Plus One](#66-plus-one)
- [x] [#67 Add Binary](#67-add-binary)
- [x] [#69 Sqrt(x)](#69-sqrtx)
- [x] [#70 Climbing Stairs](#70-climbing-stairs)
- [x] [#74 Search a 2D Matrix](#74-search-a-2d-matrix)
- [x] [#77 Combinations](#77-combinations)
- [x] [#82 Remove Duplicates from Sorted List II](#82-remove-duplicates-from-sorted-list-ii)
- [x] [#83 Remove Duplicates from Sorted List](#83-remove-duplicates-from-sorted-list)
- [x] [#88 Merge Sorted Array](#88-merge-sorted-array)
- [x] [#100 Same Tree](#100-same-tree)
- [x] [#101 Symmetric Tree](#101-symmetric-tree)
- [x] [#104 Maximum Depth of Binary Tree](#104-maximum-depth-of-binary-tree)
- [x] [#107 Binary Tree Level Order Traversal II](#107-binary-tree-level-order-traversal-ii)
- [x] [#108 Convert Sorted Array to Binary Search Tree](#108-convert-sorted-array-to-binary-search-tree)
- [x] [#110 Balanced Binary Tree](#110-balanced-binary-tree)
- [x] [#111 Minimum Depth of Binary Tree](#111-minimum-depth-of-binary-tree)
- [x] [#112 Path Sum](#112-path-sum)
- [x] [#116 Populating Next Right Pointers in Each Node](#116-Pascal's Triangle)
- [x] [#118 Pascal's Triangle](#118-pascals-triangle)
- [x] [#119 Pascal's Triangle II](#119-pascals-triangle-ii)
- [x] [#120 Triangle](#120-triangle)
- [x] [#121 Best Time to Buy and Sell Stock](#121-best-time-to-buy-and-sell-stock)
- [x] [#122 Best Time to Buy and Sell Stock II](#122-best-time-to-buy-and-sell-stock-ii)
- [x] [#124 Binary Tree Maximum Path Sum](#124-binary-tree-maximum-path-sum)
- [x] [#125 Valid Palindrome](#125-valid-palindrome)
- [x] [#136 Single Number](#136-single-number)
- [x] [#141 Linked List Cycle](#141-linked-list-cycle)
- [x] [#146 LRU Cache](#146-lru-cache)
- [x] [#153 Find Minimum in Rotated Sorted Array](#153-find-minimum-in-rotated-sorted-array)
- [x] [#155 Min Stack](#155-min-stack)
- [x] [#160 Intersection of Two Linked Lists](#160-intersection-of-two-linked-lists)
- [x] [#162 Find Peak Element](#162-Two Sum II - Input array is sorted)
- [x] [#167 Two Sum II - Input array is sorted](#167-two-sum-ii-input-array-is-sorted)
- [x] [#168 Excel Sheet Column Title](#168-excel-sheet-column-title)
- [x] [#169 Majority Element](#169-majority-element)
- [x] [#171 Excel Sheet Column Number](#171-excel-sheet-column-number)
- [x] [#172 Factorial Trailing Zeroes](#172-factorial-trailing-zeroes)
- [x] [#175 Combine Two Tables](#175-combine-two-tables)
- [x] [#176 Second Highest Salary](#176-second-highest-salary)
- [x] [#179 Largest Number](#179-largest-number)
- [x] [#181 Employees Earning More Than Their Managers](#181-employees-earning-more-than-their-managers)
- [x] [#182 Duplicate Emails](#182-duplicate-emails)
- [x] [#183 Customers Who Never Order](#183-customers-who-never-order)
- [x] [#189 Rotate Array](#189-rotate-array)
- [x] [#190 Reverse Bits](#190-reverse-bits)
- [x] [#191 Number of 1 Bits](#191-number-of-1-bits)
- [x] [#193 Valid Phone Numbers](#193-valid-phone-numbers)
- [x] [#195 Tenth Line](#195-tenth-line)
- [x] [#196 Delete Duplicate Emails](#196-delete-duplicate-emails)
- [x] [#197 Rising Temperature](#197-rising-temperature)
- [x] [#198 House Robber](#198-house-robber)
- [x] [#200 Number of Islands](#200-number-of-islands)
- [x] [#201 Bitwise AND of Numbers Range](#201-bitwise-and-of-numbers-range)
- [x] [#202 Happy Number](#202-happy-number)
- [x] [#203 Remove Linked List Elements](#203-remove-linked-list-elements)
- [x] [#204 Count Primes](#204-count-primes)
- [x] [#205 Isomorphic Strings](#205-isomorphic-strings)
- [x] [#206 Reverse Linked List](#206-reverse-linked-list)
- [x] [#208 Implement Trie (Prefix Tree)](#208-implement-trie-prefix-tree)
- [x] [#217 Contains Duplicate](#217-contains-duplicate)
- [x] [#219 Contains Duplicate II](#219-contains-duplicate-ii)
- [x] [#221 Maximal Square](#221-maximal-square)
- [x] [#224 Basic Calculator](#224-basic-calculator)
- [x] [#225 Implement Stack using Queues](#225-implement-stack-using-queues)
- [x] [#226 Invert Binary Tree](#226-invert-binary-tree)
- [x] [#231 Power of Two](#231-power-of-two)
- [x] [#232 Implement Queue using Stacks](#232-implement-queue-using-stacks)
- [x] [#234 Palindrome Linked List](#234-palindrome-linked-list)
- [x] [#235 Lowest Common Ancestor of a Binary Search Tree](#235-lowest-common-ancestor-of-a-binary-search-tree)
- [x] [#237 Delete Node in a Linked List](#237-delete-node-in-a-linked-list)
- [x] [#238 Product of Array Except Self](#238-product-of-array-except-self)
- [x] [#240 Search a 2D Matrix II](#240-search-a-2d-matrix-ii)
- [x] [#242 Valid Anagram](#242-valid-anagram)
- [x] [#257 Binary Tree Paths](#257-binary-tree-paths)
- [x] [#258 Add Digits](#258-add-digits)
- [x] [#263 Ugly Number](#263-ugly-number)
- [x] [#268 Missing Number](#268-missing-number)
- [x] [#278 First Bad Version](#278-first-bad-version)
- [x] [#283 Move Zeroes](#283-move-zeroes)
- [x] [#290 Word Pattern](#290-word-pattern)
- [x] [#292 Nim Game](#292-nim-game)
- [x] [#295 Find Median from Data Stream](#295-find-median-from-data-stream)
- [x] [#300 Longest Increasing Subsequence](#300-longest-increasing-subsequence)
- [x] [#322 Coin Change](#322-coin-change)
- [x] [#328 Odd Even Linked List](#328-odd-even-linked-list)
- [x] [#344 Reverse String](#344-reverse-string)
- [x] [#354 Russian Doll Envelopes](#354-russian-doll-envelopes)
- [x] [#369 Valid Perfect Square](#369-valid-perfect-square)
- [x] [#376 Wiggle Subsequence](#376-wiggle-subsequence)
- [x] [#378 Kth Smallest Element in a Sorted Matrix](#378-kth-smallest-element-in-a-sorted-matrix)
- [x] [#383 Ransom Note](#383-ransom-note)
- [x] [#387 First Unique Character in a String](#387-first-unique-character-in-a-string)
- [x] [#402 Remove K Digits](#402-remove-k-digits)
- [x] [#417 Pacific Atlantic Water Flow](#417-pacific-atlantic-water-flow)
- [x] [#423 Reconstruct Original Digits from English](#423-reconstruct-original-digits-from-english)
- [x] [#434 Number of Segments in a String](#434-number-of-segments-in-a-string)
- [x] [#438 Find All Anagrams in a String](#438-find-all-anagrams-in-a-string)
- [x] [#451 Sort Characters By Frequency](#451-sort-characters-by-frequency)
- [x] [#467 Unique Substrings in Wraparound String](#467-unique-substrings-in-wraparound-string)
- [x] [#474 Ones and Zeroes](#474-ones-and-zeroes)
- [x] [#476 Number Complement](#476-number-complement)
- [x] [#478 Generate Random Point in a Circle](#478-generate-random-point-in-a-circle)
- [x] [#506 Relative Ranks](#506-relative-ranks)
- [x] [#525 Contiguous Array](#525-contiguous-array)
- [x] [#535 Encode and Decode TinyURL](#535-encode-and-decode-tinyurl)
- [x] [#540 Single Element in a Sorted Array](#540-single-element-in-a-sorted-array)
- [x] [#542 01 Matrix](#542-01-matrix)
- [x] [#547 Number of Provinces](#547-number-of-provinces)
- [x] [#557 Reverse Words in a String III](#557-reverse-words-in-a-string-iii)
- [x] [#560 Subarray Sum Equals K](#560-subarray-sum-equals-k)
- [x] [#567 Permutation in String](#567-permutation-in-string)
- [x] [#575 Distribute Candies](#575-distribute-candies)
- [x] [#611 Valid Triangle Number](#611-valid-triangle-number)
- [x] [#617 Merge Two Binary Trees](#617-merge-two-binary-trees)
- [x] [#645 Set Mismatch](#645-set-mismatch)
- [x] [#667 Beautiful Arrangement II](#667-beautiful-arrangement-ii)
- [x] [#678 Valid Parenthesis String](#678-valid-parenthesis-string)
- [x] [#695 Max Area of Island](#695-max-area-of-island)
- [x] [#704 Binary Search](#704-binary-search)
- [x] [#714 Best Time to Buy and Sell Stock with Transaction Fee](#714-best-time-to-buy-and-sell-stock-with-transaction-fee)
- [x] [#720 Longest Word in Dictionary](#720-longest-word-in-dictionary)
- [x] [#733 Flood Fill](#733-flood-fill)
- [x] [#747 Largest Number At Least Twice of Others](#747-largest-number-at-least-twice-of-others)
- [x] [#771 Jewels and Stones](#771-jewels-and-stones)
- [x] [#781 Rabbits in Forest](#781-rabbits-in-forest)
- [x] [#783 Minimum Distance Between BST Nodes](#783-minimum-distance-between-bst-nodes)
- [x] [#784 Letter Case Permutation](#784-letter-case-permutation)
- [x] [#823 Binary Trees With Factors](#823-binary-trees-with-factors)
- [x] [#844 Backspace String Compare](#844-backspace-string-compare)
- [x] [#851 Loud and Rich](#851-loud-and-rich)
- [x] [#869 Reordered Power of 2](#869-reordered-power-of-2)
- [x] [#870 Advantage Shuffle](#870-advantage-shuffle)
- [x] [#876 Middle of the Linked List](#876-middle-of-the-linked-list)
- [x] [#901 Online Stock Span](#901-online-stock-span)
- [x] [#916 Word Subsets](#916-word-subsets)
- [x] [#918 Maximum Sum Circular Subarray](#918-maximum-sum-circular-subarray)
- [x] [#953 Verifying an Alien Dictionary](#953-verifying-an-alien-dictionary)
- [x] [#971 Flip Binary Tree To Match Preorder Traversal](#971-flip-binary-tree-to-match-preorder-traversal)
- [x] [#977 Squares of a Sorted Array](#977-squares-of-a-sorted-array)
- [x] [#992 Subarrays with K Different Integers](#992-subarrays-with-k-different-integers)
- [x] [#993 Cousins in Binary Tree](#993-cousins-in-binary-tree)
- [x] [#994 Rotting Oranges](#994-rotting-oranges)
- [x] [#997 Find the Town Judge](#997-find-the-town-judge)
- [x] [#1008 Construct Binary Search Tree from Preorder Traversal](#1008-construct-binary-search-tree-from-preorder-traversal)
- [x] [#1022 Sum of Root To Leaf Binary Numbers](#1022-sum-of-root-to-leaf-binary-numbers)
- [ ] [#1024 Video Stitching](#1024-video-stitching)
- [x] [#1046 Last Stone Weight](#1046-last-stone-weight)
- [x] [#1143 Longest Common Subsequence](#1143-longest-common-subsequence)
- [x] [#1147 Longest Chunked Palindrome Decomposition](#1147-longest-chunked-palindrome-decomposition)
- [x] [#1232 Check If It Is a Straight Line](#1232-check-if-it-is-a-straight-line)
- [x] [#1302 Deepest Leaves Sum](#1302-deepest-leaves-sum)
- [x] [#1306 Jump Game III](#1306-jump-game-iii)
- [x] [#1337 The K Weakest Rows in a Matrix](#1337-the-k-weakest-rows-in-a-matrix)
- [x] [#1695 Maximum Erasure Value](#1695-maximum-erasure-value)
- [x] [#1704 Determine if String Halves Are Alike](#1704-determine-if-string-halves-are-alike)
- [x] [#1721 Swapping Nodes in a Linked List](#1721-swapping-nodes-in-a-linked-list)
- [x] [#1732 Find the Highest Altitude](#1732-find-the-highest-altitude)
- [x] [Leftmost Column with at Least a One](#leftmost-column-with-at-least-a-one)
- [x] [First Unique Number](#first-unique-number)
---
## [#1 Two Sum](https://leetcode.com/problems/two-sum)
Given an array of integers, return **indices** of the two numbers such that they add up to a specific target.

You may assume that each input would have **exactly** one solution, and you may not use the same element twice.

**Example:**
```
Given nums = [2, 7, 11, 15], target = 9,

Because nums[0] + nums[1] = 2 + 7 = 9,
return [0, 1].
```
[back to top](#menu)

---
## [#2 Add Two Numbers](https://leetcode.com/problems/add-two-numbers)
You are given two **non-empty** linked lists representing two non-negative integers. The digits are stored in **reverse order** and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.

You may assume the two numbers do not contain any leading zero, except the number 0 itself.

**Example:**
```
Input
Output: 7 -> 0 -> 8
Explanation: 342 + 465 = 807.
```
[back to top](#menu)

---
## [#3 Longest Substring Without Repeating Characters](https://leetcode.com/problems/longest-substring-without-repeating-characters)
Given a string, find the length of the **longest substring** without repeating characters.

**Example 1:**
```
Input: "abcabcbb"
Output: 3
Explanation: The answer is "abc", with the length of 3.
```
**Example 2:**
```
Input: "bbbbb"
Output: 1
Explanation: The answer is "b", with the length of 1.
```
**Example 3:**
```
Input: "pwwkew"
Output: 3
Explanation: The answer is "wke", with the length of 3.
Note that the answer must be a substring, "pwke" is a subsequence and not a substring.
```
[back to top](#menu)

---
## [#4 Median of Two Sorted Arrays](https://leetcode.com/problems/median-of-two-sorted-arrays)
There are two sorted arrays **nums1** and **nums2** of size m and n respectively.

Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).

You may assume **nums1** and **nums2** cannot be both empty.

**Example 1:**
```
nums1 = [1, 3]
nums2 = [2]

The median is 2.0
```
**Example 2:**
```
nums1 = [1, 2]
nums2 = [3, 4]

The median is (2 + 3)/2 = 2.5
```
[back to top](#menu)

---
## [#5 Longest Palindromic Substring](https://leetcode.com/problems/longest-palindromic-substring)
Given a string **s**, find the longest palindromic substring in **s**. You may assume that the maximum length of **s** is 1000.

**Example 1:**
```
Input: "babad"
Output: "bab"
Note: "aba" is also a valid answer.
```
**Example 2:**
```
Input: "cbbd"
Output: "bb"
```
[back to top](#menu)

---
## [#6 ZigZag Conversion](https://leetcode.com/problems/zigzag-conversion)
The string `"PAYPALISHIRING"` is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)
```
P   A   H   N
A P L S I I G
Y   I   R
```
And then read line by line: `"PAHNAPLSIIGYIR"`

Write the code that will take a string and make this conversion given a number of rows:
```c
string convert(string s, int numRows);
```
**Example 1:**
```
Input: s = "PAYPALISHIRING", numRows = 3
Output: "PAHNAPLSIIGYIR"
```
**Example 2:**
```
Input: s = "PAYPALISHIRING", numRows = 4
Output: "PINALSIGYAHRPI"
Explanation:

P     I     N
A   L S   I G
Y A   H R
P     I
```
[back to top](#menu)

---
## [#7 Reverse Integer](https://leetcode.com/problems/reverse-integer)
Given a 32-bit signed integer, reverse digits of an integer.

**Example 1:**
```
Input: 123
Output: 321
```
**Example 2:**
```
Input: -123
Output: -321
```
**Example 3:**
```
Input: 120
Output: 21
```
**Note:**
- Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−2^(31),  2^(31) − 1]. For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows.

[back to top](#menu)

---
## [#9 Palindrome Number](https://leetcode.com/problems/palindrome-number)
Determine whether an integer is a palindrome. An integer is a palindrome when it reads the same backward as forward.

**Example 1:**
```
Input: 121
Output: true
```
**Example 2:**
```
Input: -121
Output: false
Explanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.
```
**Example 3:**
```
Input: 10
Output: false
Explanation: Reads 01 from right to left. Therefore it is not a palindrome.
```
**Follow up:**

Coud you solve it without converting the integer to a string?

[back to top](#menu)

---
## [#13 Roman to Integer](https://leetcode.com/problems/roman-to-integer)
Roman numerals are represented by seven different symbols: `I`, `V`, `X`, `L`, `C`, `D` and `M`.
```
Symbol       Value
I             1
V             5
X             10
L             50
C             100
D             500
M             1000
```
For example, two is written as `II` in Roman numeral, just two one's added together. Twelve is written as, `XII`, which is simply `X` + `II`. The number twenty seven is written as `XXVII`, which is `XX` + `V` + `II`.

Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not `IIII`. Instead, the number four is written as `IV`. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as `IX`. There are six instances where subtraction is used:
- `I` can be placed before `V` (5) and `X` (10) to make 4 and 9.
- `X` can be placed before `L` (50) and `C` (100) to make 40 and 90.
- `C` can be placed before `D` (500) and `M` (1000) to make 400 and 900.
Given a roman numeral, convert it to an integer. Input is guaranteed to be within the range from 1 to 3999.

**Example 1:**
```
Input: "III"
Output: 3
```
**Example 2:**
```
Input: "IV"
Output: 4
```
**Example 3:**
```
Input: "IX"
Output: 9
```
**Example 4:**
```
Input: "LVIII"
Output: 58
Explanation: L = 50, V= 5, III = 3.
```
**Example 5:**
```
Input: "MCMXCIV"
Output: 1994
Explanation: M = 1000, CM = 900, XC = 90 and IV = 4.
```
[back to top](#menu)

---
## [#14 Longest Common Prefix](https://leetcode.com/problems/longest-common-prefix)
Write a function to find the longest common prefix string amongst an array of strings.

If there is no common prefix, return an empty string `""`.

**Example 1:**
```
Input: ["flower","flow","flight"]
Output: "fl"
```
**Example 4:**
```
Input: ["dog","racecar","car"]
Output: ""
Explanation: There is no common prefix among the input strings.
```
**Note:**
- All given inputs are in lowercase letters `a-z`.

[back to top](#menu)

---
## [#15 3Sum](https://leetcode.com/problems/3sum)
Given an integer array nums, return all the triplets `[nums[i], nums[j], nums[k]]` such that `i != j`, `i != k`, and `j != k`, and `nums[i] + nums[j] + nums[k] == 0`.

Notice that the solution set must not contain duplicate triplets.

**Example 1:**
```
Input: nums = [-1,0,1,2,-1,-4]
Output: [[-1,-1,2],[-1,0,1]]
```
**Example 2:**
```
Input: nums = []
Output: []
```
**Example 3:**
```
Input: nums = [0]
Output: []
```
**Constraints:**
  - `0 <= nums.length <= 3000`
  - `-10^5 <= nums[i] <= 10^5`

[back to top](#menu)

---
## [#17 Letter Combinations of a Phone Number](https://leetcode.com/problems/letter-combinations-of-a-phone-number)
Given a string containing digits from `2-9` inclusive, return all possible letter combinations that the number could represent. Return the answer in **any order**.

A mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.

![](https://upload.wikimedia.org/wikipedia/commons/thumb/7/73/Telephone-keypad2.svg/200px-Telephone-keypad2.svg.png)

**Example 1:**
```
Input: digits = "23"
Output: ["ad","ae","af","bd","be","bf","cd","ce","cf"]
```
**Example 2:**
```
Input: digits = ""
Output: []
```
**Example 3:**
```
Input: digits = "2"
Output: ["a","b","c"]
```
**Constraints:**
  - `0 <= digits.length <= 4`
  - `digits[i]` is a digit in the range `['2', '9']`.

[back to top](#menu)

---
## [#19 Remove Nth Node From End of List](https://leetcode.com/problems/remove-nth-node-from-end-of-list)
Given the `head` of a linked list, remove the `n^th` node from the end of the list and return its head.

**Example 1:**

![](https://assets.leetcode.com/uploads/2020/10/03/remove_ex1.jpg)
```
Input: head = [1,2,3,4,5], n = 2
Output: [1,2,3,5]
```
**Example 2:**
```
Input: head = [1], n = 1
Output: []
```
**Example 3:**
```
Input: head = [1,2], n = 1
Output: [1]
```
**Constraints:**
  - The number of nodes in the list is `sz`.
  - `1 <= sz <= 30`
  - `0 <= Node.val <= 100`
  - `1 <= n <= sz`

**Follow up:** Could you do this in one pass?

[back to top](#menu)

---
## [#20 Valid Parentheses](https://leetcode.com/problems/valid-parentheses)
Given a string containing just the characters `'('`, `')'`, `'{'`, `'}'`, `'['` and `']'`, determine if the input string is valid.

An input string is valid if:
  1. Open brackets must be closed by the same type of brackets.
  2. Open brackets must be closed in the correct order.

Note that an empty string is also considered valid.

**Example 1:**
```
Input: "()"
Output: true
```
**Example 2:**
```
Input: "()[]{}"
Output: true
```
**Example 3:**
```
Input: "(]"
Output: false
```
**Example 4:**
```
Input: "([)]"
Output: false
```
**Example 5:**
```
Input: "{[]}"
Output: true
```
[back to top](#menu)

---
## [#21 Merge Two Sorted Lists](https://leetcode.com/problems/merge-two-sorted-lists)
Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.

**Example:**
```
Input: 1->2->4, 1->3->4
Output: 1->1->2->3->4->4
```
[back to top](#menu)

---
## [#26 Remove Duplicates from Sorted Array](https://leetcode.com/problems/remove-duplicates-from-sorted-array)
Given a sorted array nums, remove the duplicates [in-place](https://en.wikipedia.org/wiki/In-place_algorithm) such that each element appear only once and return the new length.

Do not allocate extra space for another array, you must do this by **modifying the input array** [in-place](https://en.wikipedia.org/wiki/In-place_algorithm) with O(1) extra memory.

**Example 1:**
```
Given nums = [1,1,2],

Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively.

It doesn't matter what you leave beyond the returned length.
```
**Example 2:**
```
Given nums = [0,0,1,1,1,2,2,3,3,4],

Your function should return length = 5, with the first five elements of nums being modified to 0, 1, 2, 3, and 4 respectively.

It doesn't matter what values are set beyond the returned length.
```
**Clarification:**

Confused why the returned value is an integer but your answer is an array?

Note that the input array is passed in by reference, which means modification to the input array will be known to the caller as well.

Internally you can think of this:
```cpp
// nums is passed in by reference. (i.e., without making a copy)
int len = removeElement(nums);

// any modification to nums in your function would be known by the caller.
// using the length returned by your function, it prints the first len elements.
for (int i = 0; i < len; i++) {
    print(nums[i]);
}
```
[back to top](#menu)

---
## [#27 Remove Element](https://leetcode.com/problems/remove-element)
Given an array nums and a value val, remove all instances of that value [in-place](https://en.wikipedia.org/wiki/In-place_algorithm) and return the new length.

Do not allocate extra space for another array, you must do this by **modifying the input array** [in-place](https://en.wikipedia.org/wiki/In-place_algorithm) with O(1) extra memory.

**Example 1:**
```
Given nums = [3,2,2,3], val = 3,

Your function should return length = 2, with the first two elements of nums being 2.

It doesn't matter what you leave beyond the returned length.
```
**Example 2:**
```
Given nums = [0,1,2,2,3,0,4,2], val = 2,

Your function should return length = 5, with the first five elements of nums containing 0, 1, 3, 0, and 4.

Note that the order of those five elements can be arbitrary.

It doesn't matter what values are set beyond the returned length.
```
**Clarification:**

Confused why the returned value is an integer but your answer is an array?

Note that the input array is passed in by reference, which means modification to the input array will be known to the caller as well.

Internally you can think of this:
```cpp
// nums is passed in by reference. (i.e., without making a copy)
int len = removeDuplicates(nums);

// any modification to nums in your function would be known by the caller.
// using the length returned by your function, it prints the first len elements.
for (int i = 0; i < len; i++) {
    print(nums[i]);
}
```
[back to top](#menu)

---
## [#28 Implement strStr()](https://leetcode.com/problems/implement-strstr)
Implement [strStr()](http://www.cplusplus.com/reference/cstring/strstr/).

Return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.
**Example 1:**
```
Input: haystack = "hello", needle = "ll"
Output: 2
```
**Example 2:**
```
Input: haystack = "aaaaa", needle = "bba"
Output: -1
```
**Clarification:**

What should we return when `needle` is an empty string? This is a great question to ask during an interview.

For the purpose of this problem, we will return 0 when `needle` is an empty string. This is consistent to C's [strstr()](http://www.cplusplus.com/reference/cstring/strstr/) and Java's [indexOf()](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html#indexOf(java.lang.String)).

[back to top](#menu)

---
## [#33 Search in Rotated Sorted Array](https://leetcode.com/problems/search-in-rotated-sorted-array)
Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.

(i.e., `[0,1,2,4,5,6,7]` might become `[4,5,6,7,0,1,2]`).

You are given a target value to search. If found in the array return its index, otherwise return `-1`.

You may assume no duplicate exists in the array.

Your algorithm's runtime complexity must be in the order of *O*(log *n*).

**Example 1:**
```
Input: nums = [4,5,6,7,0,1,2], target = 0
Output: 4
```
**Example 2:**
```
Input: nums = [4,5,6,7,0,1,2], target = 3
Output: -1
```

[back to top](#menu)

---
## [#34 Find First and Last Position of Element in Sorted Array](https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array)
Given an array of integers `nums` sorted in ascending order, find the starting and ending position of a given `target` value.

If `target is not found in the array, return `[-1, -1]`.

You must write an algorithm with `O(log n)` runtime complexity.

**Example 1:**
```
Input: nums = [5,7,7,8,8,10], target = 8
Output: [3,4]
```
*Example 2:*
```
Input: nums = [5,7,7,8,8,10], target = 6
Output: [-1,-1]
```
**Example 3:**
```
Input: nums = [], target = 0
Output: [-1,-1]
```
**Constraints:**
  - `0 <= nums.length <= 10^5`
  - `-10^9 <= nums[i] <= 10^9`
  - `nums` is a non-decreasing array.
  - `-10^9 <= target <= 10^9`

[back to top](#menu)

---
## [#35 Search Insert Position](https://leetcode.com/problems/search-insert-position)
Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.

You may assume no duplicates in the array.

**Example 1:**
```
Input: [1,3,5,6], 5
Output: 2
```
**Example 2:**
```
Input: [1,3,5,6], 2
Output: 1
```
**Example 3:**
```
Input: [1,3,5,6], 7
Output: 4
```
**Example 4:**
```
Input: [1,3,5,6], 0
Output: 0
```
[back to top](#menu)

---
## [#38 Count and Say](https://leetcode.com/problems/count-and-say)
The count-and-say sequence is the sequence of integers with the first five terms as following:
```
1.      1
2.      11
3.      21
4.      1211
5.      111221
```
`1` is read off as `"one 1"` or `11`.

`11` is read off as `"two 1s"` or `21`.

`21` is read off as `"one 2`, then `one 1"` or `1211`.

Given an integer *n* where 1 ≤ *n* ≤ 30, generate the *n*th term of the count-and-say sequence.

You can do so recursively, in other words from the previous member read off the digits, counting the number of digits in groups of the same digit.

Note: Each term of the sequence of integers will be represented as a string.

**Example 1:**
```
Input: 1
Output: "1"
Explanation: This is the base case.
```
**Example 2:**
```
Input: 4
Output: "1211"
Explanation: For n = 3 the term was "21" in which we have two groups "2" and "1", "2" can be read as "12" which means frequency = 1 and value = 2, the same way "1" is read as "11", so the answer is the concatenation of "12" and "11" which is "1211".
```

[back to top](#menu)

---
## [#46 Permutations](https://leetcode.com/problems/permutations)
Given an array `nums` of distinct integers, return *all the possible permutations*. You can return the answer in **any order**.

**Example 1:**
```
Input: nums = [1,2,3]
Output: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
```
**Example 2:**
```
Input: nums = [0,1]
Output: [[0,1],[1,0]]
```
**Example 3:**
```
Input: nums = [1]
Output: [[1]]
```

**Constraints:**
  - `1 <= nums.length <= 6`
  - `-10 <= nums[i] <= 10`
  - All the integers of `nums` are **unique**.

[back to top](#menu)

---
## [49 Group Anagrams](https://leetcode.com/problems/group-anagrams)
Given an array of strings, group anagrams together.

**Example:**
```
Input: ["eat", "tea", "tan", "ate", "nat", "bat"],
Output:
[
  ["ate","eat","tea"],
  ["nat","tan"],
  ["bat"]
]
```
**Note:**
- All inputs will be in lowercase.
- The order of your output does not matter.

[back to top](#menu)

---
## [#53 Maximum Subarray](https://leetcode.com/problems/maximum-subarray)
Given an integer array `nums`, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.

**Example :**
```
Input: [-2,1,-3,4,-1,2,1,-5,4],
Output: 6
Explanation: [4,-1,2,1] has the largest sum = 6.
```
**Follow up:**

If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle.

[back to top](#menu)

---
## [#55 Jump Game](https://leetcode.com/problems/jump-game)
Given an array of non-negative integers, you are initially positioned at the first index of the array.

Each element in the array represents your maximum jump length at that position.

Determine if you are able to reach the last index.

**Example 1:**
```
Input: nums = [2,3,1,1,4]
Output: true
Explanation: Jump 1 step from index 0 to 1, then 3 steps to the last index.
```
**Example 2:**
```
Input: nums = [3,2,1,0,4]
Output: false
Explanation: You will always arrive at index 3 no matter what. Its maximum jump length is 0, which makes it impossible to reach the last index.
```
**Constraints::**
- `1 <= nums.length <= 3 * 10^4`
- `0 <= nums[i][j] <= 10^5`

[back to top](#menu)

---
## [#58 Length of Last Word](https://leetcode.com/problems/length-of-last-word)
Given a string s consists of upper/lower-case alphabets and empty space characters `' '`,return the length of last word (last word means the last appearing word if we loop from left to right) in the string.

If the last word does not exist, return 0.

**Note:**
A word is defined as a **maximal substring** consisting of non-space characters only.

**Example :**
```
Input: "Hello World"
Output: 5
```
[back to top](#menu)

---
## [#64 Minimum Path Sum](https://leetcode.com/problems/minimum-path-sum)
Given a *m* x *n* grid filled with non-negative numbers, find a path from top left to bottom right which *minimizes* the sum of all numbers along its path.

**Note:** You can only move either down or right at any point in time.

**Example:**
```
Input:
[
  [1,3,1],
  [1,5,1],
  [4,2,1]
]
Output: 7
Explanation: Because the path 1→3→1→1→1 minimizes the sum.
```
[back to top](#menu)

---
## [#66 Plus One](https://leetcode.com/problems/plus-one)
Given a **non-empty** array of digits representing a non-negative integer, plus one to the integer.

The digits are stored such that the most significant digit is at the head of the list, and each element in the array contain a single digit.

You may assume the integer does not contain any leading zero, except the number 0 itself.

**Example 1:**
```
Input: [1,2,3]
Output: [1,2,4]
Explanation: The array represents the integer 123.
```
**Example 2:**
```
Input: [4,3,2,1]
Output: [4,3,2,2]
Explanation: The array represents the integer 4321.
```
[back to top](#menu)

---
## [#67 Add Binary](https://leetcode.com/problems/add-binary)
Given two binary strings, return their sum (also a binary string).

The input strings are both **non-empty** and contains only characters `1` or `0`.

**Example 1:**
```
Input: a = "11", b = "1"
Output: "100"
```
**Example 2:**
```
Input: a = "1010", b = "1011"
Output: "10101"
```
[back to top](#menu)

---
## [#69 Sqrt(x)](https://leetcode.com/problems/sqrtx)
Implement `int sqrt(int x)`.

Compute and return the square root of *x*, where *x* is guaranteed to be a non-negative integer.

Since the return type is an integer, the decimal digits are truncated and only the integer part of the result is returned.

**Example 1:**
```
Input: 4
Output: 2
```
**Example 2:**
```
Input: 8
Output: 2
Explanation: The square root of 8 is 2.82842..., and since the decimal part is truncated, 2 is returned.
```
[back to top](#menu)

---
## #70 Climbing Stairs
You are climbing a stair case. It takes *n* steps to reach to the top.

Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?

**Note:** Given *n* will be a positive integer.

**Example 1:**
```
Input: 2
Output: 2
Explanation: There are two ways to climb to the top.
1. 1 step + 1 step
2. 2 steps
```
**Example 2:**
```
Input: 3
Output: 3
Explanation: There are three ways to climb to the top.
1. 1 step + 1 step + 1 step
2. 1 step + 2 steps
3. 2 steps + 1 step
```

[back to top](#menu)

---
## [#74 Search a 2D Matrix](https://leetcode.com/problems/search-a-2d-matrix)
Write an efficient algorithm that searches for a value in an `m x n` matrix. This matrix has the following properties:
  - Integers in each row are sorted from left to right.
  - The first integer of each row is greater than the last integer of the previous row.

**Example 1:**

![](https://assets.leetcode.com/uploads/2020/10/05/mat.jpg)
```
Input: matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3
Output: true
```
**Example 2:**

![](https://assets.leetcode.com/uploads/2020/10/05/mat2.jpg)
```
Input: matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13
Output: false
```
**Constraints:**
  - `m == matrix.length`
  - `n == matrix[i].length`
  - `1 <= m, n <= 100`
  - `-10^4 <= matrix[i][j], target <= 10^4`

[back to top](#menu)

---
## [#77 Combinations](https://leetcode.com/problems/combinations)
Given two integers `n` and `k`, return *all possible combinations of `k` numbers out of the range `[1, n]`*.

You may return the answer in **any order**.

**Example 1:**
```
Input: n = 4, k = 2
Output:
[
  [2,4],
  [3,4],
  [2,3],
  [1,2],
  [1,3],
  [1,4],
]
```
**Example 2:**
```
Input: n = 1, k = 1
Output: [[1]]
```
**Constraints:**
  - `1 <= n <= 20`
  - `1 <= k <= n`

[back to top](#menu)

---
## [#82 Remove Duplicates from Sorted List II](https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii)
Given the `head` of a sorted linked list, *delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list*. Return *the linked list **sorted** as well*.

**Example 1:**

![](https://assets.leetcode.com/uploads/2021/01/04/linkedlist1.jpg)
```
Input: head = [1,2,3,3,4,4,5]
Output: [1,2,5]
```
**Example 2:**

![](https://assets.leetcode.com/uploads/2021/01/04/linkedlist2.jpg)
```
Input: head = [1,1,1,2,3]
Output: [2,3]
```
**Constraints:**
  - The number of nodes in the list is in the range `[0, 300]`.
  - `-100 <= Node.val <= 100`
  - The list is guaranteed to be **sorted** in ascending order.

[back to top](#menu)

---
## [#83 Remove Duplicates from Sorted List](https://leetcode.com/problems/remove-duplicates-from-sorted-list)
Given a sorted linked list, delete all duplicates such that each element appear only *once*.

**Example 1:**
```
Input: 1->1->2
Output: 1->2
```
**Example 2:**
```
Input: 1->1->2->3->3
Output: 1->2->3
```
[back to top](#menu)

---
## [#88 Merge Sorted Array](https://leetcode.com/problems/merge-sorted-array)
Given two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array.

**Note:**
- The number of elements initialized in nums1 and nums2 are m and n respectively.
- You may assume that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2.

**Example:**
```
Input:
nums1 = [1,2,3,0,0,0], m = 3
nums2 = [2,5,6],       n = 3
Output: [1,2,2,3,5,6]
```
[back to top](#menu)

---
## [#100 Same Tree](https://leetcode.com/problems/same-tree)
Given two binary trees, write a function to check if they are the same or not.

Two binary trees are considered the same if they are structurally identical and the nodes have the same value.

**Example 1:**
```
Input:     1         1
          / \       / \
         2   3     2   3

        [1,2,3],   [1,2,3]

Output: true
```
**Example 2:**
```
Input:     1         1
          /           \
         2             2

        [1,2],     [1,null,2]

Output: false
```
**Example 3:**
```
Input:     1         1
          / \       / \
         2   1     1   2

        [1,2,1],   [1,1,2]

Output: false
```
[back to top](#menu)

---
## [#101 Symmetric Tree](https://leetcode.com/problems/symmetric-tree)
Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center).

For example, this binary tree `[1,2,2,3,4,4,3]` is symmetric:
```
    1
   / \
  2   2
 / \ / \
3  4 4  3
```
But the following `[1,2,2,null,3,null,3]` is not:
```
    1
   / \
  2   2
   \   \
   3    3
```
**Note:**

Bonus points if you could solve it both recursively and iteratively.

[back to top](#menu)

---
## [#104 Maximum Depth of Binary Tree](https://leetcode.com/problems/maximum-depth-of-binary-tree)
Given a binary tree, find its maximum depth.

The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.

**Note:** A leaf is a node with no children.

**Example 1:**

Given binary tree `[3,9,20,null,null,15,7]`,
```
    3
   / \
  9  20
    /  \
   15   7
```
return its depth = 3.

[back to top](#menu)

---
## [#107 Binary Tree Level Order Traversal II](https://leetcode.com/problems/binary-tree-level-order-traversal-ii)
Given a binary tree, return the *bottom-up level order* traversal of its nodes' values. (ie, from left to right, level by level from leaf to root).

For example:

Given binary tree `[3,9,20,null,null,15,7]`,
```
    3
   / \
  9  20
    /  \
   15   7
```
return its bottom-up level order traversal as:
```
[
  [15,7],
  [9,20],
  [3]
]
```
[back to top](#menu)

---
## [#108 Convert Sorted Array to Binary Search Tree](https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree)
Given an array where elements are sorted in ascending order, convert it to a height balanced BST.

For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of *every* node never differ by more than 1.

**Example:**
```
Given the sorted array: [-10,-3,0,5,9],

One possible answer is: [0,-3,9,-10,null,5], which represents the following height balanced BST:

      0
     / \
   -3   9
   /   /
 -10  5
```
[back to top](#menu)

---
## [#110 Balanced Binary Tree](https://leetcode.com/problems/balanced-binary-tree)
Given a binary tree, determine if it is height-balanced.

For this problem, a height-balanced binary tree is defined as:

> a binary tree in which the left and right subtrees of *every* node differ in height by no more than 1.

**Example 1:**

Given the following tree `[3,9,20,null,null,15,7]`:
```
    3
   / \
  9  20
    /  \
   15   7
```
Return true.

**Example 2:**

Given the following tree `[1,2,2,3,3,null,null,4,4]`:
```
       1
      / \
     2   2
    / \
   3   3
  / \
 4   4
```
Return false.

[back to top](#menu)

---
## [#111 Minimum Depth of Binary Tree](https://leetcode.com/problems/minimum-depth-of-binary-tree)
Given a binary tree, find its minimum depth.

The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.

**Note:** A leaf is a node with no children.

**Example:**

Given binary tree `[3,9,20,null,null,15,7]`,
```
    3
   / \
  9  20
    /  \
   15   7
```
return its minimum depth = 2.

[back to top](#menu)

---
## [#112 Path Sum](https://leetcode.com/problems/path-sum)
Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum.

**Note:** A leaf is a node with no children.

**Example:**

Given the below binary tree and `sum = 22`,
```
      5
     / \
    4   8
   /   / \
  11  13  4
 /  \      \
7    2      1
```
return true, as there exist a root-to-leaf path `5->4->11->2` which sum is 22.

[back to top](#menu)

---
## [#116 Populating Next Right Pointers in Each Node](https://leetcode.com/problems/populating-next-right-pointers-in-each-node)
You are given a **perfect binary tree** where all leaves are on the same level, and every parent has two children. The binary tree has the following definition:

```
struct Node {
  int val;
  Node *left;
  Node *right;
  Node *next;
}
```

Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to `NULL`.

Initially, all next pointers are set to `NULL`.

**Follow up:**
  - You may only use constant extra space.
  - Recursive approach is fine, you may assume implicit stack space does not count as extra space for this problem.

**Example 1:**

![](https://assets.leetcode.com/uploads/2019/02/14/116_sample.png)
```
Input: root = [1,2,3,4,5,6,7]
Output: [1,#,2,3,#,4,5,6,7,#]
Explanation: Given the above perfect binary tree (Figure A), your function should populate each next pointer to point to its next right node, just like in Figure B. The serialized output is in level order as connected by the next pointers, with '#' signifying the end of each level.
```
**Constraints:**
  - The number of nodes in the given tree is less than `4096`.
  - `-1000 <= node.val <= 1000`

[back to top](#menu)

---
## [#118 Pascal's Triangle](https://leetcode.com/problems/pascals-triangle)
Given a non-negative integer *numRows*, generate the first *numRows* of Pascal's triangle.

![](https://upload.wikimedia.org/wikipedia/commons/0/0d/PascalTriangleAnimated2.gif)

In Pascal's triangle, each number is the sum of the two numbers directly above it.

**Example:**
```
Input: 5
Output:
[
     [1],
    [1,1],
   [1,2,1],
  [1,3,3,1],
 [1,4,6,4,1]
]
```
[back to top](#menu)

---
## [#119 Pascal's Triangle II](https://leetcode.com/problems/pascals-triangle-ii)
Given a non-negative index *k* where *k* ≤ 33, return the kth index row of the Pascal's triangle.

Note that the row index starts from 0.

![](https://upload.wikimedia.org/wikipedia/commons/0/0d/PascalTriangleAnimated2.gif)

n Pascal's triangle, each number is the sum of the two numbers directly above it.

**Example:**
```
Input: 3
Output: [1,3,3,1]
```
**Follow up:**

Could you optimize your algorithm to use only *O*(k) extra space?

[back to top](#menu)

---
## [#120 Triangle](https://leetcode.com/problems/triangle)
Given a `triangle` array, return *the minimum path sum from top to bottom*.

For each step, you may move to an adjacent number of the row below. More formally, if you are on index `i` on the current row, you may move to either index `i` or index `i + 1` on the next row.

**Example 1:**
```
Input: triangle = [[2],[3,4],[6,5,7],[4,1,8,3]]
Output: 11
Explanation: The triangle looks like:
   2
  3 4
 6 5 7
4 1 8 3
The minimum path sum from top to bottom is 2 + 3 + 5 + 1 = 11 (underlined above).
```
**Example 2:**
```
Input: triangle = [[-10]]
Output: -10
```
**Constraints:**
  - `1 <= triangle.length <= 200`
  - `triangle[0].length == 1`
  - `triangle[i].length == triangle[i - 1].length + 1`
  - `-10^4 <= triangle[i][j] <= 10^4`

**Follow up:** Could you do this using only `O(n)` extra space, where `n` is the total number of rows in the triangle?

[back to top](#menu)

---
## [#121 Best Time to Buy and Sell Stock](https://leetcode.com/problems/best-time-to-buy-and-sell-stock)
Say you have an array for which the *i*th element is the price of a given stock on day *i*.

If you were only permitted to complete at most one transaction (i.e., buy one and sell one share of the stock), design an algorithm to find the maximum profit.

Note that you cannot sell a stock before you buy one.

**Example 1:**
```
Input: [7,1,5,3,6,4]
Output: 5
Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.
             Not 7-1 = 6, as selling price needs to be larger than buying price.
```
**Example 2:**
```
Input: [7,6,4,3,1]
Output: 0
Explanation: In this case, no transaction is done, i.e. max profit = 0.
```
[back to top](#menu)

---
## [#122 Best Time to Buy and Sell Stock II](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii)
Say you have an array for which the *i*th element is the price of a given stock on day *i*.

Design an algorithm to find the maximum profit. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times).

**Note:** You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again).

**Example 1:**
```
Input: [7,1,5,3,6,4]
Output: 7
Explanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.
             Then buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.
```
**Example 2:**
```
Input: [1,2,3,4,5]
Output: 4
Explanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.
             Note that you cannot buy on day 1, buy on day 2 and sell them later, as you are
             engaging multiple transactions at the same time. You must sell before buying again.
```
**Example 3:**
```
Input: [7,6,4,3,1]
Output: 0
Explanation: In this case, no transaction is done, i.e. max profit = 0.
```
[back to top](#menu)

---
## [#124 Binary Tree Maximum Path Sum](https://leetcode.com/problems/binary-tree-maximum-path-sum)
Given a **non-empty** binary tree, find the maximum path sum.

For this problem, a path is defined as any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The path must contain **at least one node** and does not need to go through the root.

**Example 1:**
```
Input: [1,2,3]

       1
      / \
     2   3

Output: 6
```
**Example 2:**
```
Input: [-10,9,20,null,null,15,7]

   -10
   / \
  9  20
    /  \
   15   7

Output: 42
```
[back to top](#menu)

---
## [#125 Valid Palindrome](https://leetcode.com/problems/valid-palindrome)
Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases.

**Note:** For the purpose of this problem, we define empty string as valid palindrome.

**Example 1:**
```
Input: "A man, a plan, a canal: Panama"
Output: true
```
**Example 2:**
```
Input: "race a car"
Output: false
```
[back to top](#menu)

---
## [#136 Single Number](https://leetcode.com/problems/single-number)
Given a **non-empty** array of integers, every element appears *twice* except for one. Find that single one.

**Note:**

Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?

**Example 1:**
```
Input: [2,2,1]
Output: 1
```
**Example 2:**
```
Input: [4,1,2,1,2]
Output: 4
```
[back to top](#menu)

---
## [#141 Linked List Cycle](https://leetcode.com/problems/linked-list-cycle)
Given a linked list, determine if it has a cycle in it.

To represent a cycle in the given linked list, we use an integer `pos` which represents the position (0-indexed) in the linked list where tail connects to. If `pos` is `-1`, then there is no cycle in the linked list.

**Example 1:**
```
Input: head = [3,2,0,-4], pos = 1
Output: true
Explanation: There is a cycle in the linked list, where tail connects to the second node.
```
![](https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist.png)

**Example 2:**
```
Input: head = [1,2], pos = 0
Output: true
Explanation: There is a cycle in the linked list, where tail connects to the first node.
```
![](https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test2.png)

**Example 3:**
```
Input: head = [1], pos = -1
Output: false
Explanation: There is no cycle in the linked list.
```
![](https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test3.png)

**Follow up:**

Can you solve it using *O(1)* (i.e. constant) memory?

[back to top](#menu)

---
## [#146 LRU Cache](https://leetcode.com/problems/lru-cache)
Design and implement a data structure for [Least Recently Used (LRU) cache](https://en.wikipedia.org/wiki/Cache_replacement_policies#LRU). It should support the following operations: `get` and `put`.

`get(key)` - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1.

`put(key, value)` - Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item.

The cache is initialized with a **positive** capacity.

**Follow up:**

Could you do both operations in **O(1)** time complexity?

**Example:**
```
LRUCache cache = new LRUCache( 2 /* capacity */ );

cache.put(1, 1);
cache.put(2, 2);
cache.get(1);       // returns 1
cache.put(3, 3);    // evicts key 2
cache.get(2);       // returns -1 (not found)
cache.put(4, 4);    // evicts key 1
cache.get(1);       // returns -1 (not found)
cache.get(3);       // returns 3
cache.get(4);       // returns 4
```

[back to top](#menu)

---
## [#153 Find Minimum in Rotated Sorted Array](https://leetcode.com/problems/find-minimum-in-rotated-sorted-array)
Suppose an array of length `n` sorted in ascending order is **rotated** between `1` and `n` times. For example, the array `nums = [0,1,2,4,5,6,7]` might become:

  - `[4,5,6,7,0,1,2]` if it was rotated `4` times.
  - `[0,1,2,4,5,6,7]` if it was rotated `7` times.

Notice that **rotating** an array `[a[0], a[1], a[2], ..., a[n-1]]` 1 time results in the array `[a[n-1], a[0], a[1], a[2], ..., a[n-2]]`.

Given the sorted rotated array `nums` of **unique** elements, return *the minimum element of this array*.

**Example 1:**
```
Input: nums = [3,4,5,1,2]
Output: 1
Explanation: The original array was [1,2,3,4,5] rotated 3 times.
```
**Example 2:**
```
Input: nums = [4,5,6,7,0,1,2]
Output: 0
Explanation: The original array was [0,1,2,4,5,6,7] and it was rotated 4 times.
```
**Example 3:**
```
Input: nums = [11,13,15,17]
Output: 11
Explanation: The original array was [11,13,15,17] and it was rotated 4 times.
```
**Constraints:**
  - `n == nums.length`
  - `1 <= n <= 5000`
  - `-5000 <= nums[i] <= 5000`
  - All the integers of `nums` are **unique**.
  - `nums` is sorted and rotated between `1` and `n` times.

[back to top](#menu)

---
## [#155 Min Stack](https://leetcode.com/problems/min-stack)
Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.
- push(x) -- Push element x onto stack.
- pop() -- Removes the element on top of the stack.
- top() -- Get the top element.
- getMin() -- Retrieve the minimum element in the stack.

**Example:**
```
MinStack minStack = new MinStack();
minStack.push(-2);
minStack.push(0);
minStack.push(-3);
minStack.getMin();   --> Returns -3.
minStack.pop();
minStack.top();      --> Returns 0.
minStack.getMin();   --> Returns -2.
```
[back to top](#menu)

---
## [#160 Intersection of Two Linked Lists](https://leetcode.com/problems/intersection-of-two-linked-lists)
Write a program to find the node at which the intersection of two singly linked lists begins.

For example, the following two linked lists:

![](https://assets.leetcode.com/uploads/2018/12/13/160_statement.png)

begin to intersect at node c1.

**Example 1:**

![](https://assets.leetcode.com/uploads/2018/12/13/160_example_1.png)
```
Input: intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3
Output: Reference of the node with value = 8
Input Explanation: The intersected node's value is 8 (note that this must not be 0 if the two lists intersect). From the head of A, it reads as [4,1,8,4,5]. From the head of B, it reads as [5,0,1,8,4,5]. There are 2 nodes before the intersected node in A; There are 3 nodes before the intersected node in B.
```
**Example 2:**

![](https://assets.leetcode.com/uploads/2018/12/13/160_example_2.png)
```
Input: intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1
Output: Reference of the node with value = 2
Input Explanation: The intersected node's value is 2 (note that this must not be 0 if the two lists intersect). From the head of A, it reads as [0,9,1,2,4]. From the head of B, it reads as [3,2,4]. There are 3 nodes before the intersected node in A; There are 1 node before the intersected node in B.
```
**Example 3:**

![](https://assets.leetcode.com/uploads/2018/12/13/160_example_3.png)
```
Input: intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2
Output: null
Input Explanation: From the head of A, it reads as [2,6,4]. From the head of B, it reads as [1,5]. Since the two lists do not intersect, intersectVal must be 0, while skipA and skipB can be arbitrary values.
Explanation: The two lists do not intersect, so return null.
```
**Notes:**
- If the two linked lists have no intersection at all, return `null`.
- The linked lists must retain their original structure after the function returns.
- You may assume there are no cycles anywhere in the entire linked structure.
- Your code should preferably run in O(n) time and use only O(1) memory.

[back to top](#menu)

---
## [#162 Find Peak Element](https://leetcode.com/problems/find-peak-element)
A peak element is an element that is strictly greater than its neighbors.

Given an integer array `nums`, find a peak element, and return its index. If the array contains multiple peaks, return the index to **any of the peaks**.

You may imagine that **nums[-1] = nums[n] = -∞**.

You must write an algorithm that runs in `O(log n)` time.

**Example 1:**
```
Input: nums = [1,2,3,1]
Output: 2
Explanation: 3 is a peak element and your function should return the index number 2.
```
**Example 2:**
```
Input: nums = [1,2,1,3,5,6,4]
Output: 5
Explanation: Your function can return either index number 1 where the peak element is 2, or index number 5 where the peak element is 6.
```
**Constraints:**
  - `1 <= nums.length <= 1000`
  - `-2^31 <= nums[i] <= 2^31 - 1`
  - `nums[i] != nums[i + 1]` for all valid `i`.

[back to top](#menu)

---
## [#167 Two Sum II - Input array is sorted](https://leetcode.com/problems/two-sum-ii-input-array-is-sorted)
Given an array of integers that is already ***sorted in ascending order***, find two numbers such that they add up to a specific target number.

The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2.

**Note:**
- Your returned answers (both index1 and index2) are not zero-based.
- You may assume that each input would have *exactly* one solution and you may not use the *same* element twice.

**Example:**
```
Input: numbers = [2,7,11,15], target = 9
Output: [1,2]
Explanation: The sum of 2 and 7 is 9. Therefore index1 = 1, index2 = 2.
```
[back to top](#menu)

---
## [#168 Excel Sheet Column Title](https://leetcode.com/problems/excel-sheet-column-title)
Given a positive integer, return its corresponding column title as appear in an Excel sheet.

For example:
```
    1 -> A
    2 -> B
    3 -> C
    ...
    26 -> Z
    27 -> AA
    28 -> AB
    ...
```
**Example 1:**
```
Input: 1
Output: "A"
```
**Example 2:**
```
Input: 28
Output: "AB"
```
**Example 3:**
```
Input: 701
Output: "ZY"
```
[back to top](#menu)

---
## [#169 Majority Element](https://leetcode.com/problems/majority-element)
Given an array of size *n*, find the majority element. The majority element is the element that appears **more than** `⌊ n/2 ⌋` times.

You may assume that the array is non-empty and the majority element always exist in the array.

**Example 1:**
```
Input: [3,2,3]
Output: 3
```
**Example 2:**
```
Input: [2,2,1,1,1,2,2]
Output: 2
```
[back to top](#menu)

---
## [#171 Excel Sheet Column Number](https://leetcode.com/problems/excel-sheet-column-number)
Given a column title as appear in an Excel sheet, return its corresponding column number.

For example:
```
    A -> 1
    B -> 2
    C -> 3
    ...
    Z -> 26
    AA -> 27
    AB -> 28
    ...
```
**Example 1:**
```
Input: "A"
Output: 1
```
**Example 2:**
```
Input: "AB"
Output: 28
```
**Example 3:**
```
Input: "ZY"
Output: 701
```
[back to top](#menu)

---
## [#172 Factorial Trailing Zeroes](https://leetcode.com/problems/factorial-trailing-zeroes)
Given an integer *n*, return the number of trailing zeroes in *n*!.

**Example 1:**
```
Input: 3
Output: 0
Explanation: 3! = 6, no trailing zero.
```
**Example 2:**
```
Input: 5
Output: 1
Explanation: 5! = 120, one trailing zero.
```
[back to top](#menu)

---
## [#175 Combine Two Tables](https://leetcode.com/problems/combine-two-tables)
Table: `Person`
```
+-------------+---------+
| Column Name | Type    |
+-------------+---------+
| PersonId    | int     |
| FirstName   | varchar |
| LastName    | varchar |
+-------------+---------+
PersonId is the primary key column for this table.
```
Table: `Address`
```
+-------------+---------+
| Column Name | Type    |
+-------------+---------+
| AddressId   | int     |
| PersonId    | int     |
| City        | varchar |
| State       | varchar |
+-------------+---------+
AddressId is the primary key column for this table.
```
Write a SQL query for a report that provides the following information for each person in the Person table, regardless if there is an address for each of those people:
```
FirstName, LastName, City, State
```
[back to top](#menu)

---
## [#176 Second Highest Salary](https://leetcode.com/problems/second-highest-salary)
Write a SQL query to get the second highest salary from the `Employee` table.
```
+----+--------+
| Id | Salary |
+----+--------+
| 1  | 100    |
| 2  | 200    |
| 3  | 300    |
+----+--------+
```
For example, given the above Employee table, the query should return `200` as the second highest salary. If there is no second highest salary, then the query should return `null`.
```
+---------------------+
| SecondHighestSalary |
+---------------------+
| 200                 |
+---------------------+
```

[back to top](#menu)

---
## [#179 Largest Number](https://leetcode.com/problems/largest-number)
Given a list of non-negative integers `nums`, arrange them such that they form the largest number.

**Note:** The result may be very large, so you need to return a string instead of an integer.

**Example 1:**
```
Input: nums = [10,2]
Output: "210"
```
**Example 2:**
```
Input: nums = [3,30,34,5,9]
Output: "9534330"
```
**Example 3:**
```
Input: nums = [1]
Output: "1"
```
**Example 4:**
```
Input: nums = [10]
Output: "10"
```
**Constraints:**
  - `1 <= nums.length <= 100`
  - `0 <= nums[i] <= 10^9`

[back to top](#menu)

---
## [#181 Employees Earning More Than Their Managers](https://leetcode.com/problems/employees-earning-more-than-their-managers)
The `Employee` table holds all employees including their managers. Every employee has an Id, and there is also a column for the manager Id.
```
+----+-------+--------+-----------+
| Id | Name  | Salary | ManagerId |
+----+-------+--------+-----------+
| 1  | Joe   | 70000  | 3         |
| 2  | Henry | 80000  | 4         |
| 3  | Sam   | 60000  | NULL      |
| 4  | Max   | 90000  | NULL      |
+----+-------+--------+-----------+
```
Given the `Employee` table, write a SQL query that finds out employees who earn more than their managers. For the above table, Joe is the only employee who earns more than his manager.
```
+----------+
| Employee |
+----------+
| Joe      |
+----------+
```
[back to top](#menu)

---
## [#182 Duplicate Emails](https://leetcode.com/problems/duplicate-emails)
Write a SQL query to find all duplicate emails in a table named `Person`.
```
+----+---------+
| Id | Email   |
+----+---------+
| 1  | a@b.com |
| 2  | c@d.com |
| 3  | a@b.com |
+----+---------+
```
For example, your query should return the following for the above table:
```
+---------+
| Email   |
+---------+
| a@b.com |
+---------+
```
**NOTE:**All emails are in lowercase.

[back to top](#menu)

---
## [#183 Customers Who Never Order](https://leetcode.com/problems/customers-who-never-order)
Suppose that a website contains two tables, the `Customers` table and the `Orders` table. Write a SQL query to find all customers who never order anything.

Table: `Customers`.
```
+----+-------+
| Id | Name  |
+----+-------+
| 1  | Joe   |
| 2  | Henry |
| 3  | Sam   |
| 4  | Max   |
+----+-------+
```
Table: `Orders`.
```
+----+------------+
| Id | CustomerId |
+----+------------+
| 1  | 3          |
| 2  | 1          |
+----+------------+
```
Using the above tables as example, return the following:
```
+-----------+
| Customers |
+-----------+
| Henry     |
| Max       |
+-----------+
```
[back to top](#menu)

---
## [#189 Rotate Array](https://leetcode.com/problems/rotate-array)
Given an array, rotate the array to the right by *k* steps, where *k* is non-negative.

**Example 1:**
```
Input: [1,2,3,4,5,6,7] and k = 3
Output: [5,6,7,1,2,3,4]
Explanation:
rotate 1 steps to the right: [7,1,2,3,4,5,6]
rotate 2 steps to the right: [6,7,1,2,3,4,5]
rotate 3 steps to the right: [5,6,7,1,2,3,4]
```
**Example 2:**
```
Input: [-1,-100,3,99] and k = 2
Output: [3,99,-1,-100]
Explanation:
rotate 1 steps to the right: [99,-1,-100,3]
rotate 2 steps to the right: [3,99,-1,-100]
```
**Note:**
- Try to come up as many solutions as you can, there are at least 3 different ways to solve this problem.
- Could you do it in-place with O(1) extra space?

[back to top](#menu)

---
## [#190 Reverse Bits](https://leetcode.com/problems/reverse-bits)
Reverse bits of a given 32 bits unsigned integer.

**Example 1:**
```
Input: 00000010100101000001111010011100
Output: 00111001011110000010100101000000
Explanation: The input binary string 00000010100101000001111010011100 represents the unsigned integer 43261596, so return 964176192 which its binary representation is 00111001011110000010100101000000.
```
**Example 2:**
```
Input: 11111111111111111111111111111101
Output: 10111111111111111111111111111111
Explanation: The input binary string 11111111111111111111111111111101 represents the unsigned integer 4294967293, so return 3221225471 which its binary representation is 10111111111111111111111111111111.
```
**Note:**
- Note that in some languages such as Java, there is no unsigned integer type. In this case, both input and output will be given as signed integer type and should not affect your implementation, as the internal binary representation of the integer is the same whether it is signed or unsigned.
- In Java, the compiler represents the signed integers using [2's complement notation](https://en.wikipedia.org/wiki/Two%27s_complement). Therefore, in **Example 2** above the input represents the signed integer `-3` and the output represents the signed integer `-1073741825`.

**Follow up:**

If this function is called many times, how would you optimize it?

[back to top](#menu)

---
## [#191 Number of 1 Bits](https://leetcode.com/problems/basic-calculator)
Write a function that takes an unsigned integer and return the number of '1' bits it has (also known as the Hamming weight).

**Example 1:**
```
Input: 00000000000000000000000000001011
Output: 3
Explanation: The input binary string 00000000000000000000000000001011 has a total of three '1' bits.
```
**Example 2:**
```
Input: 00000000000000000000000010000000
Output: 1
Explanation: The input binary string 00000000000000000000000010000000 has a total of one '1' bit.
```
**Example 3:**
```
Input: 11111111111111111111111111111101
Output: 31
Explanation: The input binary string 11111111111111111111111111111101 has a total of thirty one '1' bits.
```
**Note:**
- Note that in some languages such as Java, there is no unsigned integer type. In this case, the input will be given as signed integer type and should not affect your implementation, as the internal binary representation of the integer is the same whether it is signed or unsigned.
- In Java, the compiler represents the signed integers using [2's complement notation](https://en.wikipedia.org/wiki/Two%27s_complement). Therefore, in **Example 3** above the input represents the signed integer `-3`.

**Follow up:**

If this function is called many times, how would you optimize it?

[back to top](#menu)

---
## [#193 Valid Phone Numbers](https://leetcode.com/problems/basic-calculator)
Given a text file `file.txt` that contains list of phone numbers (one per line), write a one liner bash script to print all valid phone numbers.

You may assume that a valid phone number must appear in one of the following two formats: (xxx) xxx-xxxx or xxx-xxx-xxxx. (x means a digit)

You may also assume each line in the text file must not contain leading or trailing white spaces.

**Example:**

Assume that `file.txt` has the following content:
```
987-123-4567
123 456 7890
(123) 456-7890
```
Your script should output the following valid phone numbers:
```
987-123-4567
(123) 456-7890
```
[back to top](#menu)

---
## [#195 Tenth Line](https://leetcode.com/problems/tenth-line)
Given a text file `file.txt`, print just the 10th line of the file.

**Example:**

Assume that `file.txt` has the following content:
```
Line 1
Line 2
Line 3
Line 4
Line 5
Line 6
Line 7
Line 8
Line 9
Line 10
```
Your script should output the tenth line, which is:
```
Line 10
```
**Note:**
1. If the file contains less than 10 lines, what should you output?
2. There's at least three different solutions. Try to explore all possibilities.

[back to top](#menu)

---
## [#196 Delete Duplicate Emails](https://leetcode.com/problems/delete-duplicate-emails)
Write a SQL query to **delete** all duplicate email entries in a table named `Person`, keeping only unique emails based on its *smallest* **Id**.
```
+----+------------------+
| Id | Email            |
+----+------------------+
| 1  | john@example.com |
| 2  | bob@example.com  |
| 3  | john@example.com |
+----+------------------+
Id is the primary key column for this table.
```
For example, after running your query, the above `Person` table should have the following rows:
```
+----+------------------+
| Id | Email            |
+----+------------------+
| 1  | john@example.com |
| 2  | bob@example.com  |
+----+------------------+
```
**Note:**

Your output is the whole `Person` table after executing your sql. Use `delete` statement.

[back to top](#menu)

---
## [#197 Rising Temperature](https://leetcode.com/problems/rising-temperature)
Given a `Weather` table, write a SQL query to find all dates' Ids with higher temperature compared to its previous (yesterday's) dates.
```
+---------+------------------+------------------+
| Id(INT) | RecordDate(DATE) | Temperature(INT) |
+---------+------------------+------------------+
|       1 |       2015-01-01 |               10 |
|       2 |       2015-01-02 |               25 |
|       3 |       2015-01-03 |               20 |
|       4 |       2015-01-04 |               30 |
+---------+------------------+------------------+
```
For example, return the following Ids for the above `Weather` table:
```
+----+
| Id |
+----+
|  2 |
|  4 |
+----+
```
[back to top](#menu)

---
## [#198 House Robber](https://leetcode.com/problems/house-robber)
You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and **it will automatically contact the police if two adjacent houses were broken into on the same night**.

Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight **without alerting the police**.

**Example 1:**
```
Input: [1,2,3,1]
Output: 4
Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).
             Total amount you can rob = 1 + 3 = 4.
```
**Example 2:**
```
Input: [2,7,9,3,1]
Output: 12
Explanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).
             Total amount you can rob = 2 + 9 + 1 = 12.
```
[back to top](#menu)

---
## [#200 Number of Islands](https://leetcode.com/problems/number-of-islands)
Given a 2d grid map of `'1'`s (land) and `'0'`s (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.

**Example 1:**
```
Input:
11110
11010
11000
00000

Output: 1
```
**Example 2:**
```
Input:
11000
11000
00100
00011

Output: 3
```
[back to top](#menu)

---
## [#201 Bitwise AND of Numbers Range](https://leetcode.com/problems/bitwise-and-of-numbers-range)
Given a range [m, n] where 0 <= m <= n <= 2147483647, return the bitwise AND of all numbers in this range, inclusive.

**Example 1:**
```
Input: [5,7]
Output: 4
```
**Example 2:**
```
Input: [0,1]
Output: 0
```
[back to top](#menu)

---
## [#202 Happy Number](https://leetcode.com/problems/happy-number)
Write an algorithm to determine if a number `n` is "happy".

A happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it **loops endlessly in a cycle** which does not include 1. Those numbers for which this process **ends in 1** are happy numbers.

Return True if `n` is a happy number, and False if not.

**Example:**
```
Input: 19
Output: true
Explanation:
1^2 + 9^2 = 82
8^2 + 2^2 = 68
6^2 + 8^2 = 100
1^2 + 0^2 + 0^2 = 1
```
[back to top](#menu)

---
## [#203 Remove Linked List Elements](https://leetcode.com/problems/remove-linked-list-elements)
Remove all elements from a linked list of integers that have value ***val***.

**Example:**
```
Input:  1->2->6->3->4->5->6, val = 6
Output: 1->2->3->4->5
```
[back to top](#menu)

---
## [#204 Count Primes](https://leetcode.com/problems/count-primes)
Count the number of prime numbers less than a non-negative number, ***n***.

**Example:**
```
Input: 10
Output: 4
Explanation: There are 4 prime numbers less than 10, they are 2, 3, 5, 7.
```
[back to top](#menu)

---
## [#205 Isomorphic Strings](https://leetcode.com/problems/isomorphic-strings)
Given two strings ***s*** and ***t***, determine if they are isomorphic.

Two strings are isomorphic if the characters in ***s*** can be replaced to get ***t***.

All occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character but a character may map to itself.

**Example 1:**
```
Input: s = "egg", t = "add"
Output: true
```
**Example 2:**
```
Input: s = "foo", t = "bar"
Output: false
```
**Example 3:**
```
Input: s = "paper", t = "title"
Output: true
```
**Note:**

You may assume both ***s*** and ***t*** have the same length.

[back to top](#menu)

---
## [#206 Reverse Linked List](https://leetcode.com/problems/reverse-linked-list)
Reverse a singly linked list.

**Example:**
```
Input: 1->2->3->4->5->NULL
Output: 5->4->3->2->1->NULL
```

**Follow up:**

A linked list can be reversed either iteratively or recursively. Could you implement both?

[back to top](#menu)

---
## [#208 Implement Trie (Prefix Tree)](https://leetcode.com/problems/implement-trie-prefix-tree)
Implement a trie with `insert`, `search`, and `startsWith` methods.

**Example:**
```
Trie trie = new Trie();

trie.insert("apple");
trie.search("apple");   // returns true
trie.search("app");     // returns false
trie.startsWith("app"); // returns true
trie.insert("app");   
trie.search("app");     // returns true
```
**Note:**
- You may assume that all inputs are consist of lowercase letters `a-z`.
- All inputs are guaranteed to be non-empty strings.

[back to top](#menu)

---
## [#217 Contains Duplicate](https://leetcode.com/problems/contains-duplicate)
Given an array of integers, find if the array contains any duplicates.

Your function should return true if any value appears at least twice in the array, and it should return false if every element is distinct.

**Example 1:**
```
Input: [1,2,3,1]
Output: true
```
**Example 2:**
```
Input: [1,2,3,4]
Output: false
```
**Example 3:**
```
Input: [1,1,1,3,3,4,3,2,4,2]
Output: true
```
[back to top](#menu)

---
## [#219 Contains Duplicate II](https://leetcode.com/problems/contains-duplicate-ii)
Given an array of integers and an integer *k*, find out whether there are two distinct indices *i* and *j* in the array such that **nums[i]** = **nums[j]** and the **absolute** difference between *i* and *j* is at most *k*.

**Example 1:**
```
Input: nums = [1,2,3,1], k = 3
Output: true
```
**Example 2:**
```
Input: nums = [1,0,1,1], k = 1
Output: true
```
**Example 3:**
```
Input: nums = [1,2,3,1,2,3], k = 2
Output: false
```
[back to top](#menu)

---
## [#221 Maximal Square](https://leetcode.com/problems/maximal-square)
Given a 2D binary matrix filled with 0's and 1's, find the largest square containing only 1's and return its area.

**Example:**
```
Input:

1 0 1 0 0
1 0 1 1 1
1 1 1 1 1
1 0 0 1 0

Output: 4
```
[back to top](#menu)

---
## [#224 Basic Calculator](https://leetcode.com/problems/basic-calculator)
Implement a basic calculator to evaluate a simple expression string.

The expression string may contain open `(` and closing parentheses `)`, the plus `+` or minus sign `-`, **non-negative** integers and empty spaces` `.

**Example 1:**
```
Input: "1 + 1"
Output: 2
```
**Example 2:**
```
Input: " 2-1 + 2 "
Output: 3
```
**Example 3:**
```
Input: "(1+(4+5+2)-3)+(6+8)"
Output: 23
```
**Note:**
- You may assume that the given expression is always valid.
- **Do not** use the `eval` built-in library function.

[back to top](#menu)

---
## [#225 Implement Stack using Queues](https://leetcode.com/problems/implement-stack-using-queues)
Implement the following operations of a stack using queues.
- push(x) -- Push element x onto stack.
- pop() -- Removes the element on top of the stack.
- top() -- Get the top element.
- empty() -- Return whether the stack is empty.

**Example:**
```
MyStack stack = new MyStack();

stack.push(1);
stack.push(2);  
stack.top();   // returns 2
stack.pop();   // returns 2
stack.empty(); // returns false
```
**Notes:**
- You must use *only* standard operations of a queue -- which means only `push to back`, `peek/pop from front`, `size`, and `is empty` operations are valid.
- Depending on your language, queue may not be supported natively. You may simulate a queue by using a list or deque (double-ended queue), as long as you use only standard operations of a queue.
- You may assume that all operations are valid (for example, no pop or top operations will be called on an empty stack).

[back to top](#menu)

---
## [#226 Invert Binary Tree](https://leetcode.com/problems/invert-binary-tree)
Invert a binary tree.

**Example:**

Input:
```
     4
   /   \
  2     7
 / \   / \
1   3 6   9
```
Output:
```
     4
   /   \
  7     2
 / \   / \
9   6 3   1
```
**Trivia:**

This problem was inspired by [this original tweet](https://twitter.com/mxcl/status/608682016205344768) by [Max Howell](https://twitter.com/mxcl):
> Google: 90% of our engineers use the software you wrote (Homebrew), but you can’t invert a binary tree on a whiteboard so f*** off.

[back to top](#menu)

---
## [#231 Power of Two](https://leetcode.com/problems/power-of-two)
Given an integer, write a function to determine if it is a power of two.

**Example 1:**
```
Input: 1
Output: true
Explanation: 2^0 = 1
```
**Example 2:**
```
Input: 16
Output: true
Explanation: 2^4 = 16
```
**Example 3:**
```
Input: 218
Output: false
```
[back to top](#menu)

---
## [#232 Implement Queue using Stacks](https://leetcode.com/problems/implement-queue-using-stacks)
Implement the following operations of a queue using stacks.
- push(x) -- Push element x to the back of queue.
- pop() -- Removes the element from in front of queue.
- peek() -- Get the front element.
- empty() -- Return whether the queue is empty.

**Example:**
```
MyQueue queue = new MyQueue();

queue.push(1);
queue.push(2);  
queue.peek();  // returns 1
queue.pop();   // returns 1
queue.empty(); // returns false
```
**Notes:**
- You must use *only* standard operations of a stack -- which means only `push to top`, `peek/pop from top`, `size`, and `is empty` operations are valid.
- Depending on your language, stack may not be supported natively. You may simulate a stack by using a list or deque (double-ended queue), as long as you use only standard operations of a stack.
- You may assume that all operations are valid (for example, no pop or peek operations will be called on an empty queue).

[back to top](#menu)

---
## [#234 Palindrome Linked List](https://leetcode.com/problems/palindrome-linked-list)
Given a singly linked list, determine if it is a palindrome.

**Example 1:**
```
Input: 1->2
Output: false
```
**Example 2:**
```
Input: 1->2->2->1
Output: true
```
**Follow up:**

Could you do it in O(n) time and O(1) space?

[back to top](#menu)

---
## [#235 Lowest Common Ancestor of a Binary Search Tree](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree)
Given a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST.

According to the [definition of LCA on Wikipedia](https://en.wikipedia.org/wiki/Lowest_common_ancestor): “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow **a node to be a descendant of itself**).”

Given binary search tree:  root = [6,2,8,0,4,7,9,null,null,3,5]

![](https://assets.leetcode.com/uploads/2018/12/14/binarysearchtree_improved.png)

**Example 1:**
```
Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8
Output: 6
Explanation: The LCA of nodes 2 and 8 is 6.
```
**Example 2:**
```
Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4
Output: 2
Explanation: The LCA of nodes 2 and 4 is 2, since a node can be a descendant of itself according to the LCA definition.
```
**Note:**
- All of the nodes' values will be unique.
- p and q are different and both values will exist in the BST.

[back to top](#menu)

---
## [#237 Delete Node in a Linked List](https://leetcode.com/problems/delete-node-in-a-linked-list)
Write a function to delete a node (except the tail) in a singly linked list, given only access to that node.

Given linked list -- head = [4,5,1,9], which looks like following:

![](https://assets.leetcode.com/uploads/2018/12/28/237_example.png)

**Example 1:**
```
Input: head = [4,5,1,9], node = 5
Output: [4,1,9]
Explanation: You are given the second node with value 5, the linked list should become 4 -> 1 -> 9 after calling your function.
```
**Example 2:**
```
Input: head = [4,5,1,9], node = 1
Output: [4,5,9]
Explanation: You are given the third node with value 1, the linked list should become 4 -> 5 -> 9 after calling your function.
```
**Note:**
- The linked list will have at least two elements.
- All of the nodes' values will be unique.
- The given node will not be the tail and it will always be a valid node of the linked list.
- Do not return anything from your function.

[back to top](#menu)

---
## [#238 Product of Array Except Self](https://leetcode.com/problems/product-of-array-except-self)
Given an array `nums` of *n* integers where *n* > 1,  return an array `output` such that `output[i]` is equal to the product of all the elements of `nums` except `nums[i]`.

**Example:**
```
Input:  [1,2,3,4]
Output: [24,12,8,6]
```
**Constraint:** It's guaranteed that the product of the elements of any prefix or suffix of the array (including the whole array) fits in a 32 bit integer.

**Note:** Please solve it **without division** and in O(*n*).

**Follow up:**

Could you solve it with constant space complexity? (The output array **does not** count as extra space for the purpose of space complexity analysis.)

[back to top](#menu)

---
## [#240 Search a 2D Matrix II](https://leetcode.com/problems/search-a-2d-matrix-ii)
Write an efficient algorithm that searches for a `target` value in an `m x n` integer `matrix`. The `matrix` has the following properties:
  - Integers in each row are sorted in ascending from left to right.
  - Integers in each column are sorted in ascending from top to bottom.

**Example 1:**

![](https://assets.leetcode.com/uploads/2020/11/24/searchgrid2.jpg)
```
Input: matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 5
Output: true
```
**Example 2:**

![](https://assets.leetcode.com/uploads/2020/11/24/searchgrid.jpg)
```
Input: matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 20
Output: false
```
**Constraints:**
  - `m == matrix.length`
  - `n == matrix[i].length`
  - `1 <= n, m <= 300`
  - `-10^9 <= matix[i][j] <= 10^9`
  - All the integers in each row are **sorted** in ascending order.
  - All the integers in each column are **sorted** in ascending order.
  - `-10^9 <= target <= 10^9`

[back to top](#menu)

---
## [#242 Valid Anagram](https://leetcode.com/problems/valid-anagram)
Given two strings *s* and *t* , write a function to determine if *t* is an anagram of *s*.

**Example 1:**
```
Input: s = "anagram", t = "nagaram"
Output: true
```
**Example 2:**
```
Input: s = "rat", t = "car"
Output: false
```
**Note:**

You may assume the string contains only lowercase alphabets.

**Follow up:**

What if the inputs contain unicode characters? How would you adapt your solution to such case?

[back to top](#menu)

---
## [#257 Binary Tree Paths](https://leetcode.com/problems/binary-tree-paths)
Given a binary tree, return all root-to-leaf paths.

**Note:** A leaf is a node with no children.

**Example:**
```
Input:

   1
 /   \
2     3
 \
  5

Output: ["1->2->5", "1->3"]

Explanation: All root-to-leaf paths are: 1->2->5, 1->3
```
[back to top](#menu)

---
## [#258 Add Digits](https://leetcode.com/problems/add-digits)
Given a non-negative integer `num`, repeatedly add all its digits until the result has only one digit.

**Example:**
```
Input: 38
Output: 2
Explanation: The process is like: 3 + 8 = 11, 1 + 1 = 2.
             Since 2 has only one digit, return it.
```

**Follow up:**

Could you do it without any loop/recursion in O(1) runtime?

[back to top](#menu)

---
## [#263 Ugly Number](https://leetcode.com/problems/ugly-number)
Write a program to check whether a given number is an ugly number.

Ugly numbers are **positive numbers** whose prime factors only include `2, 3, 5`.

**Example 1:**
```
Input: 6
Output: true
Explanation: 6 = 2 × 3
```
**Example 2:**
```
Input: 8
Output: true
Explanation: 8 = 2 × 2 × 2
```
**Example 3:**
```
Input: 14
Output: false
Explanation: 14 is not ugly since it includes another prime factor 7.
```
**Note:**
1. `1` is typically treated as an ugly number.
2. Input is within the 32-bit signed integer range: [−2^31,  2^31 − 1].

[back to top](#menu)

---
## [#268 Missing Number](https://leetcode.com/problems/missing-number)
Given an array `nums` containing `n` distinct numbers in the range `[0, n]`, return *the only number in the range that is missing from the array*.

**Follow up:** Could you implement a solution using only `O(1)` extra space complexity and `O(n)` runtime complexity?

**Example 1:**
```
Input: nums = [3,0,1]
Output: 2
Explanation: n = 3 since there are 3 numbers, so all numbers are in the range [0,3]. 2 is the missing number in the range since it does not appear in nums.
```
**Example 2:**
```
Input: nums = [0,1]
Output: 2
Explanation: n = 2 since there are 2 numbers, so all numbers are in the range [0,2]. 2 is the missing number in the range since it does not appear in nums.
```
**Example 3:**
```
Input: nums = [9,6,4,2,3,5,7,0,1]
Output: 8
Explanation: n = 9 since there are 9 numbers, so all numbers are in the range [0,9]. 8 is the missing number in the range since it does not appear in nums.
```
**Example 4:**
```
Input: nums = [0]
Output: 1
Explanation: n = 1 since there is 1 number, so all numbers are in the range [0,1]. 1 is the missing number in the range since it does not appear in nums.
```
**Constraints:**
- `n == nums.length`
- `1 <= n <= 10^4`
- `0 <= nums[i] <= n`
- All the numbers of `nums` are **unique**.

[back to top](#menu)

---
## [#278 First Bad Version](https://leetcode.com/problems/first-bad-version)
You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.

Suppose you have n versions `[1, 2, ..., n]` and you want to find out the first bad one, which causes all the following ones to be bad.

You are given an API `bool isBadVersion(version)` which will return whether `version` is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API.

**Example:**
```
Given n = 5, and version = 4 is the first bad version.

call isBadVersion(3) -> false
call isBadVersion(5) -> true
call isBadVersion(4) -> true

Then 4 is the first bad version.
```
[back to top](#menu)

---
## [#283 Move Zeroes](https://leetcode.com/problems/move-zeroes)
Given an array `nums`, write a function to move all `0`'s to the end of it while maintaining the relative order of the non-zero elements.

**Example:**
```
Input: [0,1,0,3,12]
Output: [1,3,12,0,0]
```
**Note:**
1. You must do this **in-place** without making a copy of the array.
2. Minimize the total number of operations.

[back to top](#menu)

---
## [#290 Word Pattern](https://leetcode.com/problems/word-pattern)
Given a [pattern] and a string `str`, find if `str` follows the same pattern.

Here **follow** means a full match, such that there is a bijection between a letter in `pattern` and a **non-empty** word in `str`.

**Example 1:**
```
Input: pattern = "abba", str = "dog cat cat dog"
Output: true
```
**Example 2:**
```
Input:pattern = "abba", str = "dog cat cat fish"
Output: false
```
**Example 3:**
```
Input: pattern = "aaaa", str = "dog cat cat dog"
Output: false
```
**Example 4:**
```
Input: pattern = "abba", str = "dog dog dog dog"
Output: false
```
**Notes:**

You may assume `pattern` contains only lowercase letters, and `str` contains lowercase letters that may be separated by a single space.

[back to top](#menu)

---
## [#292 Nim Game](https://leetcode.com/problems/nim-game)
You are playing the following Nim Game with your friend: There is a heap of stones on the table, each time one of you take turns to remove 1 to 3 stones. The one who removes the last stone will be the winner. You will take the first turn to remove the stones.

Both of you are very clever and have optimal strategies for the game. Write a function to determine whether you can win the game given the number of stones in the heap.

**Example:**
```
Input: 4
Output: false
Explanation: If there are 4 stones in the heap, then you will never win the game;
             No matter 1, 2, or 3 stones you remove, the last stone will always be
             removed by your friend.
```

[back to top](#menu)

---
## [#295 Find Median from Data Stream](https://leetcode.com/problems/find-median-from-data-stream)
The **median** is the middle value in an ordered integer list. If the size of the list is even, there is no middle value and the median is the mean of the two middle values.
  - For example, for `arr = [2,3,4]`, the median is `3`.
  - For example, for `arr = [2,3]`, the median is `(2 + 3) / 2 = 2.5`.
Implement the MedianFinder class:

  - `MedianFinder()` initializes the `MedianFinder` object.
  - `void addNum(int num)` adds the integer `num` from the data stream to the data structure.
  - `double findMedian()` returns the median of all elements so far. Answers within `10^-5` of the actual answer will be accepted.

**Example 1:**
```
Input
["MedianFinder", "addNum", "addNum", "findMedian", "addNum", "findMedian"]
[[], [1], [2], [], [3], []]
Output
[null, null, null, 1.5, null, 2.0]

Explanation
MedianFinder medianFinder = new MedianFinder();
medianFinder.addNum(1);    // arr = [1]
medianFinder.addNum(2);    // arr = [1, 2]
medianFinder.findMedian(); // return 1.5 (i.e., (1 + 2) / 2)
medianFinder.addNum(3);    // arr[1, 2, 3]
medianFinder.findMedian(); // return 2.0
```
**Constraints:**
  - `-10^5 <= num <= 10^5`
  - There will be at least one element in the data structure before calling `findMedian`.
  - At most `5 * 10^4` calls will be made to `addNum` and `findMedian`.

**Follow up:**
  - If all integer numbers from the stream are in the range `[0, 100]`, how would you optimize your solution?
  - If `99%` of all integer numbers from the stream are in the range `[0, 100]`, how would you optimize your solution?

[back to top](#menu)

---
## [#300 Longest Increasing Subsequence](https://leetcode.com/problems/longest-increasing-subsequence)
Given an unsorted array of integers, find the length of longest increasing subsequence.

**Example:**
```
Input: [10,9,2,5,3,7,101,18]
Output: 4
Explanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4.
```
**Note:**
- There may be more than one LIS combination, it is only necessary for you to return the length.
- Your algorithm should run in O(n2) complexity.

**Follow up**: Could you improve it to O(n log n) time complexity?

[back to top](#menu)

---
## [#322 Coin Change](https://leetcode.com/problems/coin-change)
You are given coins of different denominations and a total amount of money *amount*. Write a function to compute the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return `-1`.

You may assume that you have an infinite number of each kind of coin.

**Example 1:**
```
Input: coins = [1,2,5], amount = 11
Output: 3
Explanation: 11 = 5 + 5 + 1
```
**Example 2:**
```
Input: coins = [2], amount = 3
Output: -1
```
**Example 3:**
```
Input: coins = [1], amount = 0
Output: 0
```
**Example 4:**
```
Input: coins = [1], amount = 1
Output: 1
```
**Example 5:**
```
Input: coins = [1], amount = 2
Output: 2
```
**Constraints:**
- `1 <= coins.length <= 12`
- `1 <= coins[i] <= 2^31 - 1`
- `0 <= amount <= 10^4`

[back to top](#menu)

---
## [#328 Odd Even Linked List](https://leetcode.com/problems/odd-even-linked-list)
Given a singly linked list, group all odd nodes together followed by the even nodes. Please note here we are talking about the node number and not the value in the nodes.

You should try to do it in place. The program should run in O(1) space complexity and O(nodes) time complexity.

**Example 1:**
```
Input: 1->2->3->4->5->NULL
Output: 1->3->5->2->4->NULL
```
**Example 2:**
```
Input: 2->1->3->5->6->4->7->NULL
Output: 2->3->6->7->1->5->4->NULL
```
**Note:**
- The relative order inside both the even and odd groups should remain as it was in the input.
- The first node is considered odd, the second node even and so on ...

[back to top](#menu)

---
## [#344 Reverse String](https://leetcode.com/problems/reverse-string)
Write a function that reverses a string. The input string is given as an array of characters `s`.

**Example 1:**
```
Input: s = ["h","e","l","l","o"]
Output: ["o","l","l","e","h"]
```
**Example 2:**
```
Input: s = ["H","a","n","n","a","h"]
Output: ["h","a","n","n","a","H"]
```
**Constraints:**
  - `1 <= s.length <= 10^5`
  - `s[i]` is a [printable ascii character](https://en.wikipedia.org/wiki/ASCII#Printable_characters).

**Follow up:** Do not allocate extra space for another array. You must do this by modifying the input array [in-place](https://en.wikipedia.org/wiki/In-place_algorithm) with `O(1)` extra memory.

[back to top](#menu)

---
## [#354 Russian Doll Envelopes](https://leetcode.com/problems/russian-doll-envelopes)
You are given a 2D array of integers `envelopes` where `envelopes[i] = [wi, hi]` represents the width and the height of an envelope.

One envelope can fit into another if and only if both the width and height of one envelope is greater than the width and height of the other envelope.

Return *the maximum number of envelopes can you Russian doll (i.e., put one inside the other)*.

**Note:** You cannot rotate an envelope.

**Example 1:**
```
Input: envelopes = [[5,4],[6,4],[6,7],[2,3]]
Output: 3
Explanation: The maximum number of envelopes you can Russian doll is 3 ([2,3] => [5,4] => [6,7]).
```
**Example 2:**
```
Input: envelopes = [[1,1],[1,1],[1,1]]
Output: 1
```
**Constraints:**
  - `1 <= envelopes.length <= 5000`
  - `envelopes[i].length == 2`
  - `1 <= wi, hi <= 10^4`

[back to top](#menu)

---
## [#369 Valid Perfect Square](https://leetcode.com/problems/valid-perfect-square)
Given a positive integer *num*, write a function which returns True if *num* is a perfect square else False.

**Note:** **Do not** use any built-in library function such as `sqrt`.

**Example 1:**
```
Input: 16
Output: true
```
**Example 2:**
```
Input: 14
Output: false
```

[back to top](#menu)

---
## [#376 Wiggle Subsequence](https://leetcode.com/problems/wiggle-subsequence/solution)
Given an integer array `nums`, return *the length of the longest **wiggle sequence***.

A **wiggle sequence** is a sequence where the differences between successive numbers strictly alternate between positive and negative. The first difference (if one exists) may be either positive or negative. A sequence with fewer than two elements is trivially a wiggle sequence.

  - For example, `[1, 7, 4, 9, 2, 5]` is a **wiggle sequence** because the differences `(6, -3, 5, -7, 3)` are alternately positive and negative.
  - In contrast, `[1, 4, 7, 2, 5]` and `[1, 7, 4, 5, 5]` are not wiggle sequences, the first because its first two differences are positive and the second because its last difference is zero.

A **subsequence** is obtained by deleting some elements (eventually, also zero) from the original sequence, leaving the remaining elements in their original order.

**Example 1:**
```
Input: nums = [1,7,4,9,2,5]
Output: 6
Explanation: The entire sequence is a wiggle sequence.
```
**Example 2:**
```
Input: nums = [1,17,5,10,13,15,10,5,16,8]
Output: 7
Explanation: There are several subsequences that achieve this length. One is [1,17,10,13,10,16,8].
```
**Example 3:**
```
Input: nums = [1,2,3,4,5,6,7,8,9]
Output: 2
```
**Constraints:**
- `1 <= nums.length <= 1000`
- `0 <= nums[i] <= 1000`

[back to top](#menu)

---
## [#378 Kth Smallest Element in a Sorted Matrix](https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix)
Given an `n x n` `matrix` where each of the rows and columns are sorted in ascending order, return the `k^th` smallest element in the matrix.

Note that it is the `k^th` smallest element **in the sorted order**, not the `k^th` **distinct** element.

**Example 1:**
```
Input: matrix = [[1,5,9],[10,11,13],[12,13,15]], k = 8
Output: 13
Explanation: The elements in the matrix are [1,5,9,10,11,12,13,13,15], and the 8th smallest number is 13
```
**Example 2:**
```
Input: matrix = [[-5]], k = 1
Output: -5
```
**Constraints:**
- `n == matrix.length`
- `n == matrix[i].length`
- `1 <= n <= 300`
- `-10^9 <= matrix[i][j] <= 10^9`
- All the rows and columns of `matrix` are **guaranteed** to be sorted in **non-decreasing order**.
- `1 <= k <= n^2`

[back to top](#menu)

---
## [#383 Ransom Note](https://leetcode.com/problems/ransom-note)
Given an arbitrary ransom note string and another string containing letters from all the magazines, write a function that will return true if the ransom note can be constructed from the magazines ; otherwise, it will return false.

Each letter in the magazine string can only be used once in your ransom note.

**Example 1:**
```
Input: ransomNote = "a", magazine = "b"
Output: false
```
**Example 2:**
```
Input: ransomNote = "aa", magazine = "ab"
Output: false
```
**Example 3:**
```
Input: ransomNote = "aa", magazine = "aab"
Output: true
```
**Constraints:**
- You may assume that both strings contain only lowercase letters.

[back to top](#menu)

---
## [#387 First Unique Character in a String](https://leetcode.com/problems/first-unique-character-in-a-string)
Given a string, find the first non-repeating character in it and return it's index. If it doesn't exist, return -1.

**Examples:**
```
s = "leetcode"
return 0.

s = "loveleetcode",
return 2.
```
**Note:** You may assume the string contain only lowercase letters.

[back to top](#menu)

---
## [#402 Remove K Digits](https://leetcode.com/problems/remove-k-digits)
Given a non-negative integer *num* represented as a string, remove *k* digits from the number so that the new number is the smallest possible.

**Note:**
- The length of *num* is less than 10002 and will be ≥ *k*.
- The given *num* does not contain any leading zero.

**Example 1:**
```
Input: num = "1432219", k = 3
Output: "1219"
Explanation: Remove the three digits 4, 3, and 2 to form the new number 1219 which is the smallest.
```
**Example 2:**
```
Input: num = "10200", k = 1
Output: "200"
Explanation: Remove the leading 1 and the number is 200. Note that the output must not contain leading zeroes.
```
**Example 3:**
```
Input: num = "10", k = 2
Output: "0"
Explanation: Remove all the digits from the number and it is left with nothing which is 0.
```

[back to top](#menu)

---
## [#417 Pacific Atlantic Water Flow](https://leetcode.com/problems/pacific-atlantic-water-flow)
Given an `m x n` matrix of non-negative integers representing the height of each unit cell in a continent, the "Pacific ocean" touches the left and top edges of the matrix and the "Atlantic ocean" touches the right and bottom edges.

Water can only flow in four directions (up, down, left, or right) from a cell to another one with height equal or lower.

Find the list of grid coordinates where water can flow to both the Pacific and Atlantic ocean.

**Note:**
  1. The order of returned grid coordinates does not matter.
  2. Both *m* and *n* are less than 150.

**Example:**
```
Given the following 5x5 matrix:

  Pacific ~   ~   ~   ~   ~
       ~  1   2   2   3  (5) *
       ~  3   2   3  (4) (4) *
       ~  2   4  (5)  3   1  *
       ~ (6) (7)  1   4   5  *
       ~ (5)  1   1   2   4  *
          *   *   *   *   * Atlantic

Return:

[[0, 4], [1, 3], [1, 4], [2, 2], [3, 0], [3, 1], [4, 0]] (positions with parentheses in above matrix).
```

[back to top](#menu)

---
## [#423 Reconstruct Original Digits from English](https://leetcode.com/problems/reconstruct-original-digits-from-english)
Given a **non-empty** string containing an out-of-order English representation of digits `0-9`, output the digits in ascending order.

**Note:**
  1. Input contains only lowercase English letters.
  2. Input is guaranteed to be valid and can be transformed to its original digits. That means invalid inputs such as "abc" or "zerone" are not permitted.
  3. Input length is less than 50,000.

**Example 1:**
```
Input: "owoztneoer"

Output: "012"
```
**Example 2:**
```
Input: "fviefuro"

Output: "45"
```
[back to top](#menu)

---
## [#434 Number of Segments in a String](https://leetcode.com/problems/number-of-segments-in-a-string)
Count the number of segments in a string, where a segment is defined to be a contiguous sequence of **non-space** characters.

Please note that the string does not contain any non-printable characters.

**Example:**
```
Input: "Hello, my name is John"
Output: 5
```
[back to top](#menu)

---
## [#438 Find All Anagrams in a String](https://leetcode.com/problems/find-all-anagrams-in-a-string)
Given a string **s** and a **non-empty** string **p**, find all the start indices of **p**'s anagrams in **s**.

Strings consists of lowercase English letters only and the length of both strings **s** and **p** will not be larger than 20,100.

The order of output does not matter.

**Example 1:**
```
Input:
s: "cbaebabacd" p: "abc"

Output:
[0, 6]

Explanation:
The substring with start index = 0 is "cba", which is an anagram of "abc".
The substring with start index = 6 is "bac", which is an anagram of "abc".
```
**Example 2:**
```
Input:
s: "abab" p: "ab"

Output:
[0, 1, 2]

Explanation:
The substring with start index = 0 is "ab", which is an anagram of "ab".
The substring with start index = 1 is "ba", which is an anagram of "ab".
The substring with start index = 2 is "ab", which is an anagram of "ab".
```
[back to top](#menu)

---
## [#451 Sort Characters By Frequency](https://leetcode.com/problems/sort-characters-by-frequency)
Given a string, sort it in decreasing order based on the frequency of characters.

**Example 1:**
```
Input:
"tree"

Output:
"eert"

Explanation:
'e' appears twice while 'r' and 't' both appear once.
So 'e' must appear before both 'r' and 't'. Therefore "eetr" is also a valid answer.
```
**Example 2:**
```
Input:
"cccaaa"

Output:
"cccaaa"

Explanation:
Both 'c' and 'a' appear three times, so "aaaccc" is also a valid answer.
Note that "cacaca" is incorrect, as the same characters must be together.
```
**Example 3:**
```
Input:
"Aabb"

Output:
"bbAa"

Explanation:
"bbaA" is also a valid answer, but "Aabb" is incorrect.
Note that 'A' and 'a' are treated as two different characters.
```
[back to top](#menu)

---
## [#467 Unique Substrings in Wraparound String](https://leetcode.com/problems/unique-substrings-in-wraparound-string)
Consider the string `s` to be the infinite wraparound string of "abcdefghijklmnopqrstuvwxyz", so `s` will look like this: "...zabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcd....".

Now we have another string `p`. Your job is to find out how many unique non-empty substrings of `p` are present in `s`. In particular, your input is the string `p` and you need to output the number of different non-empty substrings of `p` in the string `s`.

Note: `p` consists of only lowercase English letters and the size of p might be over 10000.

**Example 1:**
```
Input: "a"
Output: 1
Explanation: Only the substring "a" of string "a" is in the string s.
```
**Example 2:**
```
Input: "cac"
Output: 2
Explanation: There are two substrings "a", "c" of string "cac" in the string s.
```
**Example 3:**
```
Input: "zab"
Output: 6
Explanation: There are six substrings "z", "a", "b", "za", "ab", "zab" of string "zab" in the string s.
```

[back to top](#menu)

---
## [#474 Ones and Zeroes](https://leetcode.com/problems/ones-and-zeroes)
You are given an array of binary strings `strs` and two integers `m` and `n`.

Return *the size of the largest subset of `strs` such that there are **at most** `m` `0`'s and `n` `1`'s in the subset*.

A set `x` is a **subset** of a set `y` if all elements of `x` are also elements of `y`.

**Example 1:**
```
Input: strs = ["10","0001","111001","1","0"], m = 5, n = 3
Output: 4
Explanation: The largest subset with at most 5 0's and 3 1's is {"10", "0001", "1", "0"}, so the answer is 4.
Other valid but smaller subsets include {"0001", "1"} and {"10", "1", "0"}.
{"111001"} is an invalid subset because it contains 4 1's, greater than the maximum of 3.
```
**Example 2:**
```
Input: strs = ["10","0","1"], m = 1, n = 1
Output: 2
Explanation: The largest subset is {"0", "1"}, so the answer is 2.
```
**Constraints:**
  - `1 <= strs.length <= 600`
  - `1 <= strs[i].length <= 100`
  - `strs[i]` consists only of digits `'0'` and `'1'`.
  - `1 <= m, n <= 100`

[back to top](#menu)

---
## [#476 Number Complement](https://leetcode.com/problems/number-complement)
Given a **positive** integer `num`, output its complement number. The complement strategy is to flip the bits of its binary representation.

**Example 1:**
```
Input: num = 5
Output: 2
Explanation: The binary representation of 5 is 101 (no leading zero bits), and its complement is 010. So you need to output 2.
```
**Example 2:**
```
Input: num = 1
Output: 0
Explanation: The binary representation of 1 is 1 (no leading zero bits), and its complement is 0. So you need to output 0.
```
**Constraints:**
- The given integer `num` is guaranteed to fit within the range of a 32-bit signed integer.
- `num >= 1`
- You could assume no leading zero bit in the integer’s binary representation.
- This question is the same as 1009: <https://leetcode.com/problems/complement-of-base-10-integer/>

[back to top](#menu)

---
## [#478 Generate Random Point in a Circle](https://leetcode.com/problems/generate-random-point-in-a-circle)
Given the radius and x-y positions of the center of a circle, write a function `randPoint` which generates a uniform random point in the circle.

Note:

  1. input and output values are in [floating-point](https://www.webopedia.com/TERM/F/floating_point_number.html).
  2. radius and x-y position of the center of the circle is passed into the class constructor.
  3. a point on the circumference of the circle is considered to be in the circle.
  4. `randPoint` returns a size 2 array containing x-position and y-position of the random point, in that order.

**Example 1:**
```
Input:
["Solution","randPoint","randPoint","randPoint"]
[[1,0,0],[],[],[]]
Output: [null,[-0.72939,-0.65505],[-0.78502,-0.28626],[-0.83119,-0.19803]]
```
**Example 2:**
```
Input:
["Solution","randPoint","randPoint","randPoint"]
[[10,5,-7.5],[],[],[]]
Output: [null,[11.52438,-8.33273],[2.46992,-16.21705],[11.13430,-12.42337]]
```
**Explanation of Input Syntax:**
The input is two lists: the subroutines called and their arguments. `Solution`'s constructor has three arguments, the radius, x-position of the center, and y-position of the center of the circle. `randPoint` has no arguments. Arguments are always wrapped with a list, even if there aren't any.

[back to top](#menu)

---
## [#506 Relative Ranks](https://leetcode.com/problems/relative-ranks)
You are given an integer array `score` of size `n`, where `score[i]` is the score of the `i^th` athlete in a competition. All the scores are guaranteed to be **unique**.

The athletes are **placed** based on their scores, where the `1st` place athlete has the highest score, the `2nd` place athlete has the `2nd` highest score, and so on. The placement of each athlete determines their rank:

- The `1st` place athlete's rank is `"Gold Medal"`.
- The `2nd` place athlete's rank is `"Silver Medal"`.
- The `3rd` place athlete's rank is `"Bronze Medal"`.
- For the `4th` place to the `nth` place athlete, their rank is their placement number (i.e., the `xth` place athlete's rank is `"x"`).

Return an array `answer` of size `n` where `answer[i]` is the **rank** of the `ith` athlete.

**Example 1:**
```
Input: score = [5,4,3,2,1]
Output: ["Gold Medal","Silver Medal","Bronze Medal","4","5"]
Explanation: The placements are [1st, 2nd, 3rd, 4th, 5th].
```
**Example 2:**
```
Input: score = [10,3,8,9,4]
Output: ["Gold Medal","5","Bronze Medal","Silver Medal","4"]
Explanation: The placements are [1st, 5th, 3rd, 2nd, 4th].
```
**Constraints:**
- `n == score.length`
- `1 <= n <= 10^4`
- `0 <= score[i] <= 10^6`
- All the values in `score` are **unique**.

[back to top](#menu)
## [#525 Contiguous Array](https://leetcode.com/problems/contiguous-array)
Given a binary array, find the maximum length of a contiguous subarray with equal number of 0 and 1.

**Example 1:**
```
Input: [0,1]
Output: 2
Explanation: [0, 1] is the longest contiguous subarray with equal number of 0 and 1.
```
**Example 2:**
```
Input: [0,1,0]
Output: 2
Explanation: [0, 1] (or [1, 0]) is a longest contiguous subarray with equal number of 0 and 1.
```
**Note:** The length of the given binary array will not exceed 50,000.

[back to top](#menu)

---
## [#535 Encode and Decode TinyURL](https://leetcode.com/problems/encode-and-decode-tinyurl)
> Note: This is a companion problem to the [System Design](https://leetcode.com/discuss/interview-question/system-design/) problem: [Design TinyURL](https://leetcode.com/discuss/interview-question/124658/Design-a-URL-Shortener-(-TinyURL-)-System/).

TinyURL is a URL shortening service where you enter a URL such as `https://leetcode.com/problems/design-tinyurl` and it returns a short URL such as `http://tinyurl.com/4e9iAk`.

Design the `encode` and `decode` methods for the TinyURL service. There is no restriction on how your encode/decode algorithm should work. You just need to ensure that a URL can be encoded to a tiny URL and the tiny URL can be decoded to the original URL.

[back to top](#menu)

---
## [#540 Single Element in a Sorted Array](https://leetcode.com/problems/single-element-in-a-sorted-array)
You are given a sorted array consisting of only integers where every element appears exactly twice, except for one element which appears exactly once. Find this single element that appears only once.

**Example 1:**
```
Input: [1,1,2,3,3,4,4,8,8]
Output: 2
```
**Example 2:**
```
Input: [3,3,7,7,10,11,11]
Output: 10
```
**Note:** Your solution should run in O(log n) time and O(1) space.

[back to top](#menu)

---
## [#542 01 Matrix](https://leetcode.com/problems/01-matrix)
Given an `m x n` binary matrix `mat`, return *the distance of the nearest `0` for each cell*.

The distance between two adjacent cells is `1`.

**Example 1:**

![](https://assets.leetcode.com/uploads/2021/04/24/01-1-grid.jpg)
```
Input: mat = [[0,0,0],[0,1,0],[0,0,0]]
Output: [[0,0,0],[0,1,0],[0,0,0]]
```
**Example 2:**

![](https://assets.leetcode.com/uploads/2021/04/24/01-2-grid.jpg)
```
Input: mat = [[0,0,0],[0,1,0],[1,1,1]]
Output: [[0,0,0],[0,1,0],[1,2,1]]
```
**Constraints:**
  - `m == mat.length`
  - `n == mat[i].length`
  - `1 <= m, n <= 10^4`
  - `1 <= m * n <= 10^4`
  - `mat[i][j]` is either `0` or `1`.
  - There is at least one `0` in `mat`.

[back to top](#menu)

---
## [#547 Number of Provinces](https://leetcode.com/problems/number-of-provinces)
There are `n` cities. Some of them are connected, while some are not. If city `a` is connected directly with city `b`, and city `b` is connected directly with city `c`, then city `a` is connected indirectly with city `c`.

A **province** is a group of directly or indirectly connected cities and no other cities outside of the group.

You are given an `n x n` matrix `isConnected` where `isConnected[i][j] = 1` if the `ith` city and the `jth` city are directly connected, and `isConnected[i][j] = 0` otherwise.

Return *the total number of **provinces***.

**Example 1:**

![](https://assets.leetcode.com/uploads/2020/12/24/graph1.jpg)
```
Input: isConnected = [[1,1,0],[1,1,0],[0,0,1]]
Output: 2
```
**Example 2:**

![](https://assets.leetcode.com/uploads/2020/12/24/graph2.jpg)
```
Input: isConnected = [[1,0,0],[0,1,0],[0,0,1]]
Output: 3
```
**Constraints:**
- `1 <= n <= 200`
- `n == isConnected.length`
- `n == isConnected[i].length`
- `isConnected[i][j]` is `1` or `0`.
- `isConnected[i][i] == 1`
- `isConnected[i][j] == isConnected[j][i]`

[back to top](#menu)

---
## [#557 Reverse Words in a String III](https://leetcode.com/problems/reverse-words-in-a-string-iii)
Given a string `s`, reverse the order of characters in each word within a sentence while still preserving whitespace and initial word order.

**Example 1:**
```
Input: s = "Let's take LeetCode contest"
Output: "s'teL ekat edoCteeL tsetnoc"
```
**Example 2:**
```
Input: s = "God Ding"
Output: "doG gniD"
```
**Constraints:**
  - `1 <= s.length <= 5 * 10^4`
  - `s` contains printable **ASCII** characters.
  - `s` does not contain any leading or trailing spaces.
  - There is **at least one** word in `s`.
  - All the words in `s` are separated by a single space.

[back to top](#menu)

---
## [#560 Subarray Sum Equals K](https://leetcode.com/problems/subarray-sum-equals-k)
Given an array of integers and an integer **k**, you need to find the total number of continuous subarrays whose sum equals to **k**.

**Example 1:**
```
Input:nums = [1,1,1], k = 2
Output: 2
```
**Note:**
1. The length of the array is in range [1, 20,000].
2. The range of numbers in the array is [-1000, 1000] and the range of the integer **k** is [-1e7, 1e7].

[back to top](#menu)

---
## [#567 Permutation in String](https://leetcode.com/problems/permutation-in-string)
Given two strings **s1** and **s2**, write a function to return true if **s2** contains the permutation of **s1**. In other words, one of the first string's permutations is the **substring** of the second string.

**Example 1:**
```
Input: s1 = "ab" s2 = "eidbaooo"
Output: True
Explanation: s2 contains one permutation of s1 ("ba").
```
**Example 2:**
```
Input:s1= "ab" s2 = "eidboaoo"
Output: False
```
**Note:**
1. The input strings only contain lower case letters.
2. The length of both given strings is in range [1, 10,000].

[back to top](#menu)

---
## [#575 Distribute Candies](https://leetcode.com/problems/distribute-candies)
Alice has `n` candies, where the `i^th` candy is of type `candyType[i]`. Alice noticed that she started to gain weight, so she visited a doctor.

The doctor advised Alice to only eat `n / 2` of the candies she has (`n` is always even). Alice likes her candies very much, and she wants to eat the maximum number of different types of candies while still following the doctor's advice.

Given the integer array `candyType` of length `n`, return *the **maximum** number of different types of candies she can eat if she only eats `n / 2` of them*.

**Example 1:**
```
Input: candyType = [1,1,2,2,3,3]
Output: 3
Explanation: Alice can only eat 6 / 2 = 3 candies. Since there are only 3 types, she can eat one of each type.
```
**Example 2:**
```
Input: candyType = [1,1,2,3]
Output: 2
Explanation: Alice can only eat 4 / 2 = 2 candies. Whether she eats types [1,2], [1,3], or [2,3], she still can only eat 2 different types.
```
**Example 3:**
```
Input: candyType = [6,6,6,6]
Output: 1
Explanation: Alice can only eat 4 / 2 = 2 candies. Even though she can eat 2 candies, she only has 1 type.
```
**Constraints:**
- `n == candyType.length`
- `2 <= n <= 10^4`
- `n` is even.
- `-10^5 <= candyType[i] <= 10^5`

[back to top](#menu)

---
## [#611 Valid Triangle Number](https://leetcode.com/problems/valid-triangle-number)
Given an integer array `nums`, return *the number of triplets chosen from the array that can make triangles if we take them as side lengths of a triangle*.

**Example 1:**
```
Input: nums = [2,2,3,4]
Output: 3
Explanation: Valid combinations are:
2,3,4 (using the first 2)
2,3,4 (using the second 2)
2,2,3
```
**Example 2:**
```
Input: nums = [4,2,3,4]
Output: 4
```
**Constraints:**
  - `1 <= nums.length <= 1000`
  - `0 <= nums[i] <= 1000`

[back to top](#menu)

---
## [#617 Merge Two Binary Trees](https://leetcode.com/problems/merge-two-binary-trees)
You are given two binary trees `root1` and `root2`.

Imagine that when you put one of them to cover the other, some nodes of the two trees are overlapped while the others are not. You need to merge the two trees into a new binary tree. The merge rule is that if two nodes overlap, then sum node values up as the new value of the merged node. Otherwise, the NOT null node will be used as the node of the new tree.

Return *the merged tree*.

**Note:** The merging process must start from the root nodes of both trees.

**Example 1:**

![](https://assets.leetcode.com/uploads/2021/02/05/merge.jpg)
```
Input: root1 = [1,3,2,5], root2 = [2,1,3,null,4,null,7]
Output: [3,4,5,5,4,null,7]
```
**Example 2:**
```
Input: root1 = [1], root2 = [1,2]
Output: [2,2]
```
**Constraints:**
  - The number of nodes in both trees is in the range `[0, 2000]`.
  - `-10^4 <= Node.val <= 10^4`

[back to top](#menu)

---
## [#645 Set Mismatch](https://leetcode.com/problems/set-mismatch)
You have a set of integers `s`, which originally contains all the numbers from `1` to `n`. Unfortunately, due to some error, one of the numbers in `s` got duplicated to another number in the set, which results in **repetition of one** number and **loss of another** number.

You are given an integer array `nums` representing the data status of this set after the error.

Find the number that occurs twice and the number that is missing and return *them in the form of an array*.

**Example 1:**
```
Input: nums = [1,2,2,4]
Output: [2,3]
```
**Example 2:**
```
Input: nums = [1,1]
Output: [1,2]
```
**Constraints:**
- `2 <= nums.length <= 10^4`
- `1 <= nums[i] <= 10^4`

[back to top](#menu)

---
## [#667 Beautiful Arrangement II](https://leetcode.com/problems/beautiful-arrangement-ii)
Given two integers `n` and `k`, you need to construct a list which contains `n` different positive integers ranging from `1` to `n` and obeys the following requirement:
Suppose this list is [a1, a2, a3, ... , an], then the list [|a1 - a2|, |a2 - a3|, |a3 - a4|, ... , |an-1 - an|] has exactly `k` distinct integers.

If there are multiple answers, print any of them.

**Example 1:**
```
Input: n = 3, k = 1
Output: [1, 2, 3]
Explanation: The [1, 2, 3] has three different positive integers ranging from 1 to 3, and the [1, 1] has exactly 1 distinct integer: 1.
```
**Example 2:**
```
Input: n = 3, k = 2
Output: [1, 3, 2]
Explanation: The [1, 3, 2] has three different positive integers ranging from 1 to 3, and the [2, 1] has exactly 2 distinct integers: 1 and 2.
```
**Note:**
  1. The `n` and `k` are in the range 1 <= k < n <= 10^4.

[back to top](#menu)

---
## [#678 Valid Parenthesis String](https://leetcode.com/problems/valid-parenthesis-string)
Given a string containing only three types of characters: '(', ')' and '*', write a function to check whether this string is valid. We define the validity of a string by these rules:
1. Any left parenthesis `'('` must have a corresponding right parenthesis `')'`.
2. Any right parenthesis `')'` must have a corresponding left parenthesis `'('`.
3. Left parenthesis `'('` must go before the corresponding right parenthesis `')'`.
4. `'*'` could be treated as a single right parenthesis `')'` or a single left parenthesis `'('` or an empty string.
5. An empty string is also valid.

**Example 1:**
```
Input: "()"
Output: True
```
**Example 2:**
```
Input: "(*)"
Output: True
```
**Example 3:**
```
Input: "(*))"
Output: True
```
**Note:**
1. The string size will be in the range [1, 100].

[back to top](#menu)

---
## [#695 Max Area of Island](https://leetcode.com/problems/max-area-of-island)
You are given an `m x n` binary matrix `grid`. An island is a group of `1`'s (representing land) connected **4-directionally** (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water.

The **area** of an island is the number of cells with a value `1` in the island.

Return *the maximum **area** of an island in `grid`*. If there is no island, return `0`.

**Example 1:**

![](https://assets.leetcode.com/uploads/2021/05/01/maxarea1-grid.jpg)
```
Input: grid = [[0,0,1,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,1,1,0,1,0,0,0,0,0,0,0,0],[0,1,0,0,1,1,0,0,1,0,1,0,0],[0,1,0,0,1,1,0,0,1,1,1,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,0,0,0,0,0,0,1,1,0,0,0,0]]
Output: 6
Explanation: The answer is not 11, because the island must be connected 4-directionally.
```
**Example 2:**
```
Input: grid = [[0,0,0,0,0,0,0,0]]
Output: 0
```
**Constraints:**
  - `m == grid.length`
  - `n == grid[i].length`
  - `1 <= m, n <= 50`
  - `grid[i][j]` is either `0` or `1`.

[back to top](#menu)

---
## [#704 Binary Search](https://leetcode.com/problems/binary-search)
Given an array of integers `nums` which is sorted in ascending order, and an integer `target`, write a function to search `target` in `nums`. If `target` exists, then return its index. Otherwise, return `-1`.

You must write an algorithm with `O(log n)` runtime complexity.

**Example 1:**
```
Input: nums = [-1,0,3,5,9,12], target = 9
Output: 4
Explanation: 9 exists in nums and its index is 4
```
**Example 2:**
```
Input: nums = [-1,0,3,5,9,12], target = 2
Output: -1
Explanation: 2 does not exist in nums so return -1
```
**Constraints:**
- `1 <= nums.length <= 10^4`
- `-10^4 < nums[i], target < 10^4`
- All the integers in `nums` are **unique**.
- `nums` is sorted in ascending order.

[back to top](#menu)

---
## [#714 Best Time to Buy and Sell Stock with Transaction Fee](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee)
You are given an array `prices` where `prices[i]` is the price of a given stock on the `ith` day, and an integer `fee` representing a transaction fee.

Find the maximum profit you can achieve. You may complete as many transactions as you like, but you need to pay the transaction fee for each transaction.

**Note:** You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).

**Example 1:**
```
Input: prices = [1,3,2,8,4,9], fee = 2
Output: 8
Explanation: The maximum profit can be achieved by:
- Buying at prices[0] = 1
- Selling at prices[3] = 8
- Buying at prices[4] = 4
- Selling at prices[5] = 9
The total profit is ((8 - 1) - 2) + ((9 - 4) - 2) = 8.
```
**Example 2:**
```
Input: prices = [1,3,7,5,10,3], fee = 3
Output: 6
```
**Constraints:**
- `1 < prices.length <= 5 * 10^4`
- `0 < prices[i], fee < 5 * 10^4`

[back to top](#menu)

---
## [#720 Longest Word in Dictionary](https://leetcode.com/problems/longest-word-in-dictionary)
Given a list of strings `words` representing an English Dictionary, find the longest word in `words` that can be built one character at a time by other words in `words`. If there is more than one possible answer, return the longest word with the smallest lexicographical order.

If there is no answer, return the empty string.

**Example 1:**
```
Input: words = ["w","wo","wor","worl", "world"]
Output: "world"
Explanation: The word "world" can be built one character at a time by "w", "wo", "wor", and "worl".
```
**Example 2:**
```
Input: words = ["a", "banana", "app", "appl", "ap", "apply", "apple"]
Output: "apple"
Explanation: Both "apply" and "apple" can be built from other words in the dictionary. However, "apple" is lexicographically smaller than "apply".
```
**Note:**
- All the strings in the input will only contain lowercase letters.
- The length of `words` will be in the range `[1, 1000]`.
- The length of `words[i]` will be in the range `[1, 30]`.

[back to top](#menu)

---
## [#733 Flood Fill](https://leetcode.com/problems/flood-fill)
An `image` is represented by a 2-D array of integers, each integer representing the pixel value of the image (from 0 to 65535).

Given a coordinate `(sr, sc)` representing the starting pixel (row and column) of the flood fill, and a pixel value `newColor`, "flood fill" the image.

To perform a "flood fill", consider the starting pixel, plus any pixels connected 4-directionally to the starting pixel of the same color as the starting pixel, plus any pixels connected 4-directionally to those pixels (also with the same color as the starting pixel), and so on. Replace the color of all of the aforementioned pixels with the newColor.

At the end, return the modified image.

**Example 1:**
```
Input:
image = [[1,1,1],[1,1,0],[1,0,1]]
sr = 1, sc = 1, newColor = 2
Output: [[2,2,2],[2,2,0],[2,0,1]]
Explanation:
From the center of the image (with position (sr, sc) = (1, 1)), all pixels connected
by a path of the same color as the starting pixel are colored with the new color.
Note the bottom corner is not colored 2, because it is not 4-directionally connected
to the starting pixel.
```
**Note:**
- The length of `image` and `image[0]` will be in the range `[1, 50]`.
- The given starting pixel will satisfy `0 <= sr < image.length` and `0 <= sc < image[0].length`.
- The value of each color in `image[i][j]` and `newColor` will be an integer in `[0, 65535]`.

[back to top](#menu)

---
## [#747 Largest Number At Least Twice of Others](https://leetcode.com/problems/largest-number-at-least-twice-of-others)
In a given integer array `nums`, there is always exactly one largest element.

Find whether the largest element in the array is at least twice as much as every other number in the array.

If it is, return the **index** of the largest element, otherwise return -1.

**Example 1:**
```
Input: nums = [3, 6, 1, 0]
Output: 1
Explanation: 6 is the largest integer, and for every other number in the array x,
6 is more than twice as big as x.  The index of value 6 is 1, so we return 1.
```
**Example 2:**
```
Input: nums = [1, 2, 3, 4]
Output: -1
Explanation: 4 isn't at least as big as twice the value of 3, so we return -1.
```
**Note:**
1. `nums` will have a length in the range `[1, 50]`.
2. Every `nums[i]` will be an integer in the range `[0, 99]`.

[back to top](#menu)

---
## [#781 Rabbits in Forest](https://leetcode.com/problems/rabbits-in-forest)
In a forest, each rabbit has some color. Some subset of rabbits (possibly all of them) tell you how many other rabbits have the same color as them. Those `answers` are placed in an array.

Return the minimum number of rabbits that could be in the forest.

**Example 1:**
```
Input: answers = [1, 1, 2]
Output: 5
Explanation:
The two rabbits that answered "1" could both be the same color, say red.
The rabbit than answered "2" can't be red or the answers would be inconsistent.
Say the rabbit that answered "2" was blue.
Then there should be 2 other blue rabbits in the forest that didn't answer into the array.
The smallest possible number of rabbits in the forest is therefore 5: 3 that answered plus 2 that didn't.
```
**Example 2:**
```
Input: answers = [10, 10, 10]
Output: 11
```
**Example 3:**
```
Input: answers = []
Output: 0
```
**Note:**
1. `answers` will have length at most `1000`.
2. Each `answers[i]` will be an integer in the range `[0, 999]`.

[back to top](#menu)

---
## [#771 Jewels and Stones](https://leetcode.com/problems/jewels-and-stones)
You're given strings `J` representing the types of stones that are jewels, and `S` representing the stones you have.  Each character in `S` is a type of stone you have.  You want to know how many of the stones you have are also jewels.

The letters in `J` are guaranteed distinct, and all characters in `J` and `S` are letters. Letters are case sensitive, so `"a"` is considered a different type of stone from `"A"`.

**Example 1:**
```
Input: J = "aA", S = "aAAbbbb"
Output: 3
```
**Example 2:**
```
Input: J = "z", S = "ZZ"
Output: 0
```
**Note:**
- `S` and `J` will consist of letters and have length at most 50.
- The characters in `J` are distinct.

[back to top](#menu)

---
## [#783 Minimum Distance Between BST Nodes](https://leetcode.com/problems/minimum-distance-between-bst-nodes)
Given the `root` of a Binary Search Tree (BST), return *the minimum difference between the values of any two different nodes in the tree*.

**Note:** This question is the same as 530: https://leetcode.com/problems/minimum-absolute-difference-in-bst/

**Example 1:**

![](https://assets.leetcode.com/uploads/2021/02/05/bst1.jpg)
```
Input: root = [4,2,6,1,3]
Output: 1
```
**Example 2:**

![](https://assets.leetcode.com/uploads/2021/02/05/bst2.jpg)
```
Input: root = [1,0,48,null,null,12,49]
Output: 1
```
**Constraints:**
  - The number of nodes in the tree is in the range `[2, 100]`.
  - `0 <= Node.val <= 10^5`

[back to top](#menu)

---
## [#784 Letter Case Permutation](https://leetcode.com/problems/letter-case-permutation)
Given a string `s`, we can transform every letter individually to be lowercase or uppercase to create another string.

Return *a list of all possible strings we could create*. You can return the output in **any order**.

**Example 1:**
```
Input: s = "a1b2"
Output: ["a1b2","a1B2","A1b2","A1B2"]
```
**Example 2:**
```
Input: s = "3z4"
Output: ["3z4","3Z4"]
```
**Example 3:**
```
Input: s = "12345"
Output: ["12345"]
```
**Example 4:**
```
Input: s = "0"
Output: ["0"]
```
**Constraints:**
  - `s` will be a string with length between `1` and `12`.
  - `s` will consist only of letters or digits.

[back to top](#menu)

---
## [#823 Binary Trees With Factors](https://leetcode.com/problems/binary-trees-with-factors)
Given an array of unique integers, `arr`, where each integer `arr[i]` is strictly greater than `1`.

We make a binary tree using these integers, and each number may be used for any number of times. Each non-leaf node's value should be equal to the product of the values of its children.

Return *the number of binary trees we can make*. The answer may be too large so return the answer **modulo** `10^9 + 7`.

**Example 1:**
```
Input: arr = [2,4]
Output: 3
Explanation: We can make these trees: [2], [4], [4, 2, 2]
```
**Example 2:**
```
Input: arr = [2,4,5,10]
Output: 7
Explanation: We can make these trees: [2], [4], [5], [10], [4, 2, 2], [10, 2, 5], [10, 5, 2].
```
**Constraints:**
- `1 <= arr.length <= 1000`
- `2 <= arr[i] <= 10^9`

[back to top](#menu)

---
## [#844 Backspace String Compare](https://leetcode.com/problems/backspace-string-compare)
Given two strings `S` and `T`, return if they are equal when both are typed into empty text editors. `#` means a backspace character.

Note that after backspacing an empty text, the text will continue empty.

**Example 1:**
```
Input: S = "ab#c", T = "ad#c"
Output: true
Explanation: Both S and T become "ac".
```
**Example 2:**
```
Input: S = "ab##", T = "c#d#"
Output: true
Explanation: Both S and T become "".
```
**Example 3:**
```
Input: S = "a##c", T = "#a#c"
Output: true
Explanation: Both S and T become "c".
```
**Example 4:**
```
Input: S = "a#c", T = "b"
Output: false
Explanation: S becomes "c" while T becomes "b".
```
**Note:**
- `1 <= S.length <= 200`
- `1 <= T.length <= 200`
- `S` and `T` only contain lowercase letters and `'#'` characters.

**Follow up:**
- Can you solve it in `O(N)` time and `O(1)` space?

[back to top](#menu)

---
## [#851 Loud and Rich](https://leetcode.com/problems/loud-and-rich)
In a group of N people (labelled `0, 1, 2, ..., N-1`), each person has different amounts of money, and different levels of quietness.

For convenience, we'll call the person with label `x`, simply "person `x`".

We'll say that `richer[i] = [x, y]` if person x definitely has more money than person `y`.  Note that `richer` may only be a subset of valid observations.

Also, we'll say `quiet[x] = q` if person x has quietness `q`.

Now, return `answer`, where `answer[x] = y` if `y` is the least quiet person (that is, the person `y` with the smallest value of `quiet[y]`), among all people who definitely have equal to or more money than person `x`.

**Example 1:**
```
Input: richer = [[1,0],[2,1],[3,1],[3,7],[4,3],[5,3],[6,3]], quiet = [3,2,5,4,6,1,7,0]
Output: [5,5,2,5,4,5,6,7]
Explanation:
answer[0] = 5.
Person 5 has more money than 3, which has more money than 1, which has more money than 0.
The only person who is quieter (has lower quiet[x]) is person 7, but
it isn't clear if they have more money than person 0.

answer[7] = 7.
Among all people that definitely have equal to or more money than person 7
(which could be persons 3, 4, 5, 6, or 7), the person who is the quietest (has lower quiet[x])
is person 7.

The other answers can be filled out with similar reasoning.
```
**Note:**
  1. `1 <= quiet.length = N <= 500`
  2. `0 <= quiet[i] < N`, all `quiet[i]` are different.
  3. `0 <= richer.length <= N * (N-1) / 2`
  4. `0 <= richer[i][j] < N`
  5. `richer[i][0] != richer[i][1]`
  6. `richer[i]`'s are all different.
  7. The observations in `richer` are all logically consistent.

[back to top](#menu)

---
## [#869 Reordered Power of 2](https://leetcode.com/problems/reordered-power-of-2)
Starting with a positive integer `N`, we reorder the digits in any order (including the original order) such that the leading digit is not zero.

Return `true` if and only if we can do this in a way such that the resulting number is a power of 2.

**Example 1:**
```
Input: 1
Output: true
```
**Example 2:**
```
Input: 10
Output: false
```
**Example 3:**
```
Input: 16
Output: true
```
**Example 4:**
```
Input: 24
Output: false
```
**Example 5:**
```
Input: 46
Output: true
```
**Note:**
1. `1 <= N <= 10^9`

[back to top](#menu)

---
## [#870 Advantage Shuffle](https://leetcode.com/problems/advantage-shuffle)
Given two arrays `A` and `B` of equal size, the *advantage of `A` with respect to `B`* is the number of indices `i` for which `A[i] > B[i]`.

Return **any** permutation of `A` that maximizes its advantage with respect to `B`.

**Example 1:**
```
Input: A = [2,7,11,15], B = [1,10,4,11]
Output: [2,11,7,15]
```
**Example 2:**
```
Input: A = [12,24,8,32], B = [13,25,32,11]
Output: [24,32,8,12]
```
**Note:**
  1. `1 <= A.length = B.length <= 10000`
  2. `0 <= A[i] <= 10^9`
  3. `0 <= B[i] <= 10^9`

[back to top](#menu)

---
## [#876 Middle of the Linked List](https://leetcode.com/problems/middle-of-the-linked-list)
Given a non-empty, singly linked list with head node `head`, return a middle node of linked list.

If there are two middle nodes, return the second middle node.

**Example 1:**
```
Input: [1,2,3,4,5]
Output: Node 3 from this list (Serialization: [3,4,5])
The returned node has value 3.  (The judge's serialization of this node is [3,4,5]).
Note that we returned a ListNode object ans, such that:
ans.val = 3, ans.next.val = 4, ans.next.next.val = 5, and ans.next.next.next = NULL.
```
**Example 2:**
```
Input: [1,2,3,4,5,6]
Output: Node 4 from this list (Serialization: [4,5,6])
Since the list has two middle nodes with values 3 and 4, we return the second one.
```
**Note:**
- The number of nodes in the given list will be between `1` and `100`.

[back to top](#menu)

---
## [#901 Online Stock Span](https://leetcode.com/problems/online-stock-span)
Write a class `StockSpanner` which collects daily price quotes for some stock, and returns the span of that stock's price for the current day.

The span of the stock's price today is defined as the maximum number of consecutive days (starting from today and going backwards) for which the price of the stock was less than or equal to today's price.

For example, if the price of a stock over the next 7 days were `[100, 80, 60, 70, 60, 75, 85]`, then the stock spans would be `[1, 1, 1, 2, 1, 4, 6]`.

**Example 1:**
```
Input: ["StockSpanner","next","next","next","next","next","next","next"], [[],[100],[80],[60],[70],[60],[75],[85]]
Output: [null,1,1,1,2,1,4,6]
Explanation:
First, S = StockSpanner() is initialized.  Then:
S.next(100) is called and returns 1,
S.next(80) is called and returns 1,
S.next(60) is called and returns 1,
S.next(70) is called and returns 2,
S.next(60) is called and returns 1,
S.next(75) is called and returns 4,
S.next(85) is called and returns 6.

Note that (for example) S.next(75) returned 4, because the last 4 prices
(including today's price of 75) were less than or equal to today's price.
```
**Note:**
  1. Calls to `StockSpanner.next(int price)` will have `1 <= price <= 10^5`.
  2. There will be at most `10000` calls to `StockSpanner.next` per test case.
  3. There will be at most `150000` calls to `StockSpanner.next` across all test cases.
  4. The total time limit for this problem has been reduced by 75% for C++, and 50% for all other languages.

---
## [#916 Word Subsets](https://leetcode.com/problems/word-subsets)
We are given two arrays `A` and `B` of words.  Each word is a string of lowercase letters.

Now, say that word `b` is a subset of word `a` if every letter in `b` occurs in `a`, **including multiplicity**.  For example, `"wrr"` is a subset of `"warrior"`, but is not a subset of `"world"`.

Now say a word `a` from `A` is *universal* if for every `b` in `B`, `b` is a subset of `a`.

Return a list of all universal words in `A`.  You can return the words in any order.

**Example 1:**
```
Input: A = ["amazon","apple","facebook","google","leetcode"], B = ["e","o"]
Output: ["facebook","google","leetcode"]
```
**Example 2:**
```
Input: A = ["amazon","apple","facebook","google","leetcode"], B = ["l","e"]
Output: ["apple","google","leetcode"]

```
**Example 3:**
```
Input: A = ["amazon","apple","facebook","google","leetcode"], B = ["e","oo"]
Output: ["facebook","google"]
```
**Example 4:**
```
Input: A = ["amazon","apple","facebook","google","leetcode"], B = ["lo","eo"]
Output: ["google","leetcode"]
```
**Example 5:**
```
Input: A = ["amazon","apple","facebook","google","leetcode"], B = ["ec","oc","ceo"]
Output: ["facebook","leetcode"]
```
**Note:**
1. `1 <= A.length`, `B.length <= 10000`
2. `1 <= A[i].length`, `B[i].length <= 10`
3. `A[i]` and `B[i]` consist only of lowercase letters.
4. All words in `A[i]` are unique: there isn't `i != j` with `A[i] == A[j]`.

[back to top](#menu)

---
## [#918 Maximum Sum Circular Subarray](https://leetcode.com/problems/maximum-sum-circular-subarray)
Given a **circular array C** of integers represented by `A`, find the maximum possible sum of a non-empty subarray of **C**.

Here, a *circular array* means the end of the array connects to the beginning of the array.  (Formally, `C[i] = A[i]` when `0 <= i < A.length`, and `C[i+A.length] = C[i]` when `i >= 0`.)

Also, a subarray may only include each element of the fixed buffer `A` at most once.  (Formally, for a subarray `C[i], C[i+1], ..., C[j]`, there does not exist `i <= k1, k2 <= j` with `k1 % A.length = k2 % A.length`.)

**Example 1:**
```
Input: [1,-2,3,-2]
Output: 3
Explanation: Subarray [3] has maximum sum 3
```
**Example 2:**
```
Input: [5,-3,5]
Output: 10
Explanation: Subarray [5,5] has maximum sum 5 + 5 = 10
```
**Example 3:**
```
Input: [3,-1,2,-1]
Output: 4
Explanation: Subarray [2,-1,3] has maximum sum 2 + (-1) + 3 = 4
```
**Example 4:**
```
Input: [3,-2,2,-3]
Output: 3
Explanation: Subarray [3] and [3,-2,2] both have maximum sum 3
```
**Example 5:**
```
Input: [-2,-3,-1]
Output: -1
Explanation: Subarray [-1] has maximum sum -1
```
**Note:**
1. `-30000 <= A[i] <= 30000`
2. `1 <= A.length <= 30000`

[back to top](#menu)

---
## [#953 Verifying an Alien Dictionary](https://leetcode.com/problems/verifying-an-alien-dictionary)
In an alien language, surprisingly they also use english lowercase letters, but possibly in a different `order`. The `order` of the alphabet is some permutation of lowercase letters.

Given a sequence of `words` written in the alien language, and the `order` of the alphabet, return `true` if and only if the given `words` are sorted lexicographicaly in this alien language.

**Example 1:**
```
Input: words = ["hello","leetcode"], order = "hlabcdefgijkmnopqrstuvwxyz"
Output: true
Explanation: As 'h' comes before 'l' in this language, then the sequence is sorted.
```
**Example 2:**
```
Input: words = ["word","world","row"], order = "worldabcefghijkmnpqstuvxyz"
Output: false
Explanation: As 'd' comes after 'l' in this language, then words[0] > words[1], hence the sequence is unsorted.
```
**Example 3:**
```
Input: words = ["apple","app"], order = "abcdefghijklmnopqrstuvwxyz"
Output: false
Explanation: The first three characters "app" match, and the second string is shorter (in size.) According to lexicographical rules "apple" > "app", because 'l' > '∅', where '∅' is defined as the blank character which is less than any other character (More info).
```
[More info](https://en.wikipedia.org/wiki/Lexicographical_order)
**Constraints:**
  - `1 <= words.length <= 100`
  - `1 <= words[i].length <= 20`
  - `order.length == 26`
  - All characters in `words[i]` and `order` are English lowercase letters.
[back to top](#menu)

---
## [#971 Flip Binary Tree To Match Preorder Traversal](https://leetcode.com/problems/flip-binary-tree-to-match-preorder-traversal)
You are given the `root` of a binary tree with `n` nodes, where each node is uniquely assigned a value from `1` to `n`. You are also given a sequence of `n` values `voyage`, which is the **desired [pre-order traversal](https://en.wikipedia.org/wiki/Tree_traversal#Pre-order)** of the binary tree.

Any node in the binary tree can be **flipped** by swapping its left and right subtrees. For example, flipping node 1 will have the following effect:

![](https://assets.leetcode.com/uploads/2021/02/15/fliptree.jpg)

Flip the **smallest** number of nodes so that the **pre-order traversal** of the tree **matches** `voyage`.

Return *a list of the values of all **flipped** nodes. You may return the answer in **any order**. If it is **impossible** to flip the nodes in the tree to make the pre-order traversal match `voyage`, return the list* `[-1]`.

**Example 1:**

![](https://assets.leetcode.com/uploads/2019/01/02/1219-01.png)
```
Input: root = [1,2], voyage = [2,1]
Output: [-1]
Explanation: It is impossible to flip the nodes such that the pre-order traversal matches voyage.
```
**Example 2:**

![](https://assets.leetcode.com/uploads/2019/01/02/1219-02.png)
```
Input: root = [1,2,3], voyage = [1,3,2]
Output: [1]
Explanation: Flipping node 1 swaps nodes 2 and 3, so the pre-order traversal matches voyage.
```
**Example 3:**

![](https://assets.leetcode.com/uploads/2019/01/02/1219-02.png)
```
Input: root = [1,2,3], voyage = [1,2,3]
Output: []
Explanation: The tree's pre-order traversal already matches voyage, so no nodes need to be flipped.
```
**Constraints:**
  - The number of nodes in the tree is `n`.
  - `n == voyage.length`
  - `1 <= n <= 100`
  - `1 <= Node.val`, `voyage[i] <= n`
  - All the values in the tree are **unique**.
  - All the values in `voyage` are **unique**.

[back to top](#menu)

---
## [#977 Squares of a Sorted Array](https://leetcode.com/problems/squares-of-a-sorted-array)
Given an integer array `nums` sorted in **non-decreasing** order, return *an array of **the squares of each number** sorted in non-decreasing order*.

**Example 1:**
```
Input: nums = [-4,-1,0,3,10]
Output: [0,1,9,16,100]
Explanation: After squaring, the array becomes [16,1,0,9,100].
After sorting, it becomes [0,1,9,16,100].
```
**Example 2:**
```
Input: nums = [-7,-3,2,3,11]
Output: [4,9,9,49,121]
```
**Constraints:**
  - `1 <= nums.length <= 10^4`
  - `-10^4 <= nums[i] <= 10^4`
  - `nums` is sorted in **non-decreasing** order.

[back to top](#menu)

---
## [#992 Subarrays with K Different Integers](https://leetcode.com/problems/subarrays-with-k-different-integers)
Given an array `A` of positive integers, call a (contiguous, not necessarily distinct) subarray of `A` good if the number of different integers in that subarray is exactly `K`.

(For example, `[1,2,3,1,2]` has `3` different integers: `1`, `2`, and `3`.)

Return the number of good subarrays of `A`.

**Example 1:**
```
Input: A = [1,2,1,2,3], K = 2
Output: 7
Explanation: Subarrays formed with exactly 2 different integers: [1,2], [2,1], [1,2], [2,3], [1,2,1], [2,1,2], [1,2,1,2].
```
**Example 2:**
```
Input: A = [1,2,1,3,4], K = 3
Output: 3
Explanation: Subarrays formed with exactly 3 different integers: [1,2,1,3], [2,1,3], [1,3,4].
```
**Note:**
1. `1 <= A.length <= 20000`
2. `1 <= A[i] <= A.length`
3. `1 <= K <= A.length`

[back to top](#menu)

---
## [#993 Cousins in Binary Tree](https://leetcode.com/problems/cousins-in-binary-tree)
In a binary tree, the root node is at depth `0`, and children of each depth `k` node are at depth `k+1`.

Two nodes of a binary tree are cousins if they have the same depth, but have **different parents**.

We are given the `root` of a binary tree with unique values, and the values `x` and `y` of two different nodes in the tree.

Return `true` if and only if the nodes corresponding to the values `x` and `y` are cousins.

**Example 1:**

![](https://assets.leetcode.com/uploads/2019/02/12/q1248-01.png)
```
Input: root = [1,2,3,4], x = 4, y = 3
Output: false
```
**Example 2:**

![](https://assets.leetcode.com/uploads/2019/02/12/q1248-02.png)
```
Input: root = [1,2,3,null,4,null,5], x = 5, y = 4
Output: true
```
**Example 3:**

![](https://assets.leetcode.com/uploads/2019/02/13/q1248-03.png)
```
Input: root = [1,2,3,null,4], x = 2, y = 3
Output: false
```
**Note:**
1. The number of nodes in the tree will be between `2` and `100`.
2. Each node has a unique integer value from `1` to `100`.

[back to top](#menu)

---
## [#994 Rotting Oranges](https://leetcode.com/problems/rotting-oranges)
You are given an `m x n` grid where each cell can have one of three values:
  - `0` representing an empty cell,
  - `1` representing a fresh orange, or
  - `2` representing a rotten orange.

Every minute, any fresh orange that is **4-directionally adjacent** to a rotten orange becomes rotten.

Return *the minimum number of minutes that must elapse until no cell has a fresh orange*. If *this is impossible, return `-1`*.

**Example 1:**

![](https://assets.leetcode.com/uploads/2019/02/16/oranges.png)
```
Input: grid = [[2,1,1],[1,1,0],[0,1,1]]
Output: 4
```
**Example 2:**
```
Input: grid = [[2,1,1],[0,1,1],[1,0,1]]
Output: -1
Explanation: The orange in the bottom left corner (row 2, column 0) is never rotten, because rotting only happens 4-directionally.
```
**Example 3:**
```
Input: grid = [[0,2]]
Output: 0
Explanation: Since there are already no fresh oranges at minute 0, the answer is just 0.
```
**Constraints:**
  - `m == grid.length`
  - `n == grid[i].length`
  - `1 <= m, n <= 10`
  - `grid[i][j]` is `0`, `1`, or `2`.

[back to top](#menu)

---
## [#997 Find the Town Judge](https://leetcode.com/problems/find-the-town-judge)
In a town, there are `N` people labelled from `1` to `N`.  There is a rumor that one of these people is secretly the town judge.

If the town judge exists, then:
1. The town judge trusts nobody.
2. Everybody (except for the town judge) trusts the town judge.
3. There is exactly one person that satisfies properties 1 and 2.

You are given `trust`, an array of pairs `trust[i] = [a, b]` representing that the person labelled `a` trusts the person labelled `b`.

If the town judge exists and can be identified, return the label of the town judge.  Otherwise, return `-1`.

**Example 1:**
```
Input: N = 2, trust = [[1,2]]
Output: 2
```
**Example 2:**
```
Input: N = 3, trust = [[1,3],[2,3]]
Output: 3
```
**Example 3:**
```
Input: N = 3, trust = [[1,3],[2,3],[3,1]]
Output: -1
```
**Example 4:**
```
Input: N = 3, trust = [[1,2],[2,3]]
Output: -1
```
**Example 5:**
```
Input: N = 4, trust = [[1,3],[1,4],[2,3],[2,4],[4,3]]
Output: 3
```
**Note:**
1. `1 <= N <= 1000`
2. `trust.length <= 10000`
3. `trust[i]` are all different
4. `trust[i][0] != trust[i][1]`
5. `1 <= trust[i][0], trust[i][1] <= N`

[back to top](#menu)

---
## [#1008 Construct Binary Search Tree from Preorder Traversal](https://leetcode.com/problems/construct-binary-search-tree-from-preorder-traversal)
Return the root node of a binary **search** tree that matches the given `preorder` traversal.

*(Recall that a binary search tree is a binary tree where for every node, any descendant of `node.left` has a value `<` `node.val`, and any descendant of `node.right` has a value `>` `node.val`.  Also recall that a preorder traversal displays the value of the `node` first, then traverses `node.left`, then traverses `node.right`.)*

**Example 1:**
```
Input: [8,5,1,7,10,12]
Output: [8,5,10,1,7,null,12]
```
![Output](https://assets.leetcode.com/uploads/2019/03/06/1266.png)

**Note:**
1. `1 <= preorder.length <= 100`
2. The values of `preorder` are distinct.

[back to top](#menu)

---
## [#1022 Sum of Root To Leaf Binary Numbers](https://leetcode.com/problems/sum-of-root-to-leaf-binary-numbers)
You are given the `root` of a binary tree where each node has a value `0` or `1`.  Each root-to-leaf path represents a binary number starting with the most significant bit.  For example, if the path is `0 -> 1 -> 1 -> 0 -> 1`, then this could represent `01101` in binary, which is `13`.

For all leaves in the tree, consider the numbers represented by the path from the root to that leaf.

Return *the sum of these numbers*. The answer is **guaranteed** to fit in a **32-bits** integer.

**Example 1:**

![](https://assets.leetcode.com/uploads/2019/04/04/sum-of-root-to-leaf-binary-numbers.png)
```
Input: root = [1,0,1,0,1,0,1]
Output: 22
Explanation: (100) + (101) + (110) + (111) = 4 + 5 + 6 + 7 = 22
```
**Example 2:**
```
Input: root = [0]
Output: 0
```
**Example 3:**
```
Input: root = [1]
Output: 1
```
**Example 4:**
```
Input: root = [1,1]
Output: 3
```

**Constraints:**
- The number of nodes in the tree is in the range **[1, 1000]**.
- `Node.val` is `0` or `1`.

[back to top](#menu)

---
## [#1024 Video Stitching](https://leetcode.com/problems/video-stitching)
You are given a series of video clips from a sporting event that lasted T seconds.  These video clips can be overlapping with each other and have varied lengths.

Each video clip clips[i] is an interval: it starts at time clips[i][0] and ends at time clips[i][1].  We can cut these clips into segments freely: for example, a clip [0, 7] can be cut into segments [0, 1] + [1, 3] + [3, 7].

Return the minimum number of clips needed so that we can cut the clips into segments that cover the entire sporting event ([0, T]).  If the task is impossible, return -1.

**Example 1:**
```
Input: clips = [[0,2],[4,6],[8,10],[1,9],[1,5],[5,9]], T = 10
Output: 3
Explanation:
We take the clips [0,2], [8,10], [1,9]; a total of 3 clips.
Then, we can reconstruct the sporting event as follows:
We cut [1,9] into segments [1,2] + [2,8] + [8,9].
Now we have segments [0,2] + [2,8] + [8,10] which cover the sporting event [0, 10].
```
**Example 2:**
```
Input: clips = [[0,1],[1,2]], T = 5
Output: -1
Explanation:
We can't cover [0,5] with only [0,1] and [0,2].
```
**Example 3:**
```
Input: clips = [[0,1],[6,8],[0,2],[5,6],[0,4],[0,3],[6,7],[1,3],[4,7],[1,4],[2,5],[2,6],[3,4],[4,5],[5,7],[6,9]], T = 9
Output: 3
Explanation:
We can take clips [0,4], [4,7], and [6,9].
```
**Example 4:**
```
Input: clips = [[0,4],[2,8]], T = 5
Output: 2
Explanation:
Notice you can have extra video after the event ends.
```
**Note:**
1. `1 <= clips.length <= 100`
2. `0 <= clips[i][0], clips[i][1] <= 100`
3. `0 <= T <= 100`

[back to top](#menu)

---
## [#1046 Last Stone Weight](https://leetcode.com/problems/last-stone-weight)
We have a collection of stones, each stone has a positive integer weight.

Each turn, we choose the two **heaviest** stones and smash them together.  Suppose the stones have weights `x` and `y` with `x <= y`.  The result of this smash is:
- If `x == y`, both stones are totally destroyed;
- If `x != y`, the stone of weight `x` is totally destroyed, and the stone of weight `y` has new weight `y-x`.
At the end, there is at most 1 stone left.  Return the weight of this stone (or 0 if there are no stones left.)

**Example 1:**
```
Input: [2,7,4,1,8,1]
Output: 1
Explanation:
We combine 7 and 8 to get 1 so the array converts to [2,4,1,1,1] then,
we combine 2 and 4 to get 2 so the array converts to [2,1,1,1] then,
we combine 2 and 1 to get 1 so the array converts to [1,1,1] then,
we combine 1 and 1 to get 0 so the array converts to [1] then that's the value of last stone.
```
**Note:**
1. `1 <= stones.length <= 30`
2. `1 <= stones[i] <= 1000`

[back to top](#menu)

---
## [#1143 Longest Common Subsequence](https://leetcode.com/problems/longest-common-subsequence)
Given two strings `text1` and `text2`, return the length of their longest common subsequence.

A *subsequence* of a string is a new string generated from the original string with some characters(can be none) deleted without changing the relative order of the remaining characters. (eg, "ace" is a subsequence of "abcde" while "aec" is not). A *common subsequence* of two strings is a subsequence that is common to both strings.

If there is no common subsequence, return 0.

**Example 1:**
```
Input: text1 = "abcde", text2 = "ace"
Output: 3  
Explanation: The longest common subsequence is "ace" and its length is 3.
```
**Example 2:**
```
Input: text1 = "abc", text2 = "abc"
Output: 3
Explanation: The longest common subsequence is "abc" and its length is 3.
```
**Example 3:**
```
Input: text1 = "abc", text2 = "def"
Output: 0
Explanation: There is no such common subsequence, so the result is 0.
```

**Constraints:**
- `1 <= text1.length <= 1000`
- `1 <= text2.length <= 1000`
- The input strings consist of lowercase English characters only.

[back to top](#menu)

---
## [#1147 Longest Chunked Palindrome Decomposition](https://leetcode.com/problems/longest-chunked-palindrome-decomposition)
You are given a string `text`. You should split it to k substrings `(subtext1, subtext2, ..., subtextk)` such that:
- `subtexti` is a **non-empty** string.
- The concatenation of all the substrings is equal to `text` (i.e., `subtext1 + subtext2 + ... + subtextk == text`).
- `subtexti == subtextk - i + 1` for all valid values of `i` (i.e., `1 <= i <= k`).

Return the largest possible value of `k`.

**Example 1:**
```
Input: text = "ghiabcdefhelloadamhelloabcdefghi"
Output: 7
Explanation: We can split the string on "(ghi)(abcdef)(hello)(adam)(hello)(abcdef)(ghi)".
```
**Example 2:**
```
Input: text = "merchant"
Output: 1
Explanation: We can split the string on "(merchant)".
```
**Example 3:**
```
Input: text = "antaprezatepzapreanta"
Output: 11
Explanation: We can split the string on "(a)(nt)(a)(pre)(za)(tpe)(za)(pre)(a)(nt)(a)".
```
**Example 4:**
```
Input: text = "aaa"
Output: 3
Explanation: We can split the string on "(a)(a)(a)".
```

**Constraints:**
- `1 <= text.length <= 1000`
- `text` consists only of lowercase English characters.

[back to top](#menu)

---
## [#1232 Check If It Is a Straight Line](https://leetcode.com/problems/check-if-it-is-a-straight-line)
You are given an array `coordinates`, `coordinates[i] = [x, y]`, where `[x, y]` represents the coordinate of a point. Check if these points make a straight line in the XY plane.

**Example 1:**

![](https://assets.leetcode.com/uploads/2019/10/15/untitled-diagram-2.jpg)
```
Input: coordinates = [[1,2],[2,3],[3,4],[4,5],[5,6],[6,7]]
Output: true
```
**Example 2:**

![](https://assets.leetcode.com/uploads/2019/10/09/untitled-diagram-1.jpg)
```
Input: coordinates = [[1,1],[2,2],[3,4],[4,5],[5,6],[7,7]]
Output: false
```
**Constraints:**
- `2 <= coordinates.length <= 1000`
- `coordinates[i].length == 2`
- `-10^4 <= coordinates[i][0], coordinates[i][1] <= 10^4`
- `coordinates` contains no duplicate point.

[back to top](#menu)

---
## [#1302 Deepest Leaves Sum](https://leetcode.com/problems/deepest-leaves-sum)
Given a binary tree, return the sum of values of its deepest leaves.

**Example 1:**

![](https://assets.leetcode.com/uploads/2019/07/31/1483_ex1.png)
```
Input: root = [1,2,3,4,5,null,6,7,null,null,null,null,8]
Output: 15
```
**Constraints:**
- The number of nodes in the tree is between `1` and `10^4`.
- The value of nodes is between `1` and `100`.

[back to top](#menu)

---
## [#1306 Jump Game III](https://leetcode.com/problems/jump-game-iii)
Given an array of non-negative integers `arr`, you are initially positioned at `start` index of the array. When you are at index `i`, you can jump to `i + arr[i]` or `i - arr[i]`, check if you can reach to **any** index with value 0.

Notice that you can not jump outside of the array at any time.

**Example 1:**
```
Input: arr = [4,2,3,0,3,1,2], start = 5
Output: true
Explanation:
All possible ways to reach at index 3 with value 0 are:
index 5 -> index 4 -> index 1 -> index 3
index 5 -> index 6 -> index 4 -> index 1 -> index 3
```
**Example 2:**
```
Input: arr = [4,2,3,0,3,1,2], start = 0
Output: true
Explanation:
One possible way to reach at index 3 with value 0 is:
index 0 -> index 4 -> index 1 -> index 3
```
**Example 3:**
```
Input: arr = [3,0,2,1,2], start = 2
Output: false
Explanation: There is no way to reach at index 1 with value 0.
```
**Constraints:**
  - `1 <= arr.length <= 5 * 10^4`
  - `0 <= arr[i] < arr.length`
  - `0 <= start < arr.length`

[back to top](#menu)

---
## [#1337 The K Weakest Rows in a Matrix](https://leetcode.com/problems/the-k-weakest-rows-in-a-matrix)
You are given an `m x n` binary matrix `mat` of `1`'s (representing soldiers) and `0`'s (representing civilians). The soldiers are positioned **in front** of the civilians. That is, all the `1`'s will appear to the **left** of all the `0`'s in each row.

A row `i` is **weaker** than a row `j` if one of the following is true:

- The number of soldiers in row `i` is less than the number of soldiers in row `j`.
- Both rows have the same number of soldiers and `i < j`.

Return *the indices of the `k` **weakest** rows in the matrix ordered from weakest to strongest*.

**Example 1:**
```
Input: mat =
[[1,1,0,0,0],
 [1,1,1,1,0],
 [1,0,0,0,0],
 [1,1,0,0,0],
 [1,1,1,1,1]],
k = 3
Output: [2,0,3]
Explanation:
The number of soldiers in each row is:
- Row 0: 2
- Row 1: 4
- Row 2: 1
- Row 3: 2
- Row 4: 5
The rows ordered from weakest to strongest are [2,0,3,1,4].
```
**Example 2:**
```
Input: mat =
[[1,0,0,0],
 [1,1,1,1],
 [1,0,0,0],
 [1,0,0,0]],
k = 2
Output: [0,2]
Explanation:
The number of soldiers in each row is:
- Row 0: 1
- Row 1: 4
- Row 2: 1
- Row 3: 1
The rows ordered from weakest to strongest are [0,2,3,1].
```

**Constraints:**
- `m == mat.length`
- `n == mat[i].length`
- `2 <= n, m <= 100`
- `1 <= k <= m`
- `matrix[i][j]` is either 0 or 1.

[back to top](#menu)

---
## [#1695 Maximum Erasure Value](https://leetcode.com/problems/maximum-erasure-value)
You are given an array of positive integers `nums` and want to erase a subarray containing **unique elements**. The **score** you get by erasing the subarray is equal to the **sum** of its elements.

Return *the **maximum score** you can get by erasing **exactly one** subarray*.

An array `b` is called to be a subarray of `a` if it forms a contiguous subsequence of `a`, that is, if it is equal to `a[l],a[l+1],...,a[r]` for some `(l,r)`.

**Example 1:**
```
Input: nums = [4,2,4,5,6]
Output: 17
Explanation: The optimal subarray here is [2,4,5,6].
```
**Example 2:**
```
Input: nums = [5,2,1,2,5,2,1,2,5]
Output: 8
Explanation: The optimal subarray here is [5,2,1] or [1,2,5].
```

**Constraints:**
- `1 <= nums.length <= 10^5`
- `1 <= nums[i] <= 10^4`

[back to top](#menu)

---
## [#1704 Determine if String Halves Are Alike](https://leetcode.com/problems/determine-if-string-halves-are-alike)
You are given a string `s` of even length. Split this string into two halves of equal lengths, and let `a` be the first half and `b` be the second half.

Two strings are **alike** if they have the same number of vowels (`'a'`, `'e'`, `'i'`, `'o'`, `'u'`, `'A'`, `'E'`, `'I'`, `'O'`, `'U'`). Notice that `s` contains uppercase and lowercase letters.

Return `true` *if `a` and `b` are **alike***. Otherwise, return `false`.

**Example 1:**
```
Input: s = "book"
Output: true
Explanation: a = "bo" and b = "ok". a has 1 vowel and b has 1 vowel. Therefore, they are alike.
```
**Example 2:**
```
Input: s = "textbook"
Output: false
Explanation: a = "text" and b = "book". a has 1 vowel whereas b has 2. Therefore, they are not alike.
Notice that the vowel o is counted twice.
```
**Example 3:**
```
Input: s = "MerryChristmas"
Output: false
```
**Example 4:**
```
Input: s = "AbCdEfGh"
Output: true
```
**Constraints:**
  - `2 <= s.length <= 1000`
  - `s.length` is even.
  - `s` consists of **uppercase and lowercase** letters.

[back to top](#menu)

---
## [#1721 Swapping Nodes in a Linked List](https://leetcode.com/problems/swapping-nodes-in-a-linked-list)
You are given the `head` of a linked list, and an integer `k`.

Return *the head of the linked list after **swapping** the values of the `kth` node from the beginning and the `kth` node from the end (the list is **1-indexed**)*.

**Example 1:**

![](https://assets.leetcode.com/uploads/2020/09/21/linked1.jpg)
```
Input: head = [1,2,3,4,5], k = 2
Output: [1,4,3,2,5]
```
**Example 2:**
```
Input: head = [7,9,6,6,7,8,3,0,9,5], k = 5
Output: [7,9,6,6,8,7,3,0,9,5]
```
**Example 3:**
```
Input: head = [1], k = 1
Output: [1]
```
**Example 4:**
```
Input: head = [1,2], k = 1
Output: [2,1]
```
**Example 5:**
```
Input: head = [1,2,3], k = 2
Output: [1,2,3]
```

**Constraints:**
- The number of nodes in the list is `n`.
- `1 <= k <= n <= 10^5`
- `0 <= Node.val <= 100`
[back to top](#menu)

---
## [#1732 Find the Highest Altitude](https://leetcode.com/problems/find-the-highest-altitude)
There is a biker going on a road trip. The road trip consists of `n + 1` points at different altitudes. The biker starts his trip on point `0` with altitude equal `0`.

You are given an integer array `gain` of length `n` where `gain[i]` is the `net gain in altitude` between points `i​​​​​​` and `i + 1` for all (`0 <= i < n`). Return *the **highest altitude** of a point*.

**Example 1:**
```
Input: gain = [-5,1,5,0,-7]
Output: 1
Explanation: The altitudes are [0,-5,-4,1,1,-6]. The highest is 1.
```
**Example 2:**
```
Input: gain = [-4,-3,-2,-1,4,3,2]
Output: 0
Explanation: The altitudes are [0,-4,-7,-9,-10,-6,-3,-1]. The highest is 0.
```

**Constraints:**
- `n == gain.length`
- `1 <= n <= 100`
- `-100 <= gain[i] <= 100`

[back to top](#menu)

---
## [Leftmost Column with at Least a One](https://leetcode.com/explore/challenge/card/30-day-leetcoding-challenge/530/week-3/3306)
*(This problem is an **interactive problem**.)*

A binary matrix means that all elements are `0` or `1`. For each **individual** row of the matrix, this row is sorted in non-decreasing order.

Given a row-sorted binary matrix binaryMatrix, return leftmost column index(0-indexed) with at least a `1` in it. If such index doesn't exist, return `-1`.

**You can't access the Binary Matrix directly**.  You may only access the matrix using a `BinaryMatrix` interface:
- `BinaryMatrix.get(x, y)` returns the element of the matrix at index (x, y) (0-indexed).
- `BinaryMatrix.dimensions()` returns a list of 2 elements `[m, n]`, which means the matrix is `m * n`.

Submissions making more than `1000` calls to `BinaryMatrix.get` will be judged *Wrong Answer*.  Also, any solutions that attempt to circumvent the judge will result in disqualification.

For custom testing purposes you're given the binary matrix `mat` as input in the following four examples. You will not have access the binary matrix directly.

**Example 1:**

![](https://assets.leetcode.com/uploads/2019/10/25/untitled-diagram-5.jpg)
```
Input: mat = [[0,0],[1,1]]
Output: 0
```
**Example 2:**

![](https://assets.leetcode.com/uploads/2019/10/25/untitled-diagram-4.jpg)
```
Input: mat = [[0,0],[0,1]]
Output: 1
```
**Example 3:**

![](https://assets.leetcode.com/uploads/2019/10/25/untitled-diagram-3.jpg)
```
Input: mat = [[0,0],[0,0]]
Output: -1
```
**Example 4:**

![](https://assets.leetcode.com/uploads/2019/10/25/untitled-diagram-6.jpg)
```
Input: mat = [[0,0,0,1],[0,0,1,1],[0,1,1,1]]
Output: 1
```
**Constraints:**
- `m == mat.length`
- `n == mat[i].length`
- `1 <= m, n <= 100`
- `mat[i][j]` is either `0` or `1`.
- `mat[i]` is sorted in a non-decreasing way.

[back to top](#menu)

---
## [First Unique Number](https://leetcode.com/explore/challenge/card/30-day-leetcoding-challenge/531/week-4/3313)
You have a queue of integers, you need to retrieve the first unique integer in the queue.

Implement the `FirstUnique` class:
- `FirstUnique(int[] nums)` Initializes the object with the numbers in the queue.
- `int showFirstUnique()` returns the value of **the first unique** integer of the queue, and returns **-1** if there is no such integer.
- `void add(int value)` insert value to the queue.

**Example 1:**
```
Input:
["FirstUnique","showFirstUnique","add","showFirstUnique","add","showFirstUnique","add","showFirstUnique"]
[[[2,3,5]],[],[5],[],[2],[],[3],[]]
Output:
[null,2,null,2,null,3,null,-1]

Explanation:
FirstUnique firstUnique = new FirstUnique([2,3,5]);
firstUnique.showFirstUnique(); // return 2
firstUnique.add(5);            // the queue is now [2,3,5,5]
firstUnique.showFirstUnique(); // return 2
firstUnique.add(2);            // the queue is now [2,3,5,5,2]
firstUnique.showFirstUnique(); // return 3
firstUnique.add(3);            // the queue is now [2,3,5,5,2,3]
firstUnique.showFirstUnique(); // return -1
```
**Example 2:**
```
Input:
["FirstUnique","showFirstUnique","add","add","add","add","add","showFirstUnique"]
[[[7,7,7,7,7,7]],[],[7],[3],[3],[7],[17],[]]
Output:
[null,-1,null,null,null,null,null,17]

Explanation:
FirstUnique firstUnique = new FirstUnique([7,7,7,7,7,7]);
firstUnique.showFirstUnique(); // return -1
firstUnique.add(7);            // the queue is now [7,7,7,7,7,7,7]
firstUnique.add(3);            // the queue is now [7,7,7,7,7,7,7,3]
firstUnique.add(3);            // the queue is now [7,7,7,7,7,7,7,3,3]
firstUnique.add(7);            // the queue is now [7,7,7,7,7,7,7,3,3,7]
firstUnique.add(17);           // the queue is now [7,7,7,7,7,7,7,3,3,7,17]
firstUnique.showFirstUnique(); // return 17
```
**Example 3:**
```
Input:
["FirstUnique","showFirstUnique","add","showFirstUnique"]
[[[809]],[],[809],[]]
Output:
[null,809,null,-1]

Explanation:
FirstUnique firstUnique = new FirstUnique([809]);
firstUnique.showFirstUnique(); // return 809
firstUnique.add(809);          // the queue is now [809,809]
firstUnique.showFirstUnique(); // return -1
```
**Constraints:**
- `1 <= nums.length <= 10^5`
- `1 <= nums[i] <= 10^8`
- `1 <= value <= 10^8`
- At most `50000` calls will be made to `showFirstUnique` and `add`.

[back to top](#menu)
