# [菜单](https://leetcode-cn.com/problemset/all/)
- [x] [#1 两数之和](#1-两数之和)
- [x] [#2 两数相加](#2-两数相加)
- [x] [#3 无重复字符的最长子串](#3-无重复字符的最长子串)
- [x] [#4 寻找两个有序数组的中位数](#4-寻找两个有序数组的中位数)
- [x] [#5 最长回文子串](#5-最长回文子串)
- [x] [#6 Z 字形变换](#6-z-字形变换)
- [x] [#7 整数反转](#7-整数反转)
- [x] [#9 回文数](#9-回文数)
- [x] [#13 罗马数字转整数](#13-罗马数字转整数)
- [x] [#14 最长公共前缀](#14-最长公共前缀)
- [x] [#20 有效的括号](#20-有效的括号)
- [x] [#21 合并两个有序链表](#21-合并两个有序链表)
- [x] [#26 删除排序数组中的重复项](#26-删除排序数组中的重复项)
- [x] [#27 移除元素](#27-移除元素)
- [x] [#28 实现 strStr()](#28-实现-strstr)
- [x] [#35 搜索插入位置](#35-搜索插入位置)
- [x] [#38 外观数列](#38-外观数列)
- [x] [#49 字母异位词分组](#53-字母异位词分组)
- [x] [#53 最大子序和](#53-最大子序和)
- [x] [#58 最后一个单词的长度](#58-最后一个单词的长度)
- [x] [#66 加一](#66-加一)
- [x] [#67 二进制求和](#67-二进制求和)
- [x] [#69 x 的平方根](#69-x-的平方根)
- [x] [#70 爬楼梯](#70-爬楼梯)
- [x] [#83 删除排序链表中的重复元素](#83-删除排序链表中的重复元素)
- [x] [#88 合并两个有序数组](#88-合并两个有序数组)
- [x] [#100 相同的树](#100-相同的树)
- [x] [#101 对称二叉树](#101-对称二叉树)
- [x] [#104 二叉树的最大深度](#104-二叉树的最大深度)
- [x] [#107 二叉树的层次遍历 II](#107-二叉树的层次遍历-ii)
- [x] [#108 将有序数组转换为二叉搜索树](#108-将有序数组转换为二叉搜索树)
- [x] [#110 平衡二叉树](#110-平衡二叉树)
- [x] [#111 二叉树的最小深度](#111-二叉树的最小深度)
- [x] [#112 路径总和](#112-路径总和)
- [x] [#118 杨辉三角](#118-杨辉三角)
- [x] [#119 杨辉三角 II](#119-杨辉三角-ii)
- [x] [#121 买卖股票的最佳时机](#121-买卖股票的最佳时机)
- [x] [#122 买卖股票的最佳时机 II](#122-买卖股票的最佳时机-ii)
- [x] [#125 验证回文串](#125-验证回文串)
- [x] [#136 只出现一次的数字](#136-只出现一次的数字)
- [x] [#141 环形链表](#141-环形链表)
- [x] [#155 最小栈](#155-最小栈)
- [x] [#160 相交链表](#160-相交链表)
- [x] [#167 两数之和 II - 输入有序数组](#167-两数之和-ii-输入有序数组)
- [x] [#168 Excel表列名称](#168-excel表列名称)
- [x] [#169 多数元素](#169-多数元素)
- [x] [#171 Excel表列序号](#171-excel表列序号)
- [x] [#172 阶乘后的零](#172-阶乘后的零)
- [x] [#175 组合两个表](#175-组合两个表)
- [x] [#176 第二高的薪水](#176-第二高的薪水)
- [x] [#181 超过经理收入的员工](#181-超过经理收入的员工)
- [x] [#182 查找重复的电子邮箱](#182-查找重复的电子邮箱)
- [x] [#183 从不订购的客户](#183-从不订购的客户)
- [x] [#189 旋转数组](#189-旋转数组)
- [x] [#190 颠倒二进制位](#190-颠倒二进制位)
- [x] [#191 位1的个数](#191-位1的个数)
- [x] [#193 有效电话号码](#193-有效电话号码)
- [x] [#224 基本计算器](#224-基本计算器)
- [x] [#300 最长上升子序列](#300-最长上升子序列)
- [x] [#434 字符串中的单词数](#434-字符串中的单词数)
- [x] [#467 环绕字符串中唯一的子字符串](#467-环绕字符串中唯一的子字符串)
- [x] [#747 至少是其他数字两倍的最大数](#747-至少是其他数字两倍的最大数)
- [x] [#869 重新排序得到 2 的幂](#869-重新排序得到-2-的幂)
- [x] [#992 K 个不同整数的子数组](#992-k-个不同整数的子数组)
---
## [#1 两数之和](https://leetcode-cn.com/problems/two-sum)
给定一个整数数组 `nums` 和一个目标值 `target`，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。

你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。

**示例:**
```
给定 nums = [2, 7, 11, 15], target = 9

因为 nums[0] + nums[1] = 2 + 7 = 9
所以返回 [0, 1]
```
[回到顶部](#菜单)

---
## [#2 两数相加](https://leetcode-cn.com/problems/add-two-numbers)
给出两个 **非空** 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 **逆序** 的方式存储的，并且它们的每个节点只能存储 一位 数字。

如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。

您可以假设除了数字 0 之外，这两个数都不会以 0 开头。

**示例:**
```
输入：(2 -> 4 -> 3) + (5 -> 6 -> 4)
输出：7 -> 0 -> 8
原因：342 + 465 = 807
```
[回到顶部](#菜单)

---
## [#3 无重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters)
给定一个字符串，请你找出其中不含有重复字符的 **最长子串** 的长度。

**示例 1:**
```
输入: "abcabcbb"
输出: 3
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
```
**示例 2:**
```
输入: "bbbbb"
输出: 1
解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。
```
**示例 3:**
```
输入: "pwwkew"
输出: 3
解释: 因为无重复字符的最长子串是"wke"，所以其长度为 3。
     请注意，你的答案必须是 子串 的长度，"pwke"是一个子序列，不是子串。
```
[回到顶部](#菜单)

---
## [#4 寻找两个有序数组的中位数](https://leetcode-cn.com/problems/median-of-two-sorted-arrays)
给定两个大小为 m 和 n 的有序数组 `nums1` 和 `nums2`。

请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。

你可以假设 `nums1` 和 `nums2` 不会同时为空。

**示例 1:**
```
nums1 = [1, 3]
nums2 = [2]

则中位数是 2.0
```
**示例 2:**
```
nums1 = [1, 2]
nums2 = [3, 4]

则中位数是 (2 + 3)/2 = 2.5
```
[回到顶部](#菜单)

---
## [#5 最长回文子串](https://leetcode-cn.com/problems/longest-palindromic-substring)
给定一个字符串 `s`，找到 `s` 中最长的回文子串。你可以假设 `s` 的最大长度为 1000。

**示例 1:**
```
输入: "babad"
输出: "bab"
注意: "aba" 也是一个有效答案。
```
**示例 2:**
```
输入: "cbbd"
输出: "bb"
```
[回到顶部](#菜单)

---
## [#6 Z 字形变换](https://leetcode-cn.com/problems/zigzag-conversion)
比如输入字符串为 `"PAYPALISHIRING"` 行数为 3 时，排列如下：
```
P   A   H   N
A P L S I I G
Y   I   R
```
之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：`"PAHNAPLSIIGYIR"`。

请你实现这个将字符串进行指定行数变换的函数：
```c
string convert(string s, int numRows);
```
**示例 1:**
```
输入: s = "LEETCODEISHIRING", numRows = 3
输出: "LCIRETOESIIGEDHN"
```
**示例 2:**
```
输入: s = "LEETCODEISHIRING", numRows = 4
输出: "LDREOEIIECIHNTSG"
解释:

L     D     R
E   O E   I I
E C   I H   N
T     S     G
```
[回到顶部](#菜单)

---
## [#7 整数反转](https://leetcode-cn.com/problems/reverse-integer)
给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。

**示例 1:**
```
输入: 123
输出: 321
```
**示例 2:**
```
输入: -123
输出: -321
```
**示例 3:**
```
输入: 120
输出: 21
```
**注意:**
- 设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−2^(31),  2^(31) − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。

[回到顶部](#菜单)

---
## [#9 回文数](https://leetcode-cn.com/problems/palindrome-number)
判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。

**示例 1:**
```
输入: 121
输出: true
```
**示例 2:**
```
输入: -121
输出: false
解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。
```
**示例 3:**
```
输入: 10
输出: false
解释: 从右向左读, 为 01 。因此它不是一个回文数。
```
**进阶:**

你能不将整数转为字符串来解决这个问题吗？

[回到顶部](#菜单)

---
## [#13 罗马数字转整数](https://leetcode-cn.com/problems/roman-to-integer)
罗马数字包含以下七种字符: `I`， `V`， `X`， `L`，`C`，`D` 和 `M`。
```
字符          数值
I              1
V              5
X              10
L              50
C              100
D              500
M              1000
```
例如， 罗马数字 2 写做`II`，即为两个并列的 1。12 写做`XII`，即为`X`+`II`。 27 写做`XXVII`, 即为`XX`+`V`+`II`。

通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做`IIII`，而是`IV`。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为`IX`。这个特殊的规则只适用于以下六种情况：
- `I` 可以放在 `V` (5) 和 `X` (10) 的左边，来表示 4 和 9。
- `X` 可以放在 `L` (50) 和 `C` (100) 的左边，来表示 40 和 90。
- `C` 可以放在 `D` (500) 和 `M` (1000) 的左边，来表示 400 和 900。

给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。
**示例 1:**
```
输入: "III"
输出: 3
```
**示例 2:**
```
输入: "IV"
输出: 4
```
**示例 3:**
```
输入: "IX"
输出: 9
```
**示例 4:**
```
输入: "LVIII"
输出: 58
解释: L = 50, V= 5, III = 3.
```
**示例 5:**
```
输入: "MCMXCIV"
输出: 1994
解释: M = 1000, CM = 900, XC = 90, IV = 4.
```
[回到顶部](#菜单)

---
## [#14 最长公共前缀](https://leetcode-cn.com/problems/longest-common-prefix)
编写一个函数来查找字符串数组中的最长公共前缀。

如果不存在公共前缀，返回空字符串 `""`。

**示例 1:**
```
输入: ["flower","flow","flight"]
输出: "fl"
```
**示例 2:**
```
输入: ["dog","racecar","car"]
输出: ""
解释: 输入不存在公共前缀。
```
**说明:**
- 所有输入只包含小写字母 `a-z` 。

[回到顶部](#菜单)

---
## [#20 有效的括号](https://leetcode-cn.com/problems/valid-parentheses)
给定一个只包括 `'('`，`')'`，`'{'`，`'}'`，`'['`，`']'` 的字符串，判断字符串是否有效

有效字符串需满足：
  1. 左括号必须用相同类型的右括号闭合。
  2. 左括号必须以正确的顺序闭合。

注意空字符串可被认为是有效字符串。

**示例 1:**
```
输入: "()"
输出: true
```
**示例 2:**
```
输入: "()[]{}"
输出: true
```
**示例 3:**
```
输入: "(]"
输出: false
```
**示例 4:**
```
输入: "([)]"
输出: false
```
**示例 5:**
```
输入: "{[]}"
输出: true
```
[回到顶部](#菜单)

---
## [#21 合并两个有序链表](https://leetcode-cn.com/problems/merge-two-sorted-lists)
将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。

**示例:**
```
输入：1->2->4, 1->3->4
输出：1->1->2->3->4->4
```
[回到顶部](#菜单)

---
## [#26 删除排序数组中的重复项](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array)
给定一个排序数组，你需要在[原地](https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95)删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。

不要使用额外的数组空间，你必须在[原地](http://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95)**修改输入数组**并在使用 O(1) 额外空间的条件下完成。

**示例 1:**
```
给定数组 nums = [1,1,2],

函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。

你不需要考虑数组中超出新长度后面的元素。
```
**Example(示例) 2:**
```
给定 nums = [0,0,1,1,1,2,2,3,3,4],

函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。

你不需要考虑数组中超出新长度后面的元素。
```
**说明:**

为什么返回数值是整数，但输出的答案是数组呢?

请注意，输入数组是以“**引用**”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。

你可以想象内部操作如下:
```cpp
// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝
int len = removeElement(nums);

// 在函数里修改输入数组对于调用者是可见的
// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。
for (int i = 0; i < len; i++) {
    print(nums[i]);
}
```
[回到顶部](#菜单)

---
## [#27 移除元素](https://leetcode-cn.com/problems/remove-element)
给定一个数组 *nums* 和一个值 *val*，你需要[原地](http://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95)移除所有数值等于 *val* 的元素，返回移除后数组的新长度。

不要使用额外的数组空间，你必须在[原地](http://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95)**修改输入数组**并在使用 O(1) 额外空间的条件下完成。

**示例 1:**
```
给定 nums = [3,2,2,3], val = 3,

函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。

你不需要考虑数组中超出新长度后面的元素。
```
**示例 2:**
```
给定 nums = [0,1,2,2,3,0,4,2], val = 2,

函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。

注意这五个元素可为任意顺序。

你不需要考虑数组中超出新长度后面的元素。
```
**说明:**

为什么返回数值是整数，但输出的答案是数组呢?

请注意，输入数组是以“**引用**”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。

你可以想象内部操作如下:
```cpp
// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝
int len = removeDuplicates(nums);

// 在函数里修改输入数组对于调用者是可见的
// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。
for (int i = 0; i < len; i++) {
    print(nums[i]);
}
```
[回到顶部](#菜单)

---
## [#28 实现 strStr()](https://leetcode-cn.com/problems/implement-strstr)
实现 [strStr()](https://baike.baidu.com/item/strstr/811469) 函数。

给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回 **-1**。

**示例 1:**
```
输入: haystack = "hello", needle = "ll"
输出: 2
```
**示例 2:**
```
输入: haystack = "aaaaa", needle = "bba"
输出: -1
```
**说明:**

当 `needle` 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。

对于本题而言，当 `needle` 是空字符串时我们应当返回 0 。这与C语言的 [strstr()](https://baike.baidu.com/item/strstr/811469) 以及 Java的 [indexOf()](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html#indexOf(java.lang.String)) 定义相符。

[回到顶部](#菜单)

---
## [#35 搜索插入位置](https://leetcode-cn.com/problems/search-insert-position)
给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。

你可以假设数组中无重复元素。

**示例 1:**
```
输入: [1,3,5,6], 5
输出: 2
```
**示例 2:**
```
输入: [1,3,5,6], 2
输出: 1
```
**示例 3:**
```
输入: [1,3,5,6], 7
输出: 4
```
**示例 4:**
```
输入: [1,3,5,6], 0
输出: 0
```
[回到顶部](#菜单)

---
## [#38 外观数列](https://leetcode-cn.com/problems/count-and-say)
「外观数列」是一个整数序列，从数字 1 开始，序列中的每一项都是对前一项的描述。前五项如下：
```
1.      1
2.      11
3.      21
4.      1211
5.      111221
```
`1` 被读作  `"one 1"`  (`"一个一"`) , 即 `11`。

`11` 被读作 `"two 1s"` (`"两个一"`）, 即 `21`。)

`21` 被读作 `"one 2"`,  `"one 1"` （`"一个二"` ,  `"一个一"` , 即 `1211`。)

给定一个正整数 *n*（1 ≤ *n* ≤ 30），输出外观数列的第 *n* 项。

注意：整数序列中的每一项将表示为一个字符串。

**示例 1:**
```
输入: 1
输出: "1"
解释：这是一个基本样例。
```
**示例 2:**
```
输入: 4
输出: "1211"
解释：当 n = 3 时，序列是 "21"，其中我们有 "2" 和 "1" 两组，"2" 可以读作 "12"，也就是出现频次 = 1 而 值 = 2；类似 "1" 可以读作 "11"。所以答案是 "12" 和 "11" 组合在一起，也就是 "1211"。
```
[回到顶部](#菜单)

---
## [#49 字母异位词分组](https://leetcode-cn.com/problems/group-anagrams)
给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。

**示例:**
```
输入: ["eat", "tea", "tan", "ate", "nat", "bat"]
输出:
[
  ["ate","eat","tea"],
  ["nat","tan"],
  ["bat"]
]
```
**说明：**
- 所有输入均为小写字母。
- 不考虑答案输出的顺序。

[回到顶部](#菜单)

---
## [#53 最大子序和](https://leetcode-cn.com/problems/maximum-subarray)
给定一个整数数组 `nums` ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

**示例 :**
```
输入: [-2,1,-3,4,-1,2,1,-5,4],
输出: 6
解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。
```
**进阶:**

如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。

[回到顶部](#菜单)

---
## [#58 最后一个单词的长度](https://leetcode-cn.com/problems/length-of-last-word)
给定一个仅包含大小写字母和空格 `' '` 的字符串 `s`，返回其最后一个单词(如果字符串从左向右滚动显示，那么最后一个单词就是最后出现的单词。)的长度。

如果不存在最后一个单词，请返回 0 。

**说明:**

一个单词是指仅由字母组成、不包含任何空格的 **最大子字符串**。

**示例 :**
```
输入: "Hello World"
输出: 5
```
[回到顶部](#菜单)

---
## [#66 加一](https://leetcode-cn.com/problems/plus-one)
给定一个由 **整数** 组成的 **非空** 数组所表示的非负整数，在该数的基础上加一。

最高位数字存放在数组的首位， 数组中每个元素只存储一个数字。

你可以假设除了整数 0 之外，这个整数不会以零开头。

**示例 1:**
```
输入: [1,2,3]
输出: [1,2,4]
解释: 输入数组表示数字 123。
```
**示例 2:**
```
输入: [4,3,2,1]
输出: [4,3,2,2]
解释: 输入数组表示数字 4321。
```
[回到顶部](#菜单)

---
## [#67 二进制求和](https://leetcode-cn.com/problems/add-binary)
给定两个二进制字符串，返回他们的和（用二进制表示）。

输入为**非空**字符串且只包含数字 `1` 和 `0`。

**示例 1:**
```
输入: a = "11", b = "1"
输出: "100"
```
**示例 2:**
```
输入: a = "1010", b = "1011"
输出: "10101"
```
[回到顶部](#菜单)

---
## [#69 x 的平方根](https://leetcode-cn.com/problems/sqrtx)
实现 `int sqrt(int x)` 函数。

计算并返回 *x* 的平方根，其中 *x* 是非负整数。

由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。

**示例 1:**
```
输入: 4
输出: 2
```
**示例 2:**
```
输入: 8
输出: 2
说明: 8 的平方根是 2.82842...,
     由于返回类型是整数，小数部分将被舍去。
```
[回到顶部](#菜单)

---
## [#70 爬楼梯](https://leetcode-cn.com/problems/climbing-stairs)
假设你正在爬楼梯。需要 *n* 阶你才能到达楼顶。

每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

**注意:** 给定 *n* 是一个正整数。

**示例 1:**
```
输入： 2
输出： 2
解释： 有两种方法可以爬到楼顶。
1.  1 阶 + 1 阶
2.  2 阶
```
**示例 2:**
```
输入： 3
输出： 3
解释： 有三种方法可以爬到楼顶。
1.  1 阶 + 1 阶 + 1 阶
2.  1 阶 + 2 阶
3.  2 阶 + 1 阶
```
[回到顶部](#菜单)

---
## [#83 删除排序链表中的重复元素](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list)
给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。

**示例 1:**
```
输入: 1->1->2
输出: 1->2
```
**示例 2:**
```
输入: 1->1->2->3->3
输出: 1->2->3
```
[回到顶部](#菜单)

---
## [#88 合并两个有序数组](https://leetcode-cn.com/problems/merge-sorted-array)
给定两个有序整数数组 nums1 和 nums2，将 nums2 合并到 nums1 中，使得 num1 成为一个有序数组。

**说明:**
- 初始化 nums1 和 nums2 的元素数量分别为 m 和 n。
- 你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。

**示例:**
```
输入:
nums1 = [1,2,3,0,0,0], m = 3
nums2 = [2,5,6],       n = 3

输出: [1,2,2,3,5,6]
```
[回到顶部](#菜单)

---
## [#100 相同的树](https://leetcode-cn.com/problems/same-tree)
给定两个二叉树，编写一个函数来检验它们是否相同。

如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。

**示例 1:**
```
输入:       1         1
          / \       / \
         2   3     2   3

        [1,2,3],   [1,2,3]

输出: true
```
**示例 2:**
```
输入:      1          1
          /           \
         2             2

        [1,2],     [1,null,2]

输出: false
```
**示例 3:**
```
输入:       1         1
          / \       / \
         2   1     1   2

        [1,2,1],   [1,1,2]

输出: false
```
[回到顶部](#菜单)

---
## [#101 对称二叉树](https://leetcode-cn.com/problems/symmetric-tree)
给定一个二叉树，检查它是否是镜像对称的。

例如，二叉树 `[1,2,2,3,4,4,3]` 是对称的。
```
    1
   / \
  2   2
 / \ / \
3  4 4  3
```
但是下面这个 `[1,2,2,null,3,null,3]` 则不是镜像对称的:
```
    1
   / \
  2   2
   \   \
   3    3
```
**说明:**

如果你可以运用递归和迭代两种方法解决这个问题，会很加分。

[回到顶部](#菜单)

---
## [#104 二叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree)
给定一个二叉树，找出其最大深度。

二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。

**说明:** 叶子节点是指没有子节点的节点。

**示例 1:**

给定二叉树 `[3,9,20,null,null,15,7]`，
```
    3
   / \
  9  20
    /  \
   15   7
```
返回它的最大深度 3 。

[回到顶部](#菜单)

---
## [#107 二叉树的层次遍历 II](https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii)
给定一个二叉树，返回其节点值自底向上的层次遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）

例如：

给定二叉树 `[3,9,20,null,null,15,7]`,
```
    3
   / \
  9  20
    /  \
   15   7
```
返回其自底向上的层次遍历为：
```
[
  [15,7],
  [9,20],
  [3]
]
```
[回到顶部](#菜单)

---
## [#108 将有序数组转换为二叉搜索树](https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree)
将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。

本题中，一个高度平衡二叉树是指一个二叉树*每个节点* 的左右两个子树的高度差的绝对值不超过 1。

**示例:**
```
给定有序数组: [-10,-3,0,5,9],

一个可能的答案是：[0,-3,9,-10,null,5]，它可以表示下面这个高度平衡二叉搜索树：

      0
     / \
   -3   9
   /   /
 -10  5
```
[回到顶部](#菜单)

---
## [#110 平衡二叉树](https://leetcode-cn.com/problems/balanced-binary-tree)
给定一个二叉树，判断它是否是高度平衡的二叉树。

本题中，一棵高度平衡二叉树定义为：

> 一个二叉树*每个节点* 的左右两个子树的高度差的绝对值不超过1。

**示例 1:**

给定二叉树 `[3,9,20,null,null,15,7]`
```
    3
   / \
  9  20
    /  \
   15   7
```
返回 `true` 。

**示例 2:**

给定二叉树 `[1,2,2,3,3,null,null,4,4]`
```
       1
      / \
     2   2
    / \
   3   3
  / \
 4   4
```
返回 `false` 。

[回到顶部](#菜单)

---
## [#111 二叉树的最小深度](https://leetcode-cn.com/problems/minimum-depth-of-binary-tree)
给定一个二叉树，找出其最小深度。

最小深度是从根节点到最近叶子节点的最短路径上的节点数量。

**说明:** 叶子节点是指没有子节点的节点。

**示例:**

给定二叉树 `[3,9,20,null,null,15,7]`,
```
    3
   / \
  9  20
    /  \
   15   7
```
返回它的最小深度  2.

[回到顶部](#菜单)

---
## [#112 路径总和](https://leetcode-cn.com/problems/path-sum)
给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。

**说明:** 叶子节点是指没有子节点的节点。

**示例:**

给定如下二叉树，以及目标和 `sum = 22`，
```
              5
             / \
            4   8
           /   / \
          11  13  4
         /  \      \
        7    2      1
```
返回 `true`, 因为存在目标和为 22 的根节点到叶子节点的路径 `5->4->11->2`。

[回到顶部](#菜单)

---
## [#118 杨辉三角](https://leetcode-cn.com/problems/pascals-triangle)
给定一个非负整数 *numRows*，生成杨辉三角的前 *numRows* 行。

![](https://upload.wikimedia.org/wikipedia/commons/0/0d/PascalTriangleAnimated2.gif)

在杨辉三角中，每个数是它左上方和右上方的数的和。

**示例:**
```
输入: 5
输出:
[
     [1],
    [1,1],
   [1,2,1],
  [1,3,3,1],
 [1,4,6,4,1]
]
```
[回到顶部](#菜单)

---
## [#119 杨辉三角 II](https://leetcode-cn.com/problems/pascals-triangle-ii)
给定一个非负索引 *k*，其中 *k* ≤ 33，返回杨辉三角的第 *k* 行。

![](https://upload.wikimedia.org/wikipedia/commons/0/0d/PascalTriangleAnimated2.gif)

在杨辉三角中，每个数是它左上方和右上方的数的和。

**示例:**
```
输入: 3
输出: [1,3,3,1]
```
**进阶:**

你可以优化你的算法到 *O*(k) 空间复杂度吗？

[回到顶部](#菜单)

---
## [#121 买卖股票的最佳时机](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock)
给定一个数组，它的第 *i* 个元素是一支给定股票第 *i* 天的价格。

如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。

注意你不能在买入股票前卖出股票。

**示例 1:**
```
输入: [7,1,5,3,6,4]
输出: 5
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。
```
**示例 2:**
```
输入: [7,6,4,3,1]
输出: 0
解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。
```
[回到顶部](#菜单)

---
## [#122 买卖股票的最佳时机 II](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii)
给定一个数组，它的第 *i* 个元素是一支给定股票第 *i* 天的价格。

设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。

**注意:** 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

**示例 1:**
```
输入: [7,1,5,3,6,4]
输出: 7
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。
```
**示例 2:**
```
输入: [1,2,3,4,5]
输出: 4
解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。
     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。
```
**示例 3:**
```
输入: [7,6,4,3,1]
输出: 0
解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。
```
[回到顶部](#菜单)

---
## [#125 验证回文串](https://leetcode-cn.com/problems/valid-palindrome)
给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。

**说明:** 本题中，我们将空字符串定义为有效的回文串。

**示例 1:**
```
输入: "A man, a plan, a canal: Panama"
输出: true
```
**示例 2:**
```
输入: "race a car"
输出: false
```
[回到顶部](#菜单)

---
## [#136 只出现一次的数字](https://leetcode-cn.com/problems/single-number)
给定一个**非空**整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。

**说明:**

你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？

**示例 1:**
```
输入: [2,2,1]
输出: 1
```
**示例 2:**
```
输入: [4,1,2,1,2]
输出: 4
```
[回到顶部](#菜单)

---
## [#141 环形链表](https://leetcode-cn.com/problems/linked-list-cycle)
给定一个链表，判断链表中是否有环。

为了表示给定链表中的环，我们使用整数 `pos` 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 `pos` 是 `-1`，则在该链表中没有环。

**示例 1:**
```
输入：head = [3,2,0,-4], pos = 1
输出：true
解释：链表中有一个环，其尾部连接到第二个节点。
```
![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist.png)

**示例 2:**
```
输入：head = [1,2], pos = 0
输出：true
解释：链表中有一个环，其尾部连接到第一个节点。
```
![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test2.png)

**示例 3:**
```
输入：head = [1], pos = -1
输出：false
解释：链表中没有环。
```
![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test3.png)

**进阶:**

你能用 *O(1)*（即，常量）内存解决此问题吗？

[回到顶部](#菜单)

---
## [#155 最小栈](https://leetcode-cn.com/problems/min-stack)
设计一个支持 push，pop，top 操作，并能在常数时间内检索到最小元素的栈。
- push(x) -- 将元素 x 推入栈中。
- pop() -- 删除栈顶的元素。
- top() -- 获取栈顶元素。
- getMin() -- 检索栈中的最小元素。

**示例:**
```
MinStack minStack = new MinStack();
minStack.push(-2);
minStack.push(0);
minStack.push(-3);
minStack.getMin();   --> 返回 -3.
minStack.pop();
minStack.top();      --> 返回 0.
minStack.getMin();   --> 返回 -2.
```
[回到顶部](#菜单)

---
## [#160 相交链表](https://leetcode-cn.com/problems/intersection-of-two-linked-lists)
编写一个程序，找到两个单链表相交的起始节点。

如下面的两个链表：

![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png)

在节点 c1 开始相交。

**示例 1:**
![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_1.png)
```
输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3
输出：Reference of the node with value = 8
输入解释：相交节点的值为 8 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。
```
**示例 2:**
![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_2.png)
```
输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1
输出：Reference of the node with value = 2
输入解释：相交节点的值为 2 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。
```
**示例 3:**
![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_3.png)
```
输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2
输出：null
输入解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。
解释：这两个链表不相交，因此返回 null。
```
**注意:**
- 如果两个链表没有交点，返回 `null`.
- 在返回结果后，两个链表仍须保持原有的结构。
- 可假定整个链表结构中没有循环。
- 程序尽量满足 O(*n*) 时间复杂度，且仅用 O(*1*) 内存。

[回到顶部](#菜单)

---
## [#167 两数之和 II - 输入有序数组](https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted)
给定一个已按照 ***升序排列*** 的有序数组，找到两个数使得它们相加之和等于目标数。

函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2。

**说明:**
- 返回的下标值（index1 和 index2）不是从零开始的。
- 你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。

**示例:**
```
输入: numbers = [2, 7, 11, 15], target = 9
输出: [1,2]
解释: 2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。
```
[回到顶部](#菜单)

---
## [#168 Excel表列名称](https://leetcode-cn.com/problems/excel-sheet-column-title)
给定一个正整数，返回它在 Excel 表中相对应的列名称。

例如，
```
    1 -> A
    2 -> B
    3 -> C
    ...
    26 -> Z
    27 -> AA
    28 -> AB 
    ...
```
**示例 1:**
```
输入: 1
输出: "A"
```
**示例 2:**
```
输入: 28
输出: "AB"
```
**示例 3:**
```
输入: 701
输出: "ZY"
```
[回到顶部](#菜单)

---
## [#169 多数元素](https://leetcode-cn.com/problems/majority-element)
给定一个大小为 *n* 的数组，找到其中的多数元素。多数元素是指在数组中出现次数**大于** `⌊ n/2 ⌋` 的元素。

你可以假设数组是非空的，并且给定的数组总是存在多数元素。

**示例 1:**
```
输入: [3,2,3]
输出: 3
```
**示例 2:**
```
输入: [2,2,1,1,1,2,2]
输出: 2
```
[回到顶部](#菜单)

---
## [#171 Excel表列序号](https://leetcode-cn.com/problems/basic-calculator)
给定一个Excel表格中的列名称，返回其相应的列序号。

例如，
```
    A -> 1
    B -> 2
    C -> 3
    ...
    Z -> 26
    AA -> 27
    AB -> 28 
    ...
```
**示例 1:**
```
输入: "A"
输出: 1
```
**示例 2:**
```
输入: "AB"
输出: 28
```
**示例 3:**
```
输入: "ZY"
输出: 701
```
[回到顶部](#菜单)

---
## [#172 阶乘后的零](https://leetcode-cn.com/problems/factorial-trailing-zeroes)
给定一个整数 *n*，返回 *n*! 结果尾数中零的数量。

**示例 1:**
```
输入: 3
输出: 0
解释: 3! = 6, 尾数中没有零。
```
**示例 2:**
```
输入: 5
输出: 1
解释: 5! = 120, 尾数中有 1 个零.
```
[回到顶部](#菜单)

---
## [#175 组合两个表](https://leetcode-cn.com/problems/combine-two-tables)
表1: `Person`
```
+-------------+---------+
| 列名         | 类型     |
+-------------+---------+
| PersonId    | int     |
| FirstName   | varchar |
| LastName    | varchar |
+-------------+---------+
PersonId 是上表主键
```
表2: `Address`
```
+-------------+---------+
| 列名         | 类型    |
+-------------+---------+
| AddressId   | int     |
| PersonId    | int     |
| City        | varchar |
| State       | varchar |
+-------------+---------+
AddressId 是上表主键
```
编写一个 SQL 查询，满足条件：无论 person 是否有地址信息，都需要基于上述两表提供 person 的以下信息：
```
FirstName, LastName, City, State
```
[回到顶部](#菜单)

---
## [#176 第二高的薪水](https://leetcode-cn.com/problems/second-highest-salary)
编写一个 SQL 查询，获取 `Employee` 表中第二高的薪水（Salary） 。
```
+----+--------+
| Id | Salary |
+----+--------+
| 1  | 100    |
| 2  | 200    |
| 3  | 300    |
+----+--------+
```
例如上述 `Employee` 表，SQL查询应该返回 `200` 作为第二高的薪水。如果不存在第二高的薪水，那么查询应返回 `null。`
```
+---------------------+
| SecondHighestSalary |
+---------------------+
| 200                 |
+---------------------+
```
[回到顶部](#菜单)

---
## [#181 超过经理收入的员工](https://leetcode-cn.com/problems/employees-earning-more-than-their-managers)
`Employee` 表包含所有员工，他们的经理也属于员工。每个员工都有一个 Id，此外还有一列对应员工的经理的 Id。
```+----+-------+--------+-----------+
| Id | Name  | Salary | ManagerId |
+----+-------+--------+-----------+
| 1  | Joe   | 70000  | 3         |
| 2  | Henry | 80000  | 4         |
| 3  | Sam   | 60000  | NULL      |
| 4  | Max   | 90000  | NULL      |
+----+-------+--------+-----------+
```
给定 `Employee` 表，编写一个 SQL 查询，该查询可以获取收入超过他们经理的员工的姓名。在上面的表格中，Joe 是唯一一个收入超过他的经理的员工。
```
+----------+
| Employee |
+----------+
| Joe      |
+----------+
```
[回到顶部](#菜单)

---
## [#182 查找重复的电子邮箱](https://leetcode-cn.com/problems/duplicate-emails)
编写一个 SQL 查询，查找 `Person` 表中所有重复的电子邮箱。

**示例:**
```
+----+---------+
| Id | Email   |
+----+---------+
| 1  | a@b.com |
| 2  | c@d.com |
| 3  | a@b.com |
+----+---------+
```
根据以上输入，你的查询应返回以下结果：
```
+---------+
| Email   |
+---------+
| a@b.com |
+---------+
```
**说明:**所有电子邮箱都是小写字母。

[回到顶部](#菜单)

---
## [#183 从不订购的客户](https://leetcode-cn.com/problems/basic-calculator)
某网站包含两个表，`Customers` 表和 `Orders` 表。编写一个 SQL 查询，找出所有从不订购任何东西的客户。

`Customers` 表：
```
+----+-------+
| Id | Name  |
+----+-------+
| 1  | Joe   |
| 2  | Henry |
| 3  | Sam   |
| 4  | Max   |
+----+-------+
```
`Orders` 表：
```
+----+------------+
| Id | CustomerId |
+----+------------+
| 1  | 3          |
| 2  | 1          |
+----+------------+
```
例如给定上述表格，你的查询应返回：
```
+-----------+
| Customers |
+-----------+
| Henry     |
| Max       |
+-----------+
```
[回到顶部](#菜单)

---
## [#189 旋转数组](https://leetcode-cn.com/problems/rotate-array)
给定一个数组，将数组中的元素向右移动 *k* 个位置，其中 *k* 是非负数。

**示例 1:**
```
输入: [1,2,3,4,5,6,7] 和 k = 3
输出: [5,6,7,1,2,3,4]
解释:
向右旋转 1 步: [7,1,2,3,4,5,6]
向右旋转 2 步: [6,7,1,2,3,4,5]
向右旋转 3 步: [5,6,7,1,2,3,4]
```
**示例 2:**
```
输入: [-1,-100,3,99] 和 k = 2
输出: [3,99,-1,-100]
解释: 
向右旋转 1 步: [99,-1,-100,3]
向右旋转 2 步: [3,99,-1,-100]
```
**说明:**
- 尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。
- 要求使用空间复杂度为 O(1) 的 **原地** 算法。

[回到顶部](#菜单)

---
## [#190 颠倒二进制位](https://leetcode-cn.com/problems/reverse-bits)
颠倒给定的 32 位无符号整数的二进制位。

**示例 1:**
```
输入: 00000010100101000001111010011100
输出: 00111001011110000010100101000000
解释: 输入的二进制串 00000010100101000001111010011100 表示无符号整数 43261596，
      因此返回 964176192，其二进制表示形式为 00111001011110000010100101000000。
```
**示例 2:**
```
输入：11111111111111111111111111111101
输出：10111111111111111111111111111111
解释：输入的二进制串 11111111111111111111111111111101 表示无符号整数 4294967293，
      因此返回 3221225471 其二进制表示形式为 10101111110010110010011101101001。
```
**提示:**
- 请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。
- 在 Java 中，编译器使用[二进制补码](https://baike.baidu.com/item/%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%A1%A5%E7%A0%81/5295284)记法来表示有符号整数。因此，在上面的 **示例 2** 中，输入表示有符号整数 `-3`，输出表示有符号整数 `-1073741825`。

**进阶:**

如果多次调用这个函数，你将如何优化你的算法？

[回到顶部](#菜单)

---
## [#191 位1的个数](https://leetcode-cn.com/problems/number-of-1-bits)
编写一个函数，输入是一个无符号整数，返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为[汉明重量](https://baike.baidu.com/item/%E6%B1%89%E6%98%8E%E9%87%8D%E9%87%8F）。

**示例 1:**
```
输入：00000000000000000000000000001011
输出：3
解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 '1'。
```
**示例 2:**
```
输入：00000000000000000000000010000000
输出：1
解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 '1'。
```
**示例 3:**
```
输入：11111111111111111111111111111101
输出：31
解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 '1'。
```
**提示:**
- 请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。
- 在 Java 中，编译器使用[二进制补码](https://baike.baidu.com/item/%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%A1%A5%E7%A0%81/5295284)记法来表示有符号整数。因此，在上面的 **示例 3** 中，输入表示有符号整数 `-3`。

**进阶:**

如果多次调用这个函数，你将如何优化你的算法？

[回到顶部](#菜单)

---
## [#193 有效电话号码](https://leetcode-cn.com/problems/valid-phone-numbers)
给定一个包含电话号码列表（一行一个电话号码）的文本文件 `file.txt`，写一个 bash 脚本输出所有有效的电话号码。

你可以假设一个有效的电话号码必须满足以下两种格式： (xxx) xxx-xxxx 或 xxx-xxx-xxxx。（x 表示一个数字）

你也可以假设每行前后没有多余的空格字符。

**示例:**

假设 `file.txt` 内容如下：
```
987-123-4567
123 456 7890
(123) 456-7890
```
你的脚本应当输出下列有效的电话号码：
```
987-123-4567
(123) 456-7890
```
[回到顶部](#菜单)

---
## [#224 基本计算器](https://leetcode-cn.com/problems/basic-calculator)
实现一个基本的计算器来计算一个简单的字符串表达式的值。

字符串表达式可以包含左括号 `(` ，右括号 `)`，加号 `+` ，减号 `-`，**非负** 整数和空格`  `。

**示例 1:**
```
输入: "1 + 1"
输出: 2
```
**示例 2:**
```
输入: " 2-1 + 2 "
输出: 3
```
**示例 3:**
```
输入: "(1+(4+5+2)-3)+(6+8)"
输出: 23
```
**说明:**
- 你可以假设所给定的表达式都是有效的。
- 请 **不要** 使用内置的库函数 `eval`。

[回到顶部](#菜单)

---
## [#300 最长上升子序列](https://leetcode-cn.com/problems/longest-increasing-subsequence)
给定一个无序的整数数组，找到其中最长上升子序列的长度。

**示例:**
```
输入: [10,9,2,5,3,7,101,18]
输出: 4
解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。
```
**说明:**
- 可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。
- 你算法的时间复杂度应该为 O(n2) 。

**进阶**: 你能将算法的时间复杂度降低到 O(n log n) 吗?

[回到顶部](#菜单)

---
## [#434 字符串中的单词数](https://leetcode-cn.com/problems/number-of-segments-in-a-string)
统计字符串中的单词个数，这里的单词指的是连续的不是空格的字符。

请注意，你可以假定字符串里不包括任何不可打印的字符。

**示例:**
```
输入: "Hello, my name is John"
输出: 5
```
[回到顶部](#菜单)

---
## [#467 环绕字符串中唯一的子字符串](https://leetcode-cn.com/problems/unique-substrings-in-wraparound-string)
把字符串 `s` 看作是“abcdefghijklmnopqrstuvwxyz”的无限环绕字符串，所以 `s` 看起来是这样的："...zabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcd....".

现在我们有了另一个字符串 `p` 。你需要的是找出 `s` 中有多少个唯一的 `p` 的非空子串，尤其是当你的输入是字符串 `p` ，你需要输出字符串 `s` 中 `p` 的不同的非空子串的数目。

注意: `p` 仅由小写的英文字母组成，p 的大小可能超过 10000。

**示例 1:**
```
输入: "a"
输出: 1
解释: 字符串 S 中只有一个"a"子字符。
```
**示例 2:**
```
输入: "cac"
输出: 2
解释: 字符串 S 中的字符串“cac”只有两个子串“a”、“c”。.
```
**示例 3:**
```
输入: "zab"
输出: 6
解释: 在字符串 S 中有六个子串“z”、“a”、“b”、“za”、“ab”、“zab”。.
```
[回到顶部](#菜单)

---
## [#747 至少是其他数字两倍的最大数](https://leetcode-cn.com/problems/largest-number-at-least-twice-of-others)
在一个给定的数组`nums`中，总是存在一个最大元素 。

查找数组中的最大元素是否至少是数组中每个其他数字的两倍。

如果是，则返回最大元素的索引，否则返回-1。

**示例 1:**
```
输入: nums = [3, 6, 1, 0]
输出: 1
解释: 6是最大的整数, 对于数组中的其他整数,
6大于数组中其他元素的两倍。6的索引是1, 所以我们返回1.
```
**示例 2:**
```
输入: nums = [1, 2, 3, 4]
输出: -1
解释: 4没有超过3的两倍大, 所以我们返回 -1.
```
**提示:**
  1.`nums` 的长度范围在`[1, 50]`.
  2.每个 `nums[i]` 的整数范围在 `[0, 99]`.

[回到顶部](#菜单)

---
## [#869 重新排序得到 2 的幂](https://leetcode-cn.com/problems/reordered-power-of-2)
从正整数 `N` 开始，我们按任何顺序（包括原始顺序）将数字重新排序，注意其前导数字不能为零。

如果我们可以通过上述方式得到 2 的幂，返回 `true`；否则，返回 `false`。

**Example(示例) 1:**
```
输入: 1
输出: true
```
**示例 2:**
```
输入: 10
输出: false
```
**示例 3:**
```
输入: 16
输出: true
```
**示例 4:**
```
输入: 24
输出: false
```
**示例 5:**
```
输入: 46
输出: true
```
**提示:**
  1. `1 <= N <= 10^9`

[回到顶部](#菜单)

---
## [#992 K 个不同整数的子数组](https://leetcode-cn.com/problems/subarrays-with-k-different-integers)
给定一个正整数数组 `A`，如果 `A` 的某个子数组中不同整数的个数恰好为 `K`，则称 `A` 的这个连续、不一定独立的子数组为好子数组。

(例如，`[1,2,3,1,2]` 中有 `3` 个不同的整数：`1`，`2`，以及 `3`。)

返回 `A` 中好子数组的数目。

**示例 1:**
```
输出：A = [1,2,1,2,3], K = 2
输入：7
解释：恰好由 2 个不同整数组成的子数组：[1,2], [2,1], [1,2], [2,3], [1,2,1], [2,1,2], [1,2,1,2].
```
**示例 2:**
```
输入：A = [1,2,1,3,4], K = 3
输出：3
解释：恰好由 3 个不同整数组成的子数组：[1,2,1,3], [2,1,3], [1,3,4].
```
**提示:**
  1. `1 <= A.length <= 20000`
  2. `1 <= A[i] <= A.length`
  3. `1 <= K <= A.length`

[回到顶部](#菜单)

---

来源：力扣（LeetCode）

链接：https://leetcode-cn.com

著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。