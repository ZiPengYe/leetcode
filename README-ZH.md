# [菜单](https://leetcode-cn.com/problemset/all/)
- [x] [#1 两数之和](#1-两数之和)
- [x] [#2 两数相加](#2-两数相加)
- [x] [#3 无重复字符的最长子串](#3-无重复字符的最长子串)
- [x] [#4 寻找两个有序数组的中位数](#4-寻找两个有序数组的中位数)
- [x] [#5 最长回文子串](#5-最长回文子串)
- [x] [#6 Z 字形变换](#6-z-字形变换)
- [x] [#7 整数反转](#7-整数反转)
- [x] [#9 回文数](#9-回文数)
- [x] [#13 罗马数字转整数](#13-罗马数字转整数)
- [x] [#14 最长公共前缀](#14-最长公共前缀)
- [x] [#17 电话号码的字母组合](#17-电话号码的字母组合)
- [x] [#20 有效的括号](#20-有效的括号)
- [x] [#21 合并两个有序链表](#21-合并两个有序链表)
- [x] [#26 删除排序数组中的重复项](#26-删除排序数组中的重复项)
- [x] [#27 移除元素](#27-移除元素)
- [x] [#28 实现 strStr()](#28-实现-strstr)
- [x] [#33 搜索旋转排序数组](#33-搜索旋转排序数组)
- [x] [#35 搜索插入位置](#35-搜索插入位置)
- [x] [#38 外观数列](#38-外观数列)
- [x] [#49 字母异位词分组](#53-字母异位词分组)
- [x] [#53 最大子序和](#53-最大子序和)
- [x] [#55 跳跃游戏](#55-跳跃游戏)
- [x] [#58 最后一个单词的长度](#58-最后一个单词的长度)
- [x] [#64 最小路径和](#64-最小路径和)
- [x] [#66 加一](#66-加一)
- [x] [#67 二进制求和](#67-二进制求和)
- [x] [#69 x 的平方根](#69-x-的平方根)
- [x] [#70 爬楼梯](#70-爬楼梯)
- [x] [#83 删除排序链表中的重复元素](#83-删除排序链表中的重复元素)
- [x] [#88 合并两个有序数组](#88-合并两个有序数组)
- [x] [#100 相同的树](#100-相同的树)
- [x] [#101 对称二叉树](#101-对称二叉树)
- [x] [#104 二叉树的最大深度](#104-二叉树的最大深度)
- [x] [#107 二叉树的层次遍历 II](#107-二叉树的层次遍历-ii)
- [x] [#108 将有序数组转换为二叉搜索树](#108-将有序数组转换为二叉搜索树)
- [x] [#110 平衡二叉树](#110-平衡二叉树)
- [x] [#111 二叉树的最小深度](#111-二叉树的最小深度)
- [x] [#112 路径总和](#112-路径总和)
- [x] [#118 杨辉三角](#118-杨辉三角)
- [x] [#119 杨辉三角 II](#119-杨辉三角-ii)
- [x] [#121 买卖股票的最佳时机](#121-买卖股票的最佳时机)
- [x] [#122 买卖股票的最佳时机 II](#122-买卖股票的最佳时机-ii)
- [x] [#124 二叉树中的最大路径和](#124-二叉树中的最大路径和)
- [x] [#125 验证回文串](#125-验证回文串)
- [x] [#136 只出现一次的数字](#136-只出现一次的数字)
- [x] [#141 环形链表](#141-环形链表)
- [x] [#146 LRU缓存机制](#146-LRU缓存机制)
- [x] [#153 寻找旋转排序数组中的最小值](#153-寻找旋转排序数组中的最小值)
- [x] [#155 最小栈](#155-最小栈)
- [x] [#160 相交链表](#160-相交链表)
- [x] [#167 两数之和 II - 输入有序数组](#167-两数之和-ii-输入有序数组)
- [x] [#168 Excel表列名称](#168-excel表列名称)
- [x] [#169 多数元素](#169-多数元素)
- [x] [#171 Excel表列序号](#171-excel表列序号)
- [x] [#172 阶乘后的零](#172-阶乘后的零)
- [x] [#175 组合两个表](#175-组合两个表)
- [x] [#176 第二高的薪水](#176-第二高的薪水)
- [x] [#181 超过经理收入的员工](#181-超过经理收入的员工)
- [x] [#182 查找重复的电子邮箱](#182-查找重复的电子邮箱)
- [x] [#183 从不订购的客户](#183-从不订购的客户)
- [x] [#189 旋转数组](#189-旋转数组)
- [x] [#190 颠倒二进制位](#190-颠倒二进制位)
- [x] [#191 位1的个数](#191-位1的个数)
- [x] [#193 有效电话号码](#193-有效电话号码)
- [x] [#195 第十行](#195-第十行)
- [x] [#196 删除重复的电子邮箱](#196-删除重复的电子邮箱)
- [x] [#197 上升的温度](#197-上升的温度)
- [x] [#198 打家劫舍](#198-打家劫舍)
- [x] [#200 岛屿数量](#200-岛屿数量)
- [x] [#201 数字范围按位与](#201-数字范围按位与)
- [x] [#202 快乐数](#202-快乐数)
- [x] [#203 移除链表元素](#203-移除链表元素)
- [x] [#204 计数质数](#204-计数质数)
- [x] [#205 同构字符串](#205-同构字符串)
- [x] [#206 反转链表](#206-反转链表)
- [x] [#208 实现 Trie (前缀树)](#208-实现-trie-前缀树)
- [x] [#217 存在重复元素](#217-存在重复元素)
- [x] [#219 存在重复元素 II](#219-存在重复元素-ii)
- [x] [#221 最大正方形](#221-最大正方形)
- [x] [#224 基本计算器](#224-基本计算器)
- [x] [#225 用队列实现栈](#225-用队列实现栈)
- [x] [#226 翻转二叉树](#226-翻转二叉树)
- [x] [#231 2的幂](#231-2的幂)
- [x] [#232 用栈实现队列](#232-用栈实现队列)
- [x] [#234 回文链表](#234-回文链表)
- [x] [#235 二叉搜索树的最近公共祖先](#235-二叉搜索树的最近公共祖先)
- [x] [#237 删除链表中的节点](#237-删除链表中的节点)
- [x] [#238 除自身以外数组的乘积](#238-除自身以外数组的乘积)
- [x] [#242 有效的字母异位词](#242-有效的字母异位词)
- [x] [#257 二叉树的所有路径](#257-二叉树的所有路径)
- [x] [#258 各位相加](#258-各位相加)
- [x] [#263 丑数](#263-丑数)
- [x] [#268 丢失的数字](#268-丢失的数字)
- [x] [#278 第一个错误的版本](#278-第一个错误的版本)
- [x] [#283 移动零](#283-移动零)
- [x] [#290 单词规律](#290-单词规律)
- [x] [#292 Nim 游戏](#292-nim-游戏)
- [x] [#300 最长上升子序列](#300-最长上升子序列)
- [x] [#322 零钱兑换](#322-零钱兑换)
- [x] [#328 奇偶链表](#328-奇偶链表)
- [x] [#354 俄罗斯套娃信封问题](#354-俄罗斯套娃信封问题)
- [x] [#367 有效的完全平方数](#367-有效的完全平方数)
- [x] [#376 摆动序列](#376-摆动序列)
- [x] [#383 赎金信](#383-赎金信)
- [x] [#387 字符串中的第一个唯一字符](#387-字符串中的第一个唯一字符)
- [x] [#402 移掉K位数字](#402-移掉k位数字)
- [x] [#417 太平洋大西洋水流问题](#417-太平洋大西洋水流问题)
- [x] [#423 从英文中重建数字](#423-从英文中重建数字)
- [x] [#434 字符串中的单词数](#434-字符串中的单词数)
- [x] [#438 找到字符串中所有字母异位词](#438-找到字符串中所有字母异位词)
- [x] [#467 环绕字符串中唯一的子字符串](#467-环绕字符串中唯一的子字符串)
- [x] [#474 一和零](#474-一和零)
- [x] [#476 数字的补数](#476-数字的补数)
- [x] [#478 在圆内随机生成点](#478-在圆内随机生成点)
- [x] [#506 相对名次](#506-相对名次)
- [x] [#535 TinyURL 的加密与解密](#535-tinyurl-的加密与解密)
- [x] [#540 有序数组中的单一元素](#540-有序数组中的单一元素)
- [x] [#547 省份数量](#547-省份数量)
- [x] [#560 和为K的子数组](#560-和为K的子数组)
- [x] [#567 字符串的排列](#567-字符串的排列)
- [x] [#575 分糖果](#575-分糖果)
- [x] [#645 错误的集合](#645-错误的集合)
- [x] [#678 有效的括号字符串](#678-有效的括号字符串)
- [x] [#714 买卖股票的最佳时机含手续费](#714-买卖股票的最佳时机含手续费)
- [x] [#720 词典中最长的单词](#720-词典中最长的单词)
- [x] [#733 图像渲染](#733-图像渲染)
- [x] [#747 至少是其他数字两倍的最大数](#747-至少是其他数字两倍的最大数)
- [x] [#771 宝石与石头](#771-宝石与石头)
- [x] [#781 森林中的兔子](#781-森林中的兔子)
- [x] [#823 带因子的二叉树](#823-带因子的二叉树)
- [x] [#844 比较含退格的字符串](#844-比较含退格的字符串)
- [x] [#851 喧闹和富有](#851-喧闹和富有)
- [x] [#869 重新排序得到 2 的幂](#869-重新排序得到-2-的幂)
- [x] [#870 优势洗牌](#870-优势洗牌)
- [x] [#876 链表的中间结点](#876-链表的中间结点)
- [x] [#916 单词子集](#916-单词子集)
- [x] [#918 环形子数组的最大和](#918-环形子数组的最大和)
- [x] [#971 翻转二叉树以匹配先序遍历](#971-翻转二叉树以匹配先序遍历)
- [x] [#992 K 个不同整数的子数组](#992-k-个不同整数的子数组)
- [x] [#993 二叉树的堂兄弟节点](#993-二叉树的堂兄弟节点)
- [x] [#997 找到小镇的法官](#997-找到小镇的法官)
- [x] [#1008 先序遍历构造二叉树](#1008-先序遍历构造二叉树)
- [x] [#1022 从根到叶的二进制数之和](#1022-从根到叶的二进制数之和)
- [x] [#1046 最后一块石头的重量](#1046-最后一块石头的重量)
- [x] [#1143 最长公共子序列](#1143-最长公共子序列)
- [x] [#1147 段式回文](#1147-段式回文)
- [x] [#1232 缀点成线](#1232-缀点成线)
- [x] [#1302 层数最深叶子节点的和](#1302-层数最深叶子节点的和)
- [x] [#1306 跳跃游戏 III](#1306-跳跃游戏-iii)
- [x] [#1337 矩阵中战斗力最弱的 K 行](#1337-矩阵中战斗力最弱的-k-行)
- [x] [#1695 删除子数组的最大得分](#1695-删除子数组的最大得分)
- [x] [#1704 判断字符串的两半是否相似](#1704-判断字符串的两半是否相似)
- [x] [#1721 交换链表中的节点](#1721-交换链表中的节点)
- [x] [#1732 找到最高海拔](#1732-找到最高海拔)
---
## [#1 两数之和](https://leetcode-cn.com/problems/two-sum)
给定一个整数数组 `nums` 和一个目标值 `target`，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。

你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。

**示例:**
```
给定 nums = [2, 7, 11, 15], target = 9

因为 nums[0] + nums[1] = 2 + 7 = 9
所以返回 [0, 1]
```
[回到顶部](#菜单)

---
## [#2 两数相加](https://leetcode-cn.com/problems/add-two-numbers)
给出两个 **非空** 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 **逆序** 的方式存储的，并且它们的每个节点只能存储 一位 数字。

如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。

您可以假设除了数字 0 之外，这两个数都不会以 0 开头。

**示例:**
```
输入：(2 -> 4 -> 3) + (5 -> 6 -> 4)
输出：7 -> 0 -> 8
原因：342 + 465 = 807
```
[回到顶部](#菜单)

---
## [#3 无重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters)
给定一个字符串，请你找出其中不含有重复字符的 **最长子串** 的长度。

**示例 1:**
```
输入: "abcabcbb"
输出: 3
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
```
**示例 2:**
```
输入: "bbbbb"
输出: 1
解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。
```
**示例 3:**
```
输入: "pwwkew"
输出: 3
解释: 因为无重复字符的最长子串是"wke"，所以其长度为 3。
     请注意，你的答案必须是 子串 的长度，"pwke"是一个子序列，不是子串。
```
[回到顶部](#菜单)

---
## [#4 寻找两个有序数组的中位数](https://leetcode-cn.com/problems/median-of-two-sorted-arrays)
给定两个大小为 m 和 n 的有序数组 `nums1` 和 `nums2`。

请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。

你可以假设 `nums1` 和 `nums2` 不会同时为空。

**示例 1:**
```
nums1 = [1, 3]
nums2 = [2]

则中位数是 2.0
```
**示例 2:**
```
nums1 = [1, 2]
nums2 = [3, 4]

则中位数是 (2 + 3)/2 = 2.5
```
[回到顶部](#菜单)

---
## [#5 最长回文子串](https://leetcode-cn.com/problems/longest-palindromic-substring)
给定一个字符串 `s`，找到 `s` 中最长的回文子串。你可以假设 `s` 的最大长度为 1000。

**示例 1:**
```
输入: "babad"
输出: "bab"
注意: "aba" 也是一个有效答案。
```
**示例 2:**
```
输入: "cbbd"
输出: "bb"
```
[回到顶部](#菜单)

---
## [#6 Z 字形变换](https://leetcode-cn.com/problems/zigzag-conversion)
比如输入字符串为 `"PAYPALISHIRING"` 行数为 3 时，排列如下：
```
P   A   H   N
A P L S I I G
Y   I   R
```
之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：`"PAHNAPLSIIGYIR"`。

请你实现这个将字符串进行指定行数变换的函数：
```c
string convert(string s, int numRows);
```
**示例 1:**
```
输入: s = "LEETCODEISHIRING", numRows = 3
输出: "LCIRETOESIIGEDHN"
```
**示例 2:**
```
输入: s = "LEETCODEISHIRING", numRows = 4
输出: "LDREOEIIECIHNTSG"
解释:

L     D     R
E   O E   I I
E C   I H   N
T     S     G
```
[回到顶部](#菜单)

---
## [#7 整数反转](https://leetcode-cn.com/problems/reverse-integer)
给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。

**示例 1:**
```
输入: 123
输出: 321
```
**示例 2:**
```
输入: -123
输出: -321
```
**示例 3:**
```
输入: 120
输出: 21
```
**注意:**
- 设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−2^(31),  2^(31) − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。

[回到顶部](#菜单)

---
## [#9 回文数](https://leetcode-cn.com/problems/palindrome-number)
判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。

**示例 1:**
```
输入: 121
输出: true
```
**示例 2:**
```
输入: -121
输出: false
解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。
```
**示例 3:**
```
输入: 10
输出: false
解释: 从右向左读, 为 01 。因此它不是一个回文数。
```
**进阶:**

你能不将整数转为字符串来解决这个问题吗？

[回到顶部](#菜单)

---
## [#13 罗马数字转整数](https://leetcode-cn.com/problems/roman-to-integer)
罗马数字包含以下七种字符: `I`， `V`， `X`， `L`，`C`，`D` 和 `M`。
```
字符          数值
I              1
V              5
X              10
L              50
C              100
D              500
M              1000
```
例如， 罗马数字 2 写做`II`，即为两个并列的 1。12 写做`XII`，即为`X`+`II`。 27 写做`XXVII`, 即为`XX`+`V`+`II`。

通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做`IIII`，而是`IV`。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为`IX`。这个特殊的规则只适用于以下六种情况：
- `I` 可以放在 `V` (5) 和 `X` (10) 的左边，来表示 4 和 9。
- `X` 可以放在 `L` (50) 和 `C` (100) 的左边，来表示 40 和 90。
- `C` 可以放在 `D` (500) 和 `M` (1000) 的左边，来表示 400 和 900。

给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。
**示例 1:**
```
输入: "III"
输出: 3
```
**示例 2:**
```
输入: "IV"
输出: 4
```
**示例 3:**
```
输入: "IX"
输出: 9
```
**示例 4:**
```
输入: "LVIII"
输出: 58
解释: L = 50, V= 5, III = 3.
```
**示例 5:**
```
输入: "MCMXCIV"
输出: 1994
解释: M = 1000, CM = 900, XC = 90, IV = 4.
```
[回到顶部](#菜单)

---
## [#14 最长公共前缀](https://leetcode-cn.com/problems/longest-common-prefix)
编写一个函数来查找字符串数组中的最长公共前缀。

如果不存在公共前缀，返回空字符串 `""`。

**示例 1:**
```
输入: ["flower","flow","flight"]
输出: "fl"
```
**示例 2:**
```
输入: ["dog","racecar","car"]
输出: ""
解释: 输入不存在公共前缀。
```
**说明:**
- 所有输入只包含小写字母 `a-z` 。

[回到顶部](#菜单)

---
## [#17 电话号码的字母组合](https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number)
给定一个仅包含数字 `2-9` 的字符串，返回所有它能表示的字母组合。答案可以按 **任意顺序** 返回。

给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。

![](https://assets.leetcode-cn.com/aliyun-lc-upload/original_images/17_telephone_keypad.png)

**示例 1:**
```
输入：digits = "23"
输出：["ad","ae","af","bd","be","bf","cd","ce","cf"]
```
**示例 2:**
```
输入：digits = ""
输出：[]
```
**示例 3:**
```
输入：digits = "2"
输出：["a","b","c"]
```
**提示:**
  - `0 <= digits.length <= 4`
  - `digits[i]` 是范围 `['2', '9']` 的一个数字。

[回到顶部](#菜单)

---
## [#20 有效的括号](https://leetcode-cn.com/problems/valid-parentheses)
给定一个只包括 `'('`，`')'`，`'{'`，`'}'`，`'['`，`']'` 的字符串，判断字符串是否有效

有效字符串需满足：
  1. 左括号必须用相同类型的右括号闭合。
  2. 左括号必须以正确的顺序闭合。

注意空字符串可被认为是有效字符串。

**示例 1:**
```
输入: "()"
输出: true
```
**示例 2:**
```
输入: "()[]{}"
输出: true
```
**示例 3:**
```
输入: "(]"
输出: false
```
**示例 4:**
```
输入: "([)]"
输出: false
```
**示例 5:**
```
输入: "{[]}"
输出: true
```
[回到顶部](#菜单)

---
## [#21 合并两个有序链表](https://leetcode-cn.com/problems/merge-two-sorted-lists)
将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。

**示例:**
```
输入：1->2->4, 1->3->4
输出：1->1->2->3->4->4
```
[回到顶部](#菜单)

---
## [#26 删除排序数组中的重复项](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array)
给定一个排序数组，你需要在[原地](https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95)删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。

不要使用额外的数组空间，你必须在[原地](http://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95)**修改输入数组**并在使用 O(1) 额外空间的条件下完成。

**示例 1:**
```
给定数组 nums = [1,1,2],

函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。

你不需要考虑数组中超出新长度后面的元素。
```
**Example(示例) 2:**
```
给定 nums = [0,0,1,1,1,2,2,3,3,4],

函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。

你不需要考虑数组中超出新长度后面的元素。
```
**说明:**

为什么返回数值是整数，但输出的答案是数组呢?

请注意，输入数组是以“**引用**”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。

你可以想象内部操作如下:
```cpp
// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝
int len = removeElement(nums);

// 在函数里修改输入数组对于调用者是可见的
// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。
for (int i = 0; i < len; i++) {
    print(nums[i]);
}
```
[回到顶部](#菜单)

---
## [#27 移除元素](https://leetcode-cn.com/problems/remove-element)
给定一个数组 *nums* 和一个值 *val*，你需要[原地](http://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95)移除所有数值等于 *val* 的元素，返回移除后数组的新长度。

不要使用额外的数组空间，你必须在[原地](http://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95)**修改输入数组**并在使用 O(1) 额外空间的条件下完成。

**示例 1:**
```
给定 nums = [3,2,2,3], val = 3,

函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。

你不需要考虑数组中超出新长度后面的元素。
```
**示例 2:**
```
给定 nums = [0,1,2,2,3,0,4,2], val = 2,

函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。

注意这五个元素可为任意顺序。

你不需要考虑数组中超出新长度后面的元素。
```
**说明:**

为什么返回数值是整数，但输出的答案是数组呢?

请注意，输入数组是以“**引用**”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。

你可以想象内部操作如下:
```cpp
// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝
int len = removeDuplicates(nums);

// 在函数里修改输入数组对于调用者是可见的
// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。
for (int i = 0; i < len; i++) {
    print(nums[i]);
}
```
[回到顶部](#菜单)

---
## [#28 实现 strStr()](https://leetcode-cn.com/problems/implement-strstr)
实现 [strStr()](https://baike.baidu.com/item/strstr/811469) 函数。

给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回 **-1**。

**示例 1:**
```
输入: haystack = "hello", needle = "ll"
输出: 2
```
**示例 2:**
```
输入: haystack = "aaaaa", needle = "bba"
输出: -1
```
**说明:**

当 `needle` 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。

对于本题而言，当 `needle` 是空字符串时我们应当返回 0 。这与C语言的 [strstr()](https://baike.baidu.com/item/strstr/811469) 以及 Java的 [indexOf()](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html#indexOf(java.lang.String)) 定义相符。

[回到顶部](#菜单)

---
## [#33 搜索旋转排序数组](https://leetcode-cn.com/problems/search-in-rotated-sorted-array)
假设按照升序排序的数组在预先未知的某个点上进行了旋转。

( 例如，数组 `[0,1,2,4,5,6,7]` 可能变为 `[4,5,6,7,0,1,2]` )。

搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 `-1` 。

你可以假设数组中不存在重复的元素。

你的算法时间复杂度必须是 *O*(log *n*) 级别。

**示例 1:**
```
输入: nums = [4,5,6,7,0,1,2], target = 0
输出: 4
```
**示例 2:**
```
输入: nums = [4,5,6,7,0,1,2], target = 3
输出: -1
```
[回到顶部](#菜单)

---
## [#35 搜索插入位置](https://leetcode-cn.com/problems/search-insert-position)
给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。

你可以假设数组中无重复元素。

**示例 1:**
```
输入: [1,3,5,6], 5
输出: 2
```
**示例 2:**
```
输入: [1,3,5,6], 2
输出: 1
```
**示例 3:**
```
输入: [1,3,5,6], 7
输出: 4
```
**示例 4:**
```
输入: [1,3,5,6], 0
输出: 0
```
[回到顶部](#菜单)

---
## [#38 外观数列](https://leetcode-cn.com/problems/count-and-say)
「外观数列」是一个整数序列，从数字 1 开始，序列中的每一项都是对前一项的描述。前五项如下：
```
1.      1
2.      11
3.      21
4.      1211
5.      111221
```
`1` 被读作  `"one 1"`  (`"一个一"`) , 即 `11`。

`11` 被读作 `"two 1s"` (`"两个一"`）, 即 `21`。)

`21` 被读作 `"one 2"`,  `"one 1"` （`"一个二"` ,  `"一个一"` , 即 `1211`。)

给定一个正整数 *n*（1 ≤ *n* ≤ 30），输出外观数列的第 *n* 项。

注意：整数序列中的每一项将表示为一个字符串。

**示例 1:**
```
输入: 1
输出: "1"
解释：这是一个基本样例。
```
**示例 2:**
```
输入: 4
输出: "1211"
解释：当 n = 3 时，序列是 "21"，其中我们有 "2" 和 "1" 两组，"2" 可以读作 "12"，也就是出现频次 = 1 而 值 = 2；类似 "1" 可以读作 "11"。所以答案是 "12" 和 "11" 组合在一起，也就是 "1211"。
```
[回到顶部](#菜单)

---
## [#49 字母异位词分组](https://leetcode-cn.com/problems/group-anagrams)
给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。

**示例:**
```
输入: ["eat", "tea", "tan", "ate", "nat", "bat"]
输出:
[
  ["ate","eat","tea"],
  ["nat","tan"],
  ["bat"]
]
```
**说明：**
- 所有输入均为小写字母。
- 不考虑答案输出的顺序。

[回到顶部](#菜单)

---
## [#53 最大子序和](https://leetcode-cn.com/problems/maximum-subarray)
给定一个整数数组 `nums` ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

**示例 :**
```
输入: [-2,1,-3,4,-1,2,1,-5,4],
输出: 6
解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。
```
**进阶:**

如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。

[回到顶部](#菜单)

---
## [#55 跳跃游戏](https://leetcode-cn.com/problems/jump-game)
给定一个非负整数数组，你最初位于数组的第一个位置。

数组中的每个元素代表你在该位置可以跳跃的最大长度。

判断你是否能够到达最后一个位置。

**示例 1:**
```
输入: [2,3,1,1,4]
输出: true
解释: 我们可以先跳 1 步，从位置 0 到达 位置 1, 然后再从位置 1 跳 3 步到达最后一个位置。
```
**示例 2:**
```
输入: [3,2,1,0,4]
输出: false
解释: 无论怎样，你总会到达索引为 3 的位置。但该位置的最大跳跃长度是 0 ， 所以你永远不可能到达最后一个位置。
```
[回到顶部](#菜单)

---
## [#58 最后一个单词的长度](https://leetcode-cn.com/problems/length-of-last-word)
给定一个仅包含大小写字母和空格 `' '` 的字符串 `s`，返回其最后一个单词(如果字符串从左向右滚动显示，那么最后一个单词就是最后出现的单词。)的长度。

如果不存在最后一个单词，请返回 0 。

**说明:**

一个单词是指仅由字母组成、不包含任何空格的 **最大子字符串**。

**示例 :**
```
输入: "Hello World"
输出: 5
```
[回到顶部](#菜单)

---
## [#64 最小路径和](https://leetcode-cn.com/problems/minimum-path-sum)
给定一个包含非负整数的 *m* x *n* 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。

**说明:** 每次只能向下或者向右移动一步。

**示例:**
```
输入:
[
  [1,3,1],
  [1,5,1],
  [4,2,1]
]
输出: 7
解释: 因为路径 1→3→1→1→1 的总和最小。
```
[回到顶部](#菜单)

---
## [#66 加一](https://leetcode-cn.com/problems/plus-one)
给定一个由 **整数** 组成的 **非空** 数组所表示的非负整数，在该数的基础上加一。

最高位数字存放在数组的首位， 数组中每个元素只存储一个数字。

你可以假设除了整数 0 之外，这个整数不会以零开头。

**示例 1:**
```
输入: [1,2,3]
输出: [1,2,4]
解释: 输入数组表示数字 123。
```
**示例 2:**
```
输入: [4,3,2,1]
输出: [4,3,2,2]
解释: 输入数组表示数字 4321。
```
[回到顶部](#菜单)

---
## [#67 二进制求和](https://leetcode-cn.com/problems/add-binary)
给定两个二进制字符串，返回他们的和（用二进制表示）。

输入为**非空**字符串且只包含数字 `1` 和 `0`。

**示例 1:**
```
输入: a = "11", b = "1"
输出: "100"
```
**示例 2:**
```
输入: a = "1010", b = "1011"
输出: "10101"
```
[回到顶部](#菜单)

---
## [#69 x 的平方根](https://leetcode-cn.com/problems/sqrtx)
实现 `int sqrt(int x)` 函数。

计算并返回 *x* 的平方根，其中 *x* 是非负整数。

由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。

**示例 1:**
```
输入: 4
输出: 2
```
**示例 2:**
```
输入: 8
输出: 2
说明: 8 的平方根是 2.82842...,
     由于返回类型是整数，小数部分将被舍去。
```
[回到顶部](#菜单)

---
## [#70 爬楼梯](https://leetcode-cn.com/problems/climbing-stairs)
假设你正在爬楼梯。需要 *n* 阶你才能到达楼顶。

每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

**注意:** 给定 *n* 是一个正整数。

**示例 1:**
```
输入： 2
输出： 2
解释： 有两种方法可以爬到楼顶。
1.  1 阶 + 1 阶
2.  2 阶
```
**示例 2:**
```
输入： 3
输出： 3
解释： 有三种方法可以爬到楼顶。
1.  1 阶 + 1 阶 + 1 阶
2.  1 阶 + 2 阶
3.  2 阶 + 1 阶
```
[回到顶部](#菜单)

---
## [#83 删除排序链表中的重复元素](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list)
给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。

**示例 1:**
```
输入: 1->1->2
输出: 1->2
```
**示例 2:**
```
输入: 1->1->2->3->3
输出: 1->2->3
```
[回到顶部](#菜单)

---
## [#88 合并两个有序数组](https://leetcode-cn.com/problems/merge-sorted-array)
给定两个有序整数数组 nums1 和 nums2，将 nums2 合并到 nums1 中，使得 num1 成为一个有序数组。

**说明:**
- 初始化 nums1 和 nums2 的元素数量分别为 m 和 n。
- 你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。

**示例:**
```
输入:
nums1 = [1,2,3,0,0,0], m = 3
nums2 = [2,5,6],       n = 3

输出: [1,2,2,3,5,6]
```
[回到顶部](#菜单)

---
## [#100 相同的树](https://leetcode-cn.com/problems/same-tree)
给定两个二叉树，编写一个函数来检验它们是否相同。

如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。

**示例 1:**
```
输入:       1         1
          / \       / \
         2   3     2   3

        [1,2,3],   [1,2,3]

输出: true
```
**示例 2:**
```
输入:      1          1
          /           \
         2             2

        [1,2],     [1,null,2]

输出: false
```
**示例 3:**
```
输入:       1         1
          / \       / \
         2   1     1   2

        [1,2,1],   [1,1,2]

输出: false
```
[回到顶部](#菜单)

---
## [#101 对称二叉树](https://leetcode-cn.com/problems/symmetric-tree)
给定一个二叉树，检查它是否是镜像对称的。

例如，二叉树 `[1,2,2,3,4,4,3]` 是对称的。
```
    1
   / \
  2   2
 / \ / \
3  4 4  3
```
但是下面这个 `[1,2,2,null,3,null,3]` 则不是镜像对称的:
```
    1
   / \
  2   2
   \   \
   3    3
```
**说明:**

如果你可以运用递归和迭代两种方法解决这个问题，会很加分。

[回到顶部](#菜单)

---
## [#104 二叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree)
给定一个二叉树，找出其最大深度。

二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。

**说明:** 叶子节点是指没有子节点的节点。

**示例 1:**

给定二叉树 `[3,9,20,null,null,15,7]`，
```
    3
   / \
  9  20
    /  \
   15   7
```
返回它的最大深度 3 。

[回到顶部](#菜单)

---
## [#107 二叉树的层次遍历 II](https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii)
给定一个二叉树，返回其节点值自底向上的层次遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）

例如：

给定二叉树 `[3,9,20,null,null,15,7]`,
```
    3
   / \
  9  20
    /  \
   15   7
```
返回其自底向上的层次遍历为：
```
[
  [15,7],
  [9,20],
  [3]
]
```
[回到顶部](#菜单)

---
## [#108 将有序数组转换为二叉搜索树](https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree)
将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。

本题中，一个高度平衡二叉树是指一个二叉树*每个节点* 的左右两个子树的高度差的绝对值不超过 1。

**示例:**
```
给定有序数组: [-10,-3,0,5,9],

一个可能的答案是：[0,-3,9,-10,null,5]，它可以表示下面这个高度平衡二叉搜索树：

      0
     / \
   -3   9
   /   /
 -10  5
```
[回到顶部](#菜单)

---
## [#110 平衡二叉树](https://leetcode-cn.com/problems/balanced-binary-tree)
给定一个二叉树，判断它是否是高度平衡的二叉树。

本题中，一棵高度平衡二叉树定义为：

> 一个二叉树*每个节点* 的左右两个子树的高度差的绝对值不超过1。

**示例 1:**

给定二叉树 `[3,9,20,null,null,15,7]`
```
    3
   / \
  9  20
    /  \
   15   7
```
返回 `true` 。

**示例 2:**

给定二叉树 `[1,2,2,3,3,null,null,4,4]`
```
       1
      / \
     2   2
    / \
   3   3
  / \
 4   4
```
返回 `false` 。

[回到顶部](#菜单)

---
## [#111 二叉树的最小深度](https://leetcode-cn.com/problems/minimum-depth-of-binary-tree)
给定一个二叉树，找出其最小深度。

最小深度是从根节点到最近叶子节点的最短路径上的节点数量。

**说明:** 叶子节点是指没有子节点的节点。

**示例:**

给定二叉树 `[3,9,20,null,null,15,7]`,
```
    3
   / \
  9  20
    /  \
   15   7
```
返回它的最小深度  2.

[回到顶部](#菜单)

---
## [#112 路径总和](https://leetcode-cn.com/problems/path-sum)
给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。

**说明:** 叶子节点是指没有子节点的节点。

**示例:**

给定如下二叉树，以及目标和 `sum = 22`，
```
              5
             / \
            4   8
           /   / \
          11  13  4
         /  \      \
        7    2      1
```
返回 `true`, 因为存在目标和为 22 的根节点到叶子节点的路径 `5->4->11->2`。

[回到顶部](#菜单)

---
## [#118 杨辉三角](https://leetcode-cn.com/problems/pascals-triangle)
给定一个非负整数 *numRows*，生成杨辉三角的前 *numRows* 行。

![](https://upload.wikimedia.org/wikipedia/commons/0/0d/PascalTriangleAnimated2.gif)

在杨辉三角中，每个数是它左上方和右上方的数的和。

**示例:**
```
输入: 5
输出:
[
     [1],
    [1,1],
   [1,2,1],
  [1,3,3,1],
 [1,4,6,4,1]
]
```
[回到顶部](#菜单)

---
## [#119 杨辉三角 II](https://leetcode-cn.com/problems/pascals-triangle-ii)
给定一个非负索引 *k*，其中 *k* ≤ 33，返回杨辉三角的第 *k* 行。

![](https://upload.wikimedia.org/wikipedia/commons/0/0d/PascalTriangleAnimated2.gif)

在杨辉三角中，每个数是它左上方和右上方的数的和。

**示例:**
```
输入: 3
输出: [1,3,3,1]
```
**进阶:**

你可以优化你的算法到 *O*(k) 空间复杂度吗？

[回到顶部](#菜单)

---
## [#121 买卖股票的最佳时机](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock)
给定一个数组，它的第 *i* 个元素是一支给定股票第 *i* 天的价格。

如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。

注意你不能在买入股票前卖出股票。

**示例 1:**
```
输入: [7,1,5,3,6,4]
输出: 5
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。
```
**示例 2:**
```
输入: [7,6,4,3,1]
输出: 0
解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。
```
[回到顶部](#菜单)

---
## [#122 买卖股票的最佳时机 II](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii)
给定一个数组，它的第 *i* 个元素是一支给定股票第 *i* 天的价格。

设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。

**注意:** 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

**示例 1:**
```
输入: [7,1,5,3,6,4]
输出: 7
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。
```
**示例 2:**
```
输入: [1,2,3,4,5]
输出: 4
解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。
     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。
```
**示例 3:**
```
输入: [7,6,4,3,1]
输出: 0
解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。
```
[回到顶部](#菜单)

---
## [#124 二叉树中的最大路径和](https://leetcode-cn.com/problems/binary-tree-maximum-path-sum)
给定一个**非空**二叉树，返回其最大路径和。

本题中，路径被定义为一条从树中任意节点出发，达到任意节点的序列。该路径**至少包含一个**节点，且不一定经过根节点。

**示例 1:**
```
输入: [1,2,3]

       1
      / \
     2   3

输出: 6
```
**示例 2:**
```
输入: [-10,9,20,null,null,15,7]

   -10
   / \
  9  20
    /  \
   15   7

输出: 42
```
[回到顶部](#菜单)

---
## [#125 验证回文串](https://leetcode-cn.com/problems/valid-palindrome)
给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。

**说明:** 本题中，我们将空字符串定义为有效的回文串。

**示例 1:**
```
输入: "A man, a plan, a canal: Panama"
输出: true
```
**示例 2:**
```
输入: "race a car"
输出: false
```
[回到顶部](#菜单)

---
## [#136 只出现一次的数字](https://leetcode-cn.com/problems/single-number)
给定一个**非空**整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。

**说明:**

你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？

**示例 1:**
```
输入: [2,2,1]
输出: 1
```
**示例 2:**
```
输入: [4,1,2,1,2]
输出: 4
```
[回到顶部](#菜单)

---
## [#141 环形链表](https://leetcode-cn.com/problems/linked-list-cycle)
给定一个链表，判断链表中是否有环。

为了表示给定链表中的环，我们使用整数 `pos` 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 `pos` 是 `-1`，则在该链表中没有环。

**示例 1:**
```
输入：head = [3,2,0,-4], pos = 1
输出：true
解释：链表中有一个环，其尾部连接到第二个节点。
```
![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist.png)

**示例 2:**
```
输入：head = [1,2], pos = 0
输出：true
解释：链表中有一个环，其尾部连接到第一个节点。
```
![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test2.png)

**示例 3:**
```
输入：head = [1], pos = -1
输出：false
解释：链表中没有环。
```
![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test3.png)

**进阶:**

你能用 *O(1)*（即，常量）内存解决此问题吗？

[回到顶部](#菜单)

---
## [#146 LRU缓存机制](https://leetcode-cn.com/problems/lru-cache)
运用你所掌握的数据结构，设计和实现一个  [LRU (最近最少使用) 缓存机制](https://baike.baidu.com/item/LRU)。它应该支持以下操作： 获取数据 `get` 和 写入数据 `put` 。

获取数据 `get(key)` - 如果密钥 (key) 存在于缓存中，则获取密钥的值（总是正数），否则返回 -1。

写入数据 `put(key, value)` - 如果密钥已经存在，则变更其数据值；如果密钥不存在，则插入该组「密钥/数据值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。

**进阶:**

你是否可以在 **O(1)** 时间复杂度内完成这两种操作？

**示例:**
```
LRUCache cache = new LRUCache( 2 /* 缓存容量 */ );

cache.put(1, 1);
cache.put(2, 2);
cache.get(1);       // 返回  1
cache.put(3, 3);    // 该操作会使得密钥 2 作废
cache.get(2);       // 返回 -1 (未找到)
cache.put(4, 4);    // 该操作会使得密钥 1 作废
cache.get(1);       // 返回 -1 (未找到)
cache.get(3);       // 返回  3
cache.get(4);       // 返回  4
```

[回到顶部](#菜单)

---
## [#153 寻找旋转排序数组中的最小值](https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array)
已知一个长度为 `n` 的数组，预先按照升序排列，经由 `1` 到 `n` 次 **旋转** 后，得到输入数组。例如，原数组 `nums = [0,1,2,4,5,6,7]` 在变化后可能得到：
  - 若旋转 `4` 次，则可以得到 `[4,5,6,7,0,1,2]`
  - 若旋转 `4` 次，则可以得到 `[0,1,2,4,5,6,7]`

注意，数组 `[a[0], a[1], a[2], ..., a[n-1]]` **旋转一次** 的结果为数组 `[a[n-1], a[0], a[1], a[2], ..., a[n-2]]` 。

给你一个元素值 **互不相同** 的数组 `nums` ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 **最小元素** 。

**示例 1:**
```
输入：nums = [3,4,5,1,2]
输出：1
解释：原数组为 [1,2,3,4,5] ，旋转 3 次得到输入数组。
```
**示例 2:**
```
输入：nums = [4,5,6,7,0,1,2]
输出：0
解释：原数组为 [0,1,2,4,5,6,7] ，旋转 4 次得到输入数组。
```
**示例 3:**
```
输入：nums = [11,13,15,17]
输出：11
解释：原数组为 [11,13,15,17] ，旋转 4 次得到输入数组。
```
**提示:**
  - `n == nums.length`
  - `1 <= n <= 5000`
  - `-5000 <= nums[i] <= 5000`
  - `nums` 中的所有整数 **互不相同**
  - `nums` 原来是一个升序排序的数组，并进行了 `1` 至 `n` 次旋转
[回到顶部](#菜单)

---
## [#155 最小栈](https://leetcode-cn.com/problems/min-stack)
设计一个支持 push，pop，top 操作，并能在常数时间内检索到最小元素的栈。
- push(x) -- 将元素 x 推入栈中。
- pop() -- 删除栈顶的元素。
- top() -- 获取栈顶元素。
- getMin() -- 检索栈中的最小元素。

**示例:**
```
MinStack minStack = new MinStack();
minStack.push(-2);
minStack.push(0);
minStack.push(-3);
minStack.getMin();   --> 返回 -3.
minStack.pop();
minStack.top();      --> 返回 0.
minStack.getMin();   --> 返回 -2.
```
[回到顶部](#菜单)

---
## [#160 相交链表](https://leetcode-cn.com/problems/intersection-of-two-linked-lists)
编写一个程序，找到两个单链表相交的起始节点。

如下面的两个链表：

![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png)

在节点 c1 开始相交。

**示例 1:**

![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_1.png)
```
输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3
输出：Reference of the node with value = 8
输入解释：相交节点的值为 8 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。
```
**示例 2:**

![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_2.png)
```
输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1
输出：Reference of the node with value = 2
输入解释：相交节点的值为 2 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。
```
**示例 3:**

![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_3.png)
```
输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2
输出：null
输入解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。
解释：这两个链表不相交，因此返回 null。
```
**注意:**
- 如果两个链表没有交点，返回 `null`.
- 在返回结果后，两个链表仍须保持原有的结构。
- 可假定整个链表结构中没有循环。
- 程序尽量满足 O(*n*) 时间复杂度，且仅用 O(*1*) 内存。

[回到顶部](#菜单)

---
## [#167 两数之和 II - 输入有序数组](https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted)
给定一个已按照 ***升序排列*** 的有序数组，找到两个数使得它们相加之和等于目标数。

函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2。

**说明:**
- 返回的下标值（index1 和 index2）不是从零开始的。
- 你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。

**示例:**
```
输入: numbers = [2, 7, 11, 15], target = 9
输出: [1,2]
解释: 2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。
```
[回到顶部](#菜单)

---
## [#168 Excel表列名称](https://leetcode-cn.com/problems/excel-sheet-column-title)
给定一个正整数，返回它在 Excel 表中相对应的列名称。

例如，
```
    1 -> A
    2 -> B
    3 -> C
    ...
    26 -> Z
    27 -> AA
    28 -> AB
    ...
```
**示例 1:**
```
输入: 1
输出: "A"
```
**示例 2:**
```
输入: 28
输出: "AB"
```
**示例 3:**
```
输入: 701
输出: "ZY"
```
[回到顶部](#菜单)

---
## [#169 多数元素](https://leetcode-cn.com/problems/majority-element)
给定一个大小为 *n* 的数组，找到其中的多数元素。多数元素是指在数组中出现次数**大于** `⌊ n/2 ⌋` 的元素。

你可以假设数组是非空的，并且给定的数组总是存在多数元素。

**示例 1:**
```
输入: [3,2,3]
输出: 3
```
**示例 2:**
```
输入: [2,2,1,1,1,2,2]
输出: 2
```
[回到顶部](#菜单)

---
## [#171 Excel表列序号](https://leetcode-cn.com/problems/basic-calculator)
给定一个Excel表格中的列名称，返回其相应的列序号。

例如，
```
    A -> 1
    B -> 2
    C -> 3
    ...
    Z -> 26
    AA -> 27
    AB -> 28
    ...
```
**示例 1:**
```
输入: "A"
输出: 1
```
**示例 2:**
```
输入: "AB"
输出: 28
```
**示例 3:**
```
输入: "ZY"
输出: 701
```
[回到顶部](#菜单)

---
## [#172 阶乘后的零](https://leetcode-cn.com/problems/factorial-trailing-zeroes)
给定一个整数 *n*，返回 *n*! 结果尾数中零的数量。

**示例 1:**
```
输入: 3
输出: 0
解释: 3! = 6, 尾数中没有零。
```
**示例 2:**
```
输入: 5
输出: 1
解释: 5! = 120, 尾数中有 1 个零.
```
[回到顶部](#菜单)

---
## [#175 组合两个表](https://leetcode-cn.com/problems/combine-two-tables)
表1: `Person`
```
+-------------+---------+
| 列名         | 类型     |
+-------------+---------+
| PersonId    | int     |
| FirstName   | varchar |
| LastName    | varchar |
+-------------+---------+
PersonId 是上表主键
```
表2: `Address`
```
+-------------+---------+
| 列名         | 类型    |
+-------------+---------+
| AddressId   | int     |
| PersonId    | int     |
| City        | varchar |
| State       | varchar |
+-------------+---------+
AddressId 是上表主键
```
编写一个 SQL 查询，满足条件：无论 person 是否有地址信息，都需要基于上述两表提供 person 的以下信息：
```
FirstName, LastName, City, State
```
[回到顶部](#菜单)

---
## [#176 第二高的薪水](https://leetcode-cn.com/problems/second-highest-salary)
编写一个 SQL 查询，获取 `Employee` 表中第二高的薪水（Salary） 。
```
+----+--------+
| Id | Salary |
+----+--------+
| 1  | 100    |
| 2  | 200    |
| 3  | 300    |
+----+--------+
```
例如上述 `Employee` 表，SQL查询应该返回 `200` 作为第二高的薪水。如果不存在第二高的薪水，那么查询应返回 `null。`
```
+---------------------+
| SecondHighestSalary |
+---------------------+
| 200                 |
+---------------------+
```
[回到顶部](#菜单)

---
## [#181 超过经理收入的员工](https://leetcode-cn.com/problems/employees-earning-more-than-their-managers)
`Employee` 表包含所有员工，他们的经理也属于员工。每个员工都有一个 Id，此外还有一列对应员工的经理的 Id。
```+----+-------+--------+-----------+
| Id | Name  | Salary | ManagerId |
+----+-------+--------+-----------+
| 1  | Joe   | 70000  | 3         |
| 2  | Henry | 80000  | 4         |
| 3  | Sam   | 60000  | NULL      |
| 4  | Max   | 90000  | NULL      |
+----+-------+--------+-----------+
```
给定 `Employee` 表，编写一个 SQL 查询，该查询可以获取收入超过他们经理的员工的姓名。在上面的表格中，Joe 是唯一一个收入超过他的经理的员工。
```
+----------+
| Employee |
+----------+
| Joe      |
+----------+
```
[回到顶部](#菜单)

---
## [#182 查找重复的电子邮箱](https://leetcode-cn.com/problems/duplicate-emails)
编写一个 SQL 查询，查找 `Person` 表中所有重复的电子邮箱。

**示例:**
```
+----+---------+
| Id | Email   |
+----+---------+
| 1  | a@b.com |
| 2  | c@d.com |
| 3  | a@b.com |
+----+---------+
```
根据以上输入，你的查询应返回以下结果：
```
+---------+
| Email   |
+---------+
| a@b.com |
+---------+
```
**说明:**所有电子邮箱都是小写字母。

[回到顶部](#菜单)

---
## [#183 从不订购的客户](https://leetcode-cn.com/problems/basic-calculator)
某网站包含两个表，`Customers` 表和 `Orders` 表。编写一个 SQL 查询，找出所有从不订购任何东西的客户。

`Customers` 表：
```
+----+-------+
| Id | Name  |
+----+-------+
| 1  | Joe   |
| 2  | Henry |
| 3  | Sam   |
| 4  | Max   |
+----+-------+
```
`Orders` 表：
```
+----+------------+
| Id | CustomerId |
+----+------------+
| 1  | 3          |
| 2  | 1          |
+----+------------+
```
例如给定上述表格，你的查询应返回：
```
+-----------+
| Customers |
+-----------+
| Henry     |
| Max       |
+-----------+
```
[回到顶部](#菜单)

---
## [#189 旋转数组](https://leetcode-cn.com/problems/rotate-array)
给定一个数组，将数组中的元素向右移动 *k* 个位置，其中 *k* 是非负数。

**示例 1:**
```
输入: [1,2,3,4,5,6,7] 和 k = 3
输出: [5,6,7,1,2,3,4]
解释:
向右旋转 1 步: [7,1,2,3,4,5,6]
向右旋转 2 步: [6,7,1,2,3,4,5]
向右旋转 3 步: [5,6,7,1,2,3,4]
```
**示例 2:**
```
输入: [-1,-100,3,99] 和 k = 2
输出: [3,99,-1,-100]
解释:
向右旋转 1 步: [99,-1,-100,3]
向右旋转 2 步: [3,99,-1,-100]
```
**说明:**
- 尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。
- 要求使用空间复杂度为 O(1) 的 **原地** 算法。

[回到顶部](#菜单)

---
## [#190 颠倒二进制位](https://leetcode-cn.com/problems/reverse-bits)
颠倒给定的 32 位无符号整数的二进制位。

**示例 1:**
```
输入: 00000010100101000001111010011100
输出: 00111001011110000010100101000000
解释: 输入的二进制串 00000010100101000001111010011100 表示无符号整数 43261596，
      因此返回 964176192，其二进制表示形式为 00111001011110000010100101000000。
```
**示例 2:**
```
输入：11111111111111111111111111111101
输出：10111111111111111111111111111111
解释：输入的二进制串 11111111111111111111111111111101 表示无符号整数 4294967293，
      因此返回 3221225471 其二进制表示形式为 10101111110010110010011101101001。
```
**提示:**
- 请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。
- 在 Java 中，编译器使用[二进制补码](https://baike.baidu.com/item/%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%A1%A5%E7%A0%81/5295284)记法来表示有符号整数。因此，在上面的 **示例 2** 中，输入表示有符号整数 `-3`，输出表示有符号整数 `-1073741825`。

**进阶:**

如果多次调用这个函数，你将如何优化你的算法？

[回到顶部](#菜单)

---
## [#191 位1的个数](https://leetcode-cn.com/problems/number-of-1-bits)
编写一个函数，输入是一个无符号整数，返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为[汉明重量](https://baike.baidu.com/item/%E6%B1%89%E6%98%8E%E9%87%8D%E9%87%8F）。

**示例 1:**
```
输入：00000000000000000000000000001011
输出：3
解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 '1'。
```
**示例 2:**
```
输入：00000000000000000000000010000000
输出：1
解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 '1'。
```
**示例 3:**
```
输入：11111111111111111111111111111101
输出：31
解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 '1'。
```
**提示:**
- 请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。
- 在 Java 中，编译器使用[二进制补码](https://baike.baidu.com/item/%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%A1%A5%E7%A0%81/5295284)记法来表示有符号整数。因此，在上面的 **示例 3** 中，输入表示有符号整数 `-3`。

**进阶:**

如果多次调用这个函数，你将如何优化你的算法？

[回到顶部](#菜单)

---
## [#193 有效电话号码](https://leetcode-cn.com/problems/valid-phone-numbers)
给定一个包含电话号码列表（一行一个电话号码）的文本文件 `file.txt`，写一个 bash 脚本输出所有有效的电话号码。

你可以假设一个有效的电话号码必须满足以下两种格式： (xxx) xxx-xxxx 或 xxx-xxx-xxxx。（x 表示一个数字）

你也可以假设每行前后没有多余的空格字符。

**示例:**

假设 `file.txt` 内容如下：
```
987-123-4567
123 456 7890
(123) 456-7890
```
你的脚本应当输出下列有效的电话号码：
```
987-123-4567
(123) 456-7890
```
[回到顶部](#菜单)

---
## [#195 第十行](https://leetcode-cn.com/problems/tenth-line)
给定一个文本文件 `file.txt`，请只打印这个文件中的第十行。

**示例:**

假设 `file.txt` 有如下内容：
```
Line 1
Line 2
Line 3
Line 4
Line 5
Line 6
Line 7
Line 8
Line 9
Line 10
```
你的脚本应当显示第十行：
```
Line 10
```
**说明:**
1. 如果文件少于十行，你应当输出什么？
2. 至少有三种不同的解法，请尝试尽可能多的方法来解题。

[回到顶部](#菜单)

---
## [#196 删除重复的电子邮箱](https://leetcode-cn.com/problems/delete-duplicate-emails)
编写一个 SQL 查询，来删除 `Person` 表中所有重复的电子邮箱，重复的邮箱里只保留 **Id** *最小* 的那个。
```
+----+------------------+
| Id | Email            |
+----+------------------+
| 1  | john@example.com |
| 2  | bob@example.com  |
| 3  | john@example.com |
+----+------------------+
Id 是这个表的主键。
```
例如，在运行你的查询语句之后，上面的 `Person` 表应返回以下几行:
```
+----+------------------+
| Id | Email            |
+----+------------------+
| 1  | john@example.com |
| 2  | bob@example.com  |
+----+------------------+
```
**提示:**
- 执行 SQL 之后，输出是整个 `Person` 表。
- 使用 `delete` 语句。

[回到顶部](#菜单)

---
## [#197 上升的温度](https://leetcode-cn.com/problems/rising-temperature)
给定一个 `Weather` 表，编写一个 SQL 查询，来查找与之前（昨天的）日期相比温度更高的所有日期的 Id。
```
+---------+------------------+------------------+
| Id(INT) | RecordDate(DATE) | Temperature(INT) |
+---------+------------------+------------------+
|       1 |       2015-01-01 |               10 |
|       2 |       2015-01-02 |               25 |
|       3 |       2015-01-03 |               20 |
|       4 |       2015-01-04 |               30 |
+---------+------------------+------------------+
```
例如，根据上述给定的 `Weather` 表格，返回如下 Id:
```
+----+
| Id |
+----+
|  2 |
|  4 |
+----+
```
[回到顶部](#菜单)

---
## [#198 打家劫舍](https://leetcode-cn.com/problems/house-robber)
你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，**如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警**。

给定一个代表每个房屋存放金额的非负整数数组，计算你**在不触动警报装置的情况下**，能够偷窃到的最高金额。

**示例 1:**
```
输入: [1,2,3,1]
输出: 4
解释: 偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
     偷窃到的最高金额 = 1 + 3 = 4 。
```
**示例 2:**
```
输入: [2,7,9,3,1]
输出: 12
解释: 偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。
     偷窃到的最高金额 = 2 + 9 + 1 = 12 。
```
[回到顶部](#菜单)

---
## [#200 岛屿数量](https://leetcode-cn.com/problems/number-of-islands)
给你一个由 `'1'`（陆地）和 `'0'`（水）组成的的二维网格，请你计算网格中岛屿的数量。

岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。

此外，你可以假设该网格的四条边均被水包围。

**示例 1:**
```
输入:
11110
11010
11000
00000
输出: 1
```
**示例 2:**
```
输入:
11000
11000
00100
00011
输出: 3
解释: 每座岛屿只能由水平和/或竖直方向上相邻的陆地连接而成。
```
[回到顶部](#菜单)

---
## [#201 数字范围按位与](https://leetcode-cn.com/problems/bitwise-and-of-numbers-range)
给定范围 [m, n]，其中 0 <= m <= n <= 2147483647，返回此范围内所有数字的按位与（包含 m, n 两端点）。

**示例 1:**
```
输入: [5,7]
输出: 4
```
**示例 2:**
```
输入: [0,1]
输出: 0
```
[回到顶部](#菜单)

---
## [#202 快乐数](https://leetcode-cn.com/problems/happy-number)
编写一个算法来判断一个数 `n` 是不是快乐数。

「快乐数」定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是 **无限循环** 但始终变不到 1。如果 **可以变为** 1，那么这个数就是快乐数。

如果 `n` 是快乐数就返回 `True` ；不是，则返回 `False` 。

**示例:**
```
输入：19
输出：true
解释：
1^2 + 9^2 = 82
8^2 + 2^2 = 68
6^2 + 8^2 = 100
1^2 + 0^2 + 0^2 = 1
```
[回到顶部](#菜单)

---
## [#203 移除链表元素](https://leetcode-cn.com/problems/remove-linked-list-elements)
删除链表中等于给定值 ***val*** 的所有节点。

**示例:**
```
输入: 1->2->6->3->4->5->6, val = 6
输出: 1->2->3->4->5
```
[回到顶部](#菜单)

---
## [#204 计数质数](https://leetcode-cn.com/problems/count-primes)
统计所有小于非负整数 *n* 的质数的数量。

**示例:**
```
输入: 10
输出: 4
解释: 小于 10 的质数一共有 4 个, 它们是 2, 3, 5, 7 。
```
[回到顶部](#菜单)

---
## [#205 同构字符串](https://leetcode-cn.com/problems/isomorphic-strings)
给定两个字符串 **s** 和 **t**，判断它们是否是同构的。

如果 **s** 中的字符可以被替换得到 **t** ，那么这两个字符串是同构的。

所有出现的字符都必须用另一个字符替换，同时保留字符的顺序。两个字符不能映射到同一个字符上，但字符可以映射自己本身。

**示例 1:**
```
输入: s = "egg", t = "add"
输出: true
```
**示例 2:**
```
输入: s = "foo", t = "bar"
输出: false
```
**示例 3:**
```
输入: s = "paper", t = "title"
输出: true
```

**说明:**

你可以假设 **s** 和 **t** 具有相同的长度。

[回到顶部](#菜单)

---
## [#206 反转链表](https://leetcode-cn.com/problems/reverse-linked-list)
反转一个单链表。

**示例:**
```
输入: 1->2->3->4->5->NULL
输出: 5->4->3->2->1->NULL
```

**进阶:**

你可以迭代或递归地反转链表。你能否用两种方法解决这道题？

[回到顶部](#菜单)

---
## [#208 实现 Trie (前缀树)](https://leetcode-cn.com/problems/implement-trie-prefix-tree)
实现一个 Trie (前缀树)，包含 `insert`, `search`, 和 `startsWith` 这三个操作。

**示例:**
```
Trie trie = new Trie();

trie.insert("apple");
trie.search("apple");   // 返回 true
trie.search("app");     // 返回 false
trie.startsWith("app"); // 返回 true
trie.insert("app");   
trie.search("app");     // 返回 true
```
**说明:**
- 你可以假设所有的输入都是由小写字母 `a-z` 构成的。
- 保证所有输入均为非空字符串。

[回到顶部](#菜单)

---
## [#217 存在重复元素](https://leetcode-cn.com/problems/contains-duplicate)
给定一个整数数组，判断是否存在重复元素。

如果任意一值在数组中出现至少两次，函数返回 `true` 。如果数组中每个元素都不相同，则返回 `false` 。

**示例 1:**
```
输入: [1,2,3,1]
输出: true
```
**示例 2:**
```
输入: [1,2,3,4]
输出: false
```
**示例 3:**
```
输入: [1,1,1,3,3,4,3,2,4,2]
输出: true
```
[回到顶部](#菜单)

---
## [#219 存在重复元素 II](https://leetcode-cn.com/problems/contains-duplicate-ii)
给定一个整数数组和一个整数 k，判断数组中是否存在两个不同的索引 i 和 j，使得 **nums [i]** = **nums [j]**，并且 i 和 j 的差的 **绝对值** 至多为 k。

**示例 1:**
```
输入: nums = [1,2,3,1], k = 3
输出: true
```
**示例 2:**
```
输入: nums = [1,0,1,1], k = 1
输出: true
```
**示例 3:**
```
输入: nums = [1,2,3,1,2,3], k = 2
输出: false
```
[回到顶部](#菜单)

---
## [#221 最大正方形](https://leetcode-cn.com/problems/maximal-square)
在一个由 0 和 1 组成的二维矩阵内，找到只包含 1 的最大正方形，并返回其面积。

**示例:**
```
输入:

1 0 1 0 0
1 0 1 1 1
1 1 1 1 1
1 0 0 1 0

输出: 4
```
[回到顶部](#菜单)

---
## [#224 基本计算器](https://leetcode-cn.com/problems/basic-calculator)
实现一个基本的计算器来计算一个简单的字符串表达式的值。

字符串表达式可以包含左括号 `(` ，右括号 `)`，加号 `+` ，减号 `-`，**非负** 整数和空格`  `。

**示例 1:**
```
输入: "1 + 1"
输出: 2
```
**示例 2:**
```
输入: " 2-1 + 2 "
输出: 3
```
**示例 3:**
```
输入: "(1+(4+5+2)-3)+(6+8)"
输出: 23
```
**说明:**
- 你可以假设所给定的表达式都是有效的。
- 请 **不要** 使用内置的库函数 `eval`。

[回到顶部](#菜单)

---
## [#225 用队列实现栈](https://leetcode-cn.com/problems/implement-stack-using-queues)
使用队列实现栈的下列操作：
- push(x) -- 元素 x 入栈
- pop() -- 移除栈顶元素
- top() -- 获取栈顶元素
- empty() -- 返回栈是否为空

**注意:**
- 你只能使用队列的基本操作-- 也就是 `push to back`, `peek/pop from front`, `size`, 和 `is empty` 这些操作是合法的。
- 你所使用的语言也许不支持队列。 你可以使用 list 或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。
- 你可以假设所有操作都是有效的（例如, 对一个空的栈不会调用 pop 或者 top 操作）。

[回到顶部](#菜单)

---
## [#226 翻转二叉树](https://leetcode-cn.com/problems/invert-binary-tree)
翻转一棵二叉树。

**示例:**

输入:
```
     4
   /   \
  2     7
 / \   / \
1   3 6   9
```
输出:
```
     4
   /   \
  7     2
 / \   / \
9   6 3   1
```
**备注:**

这个问题是受到 [Max Howell](https://twitter.com/mxcl) 的 [原问题](https://twitter.com/mxcl/status/608682016205344768) 启发的 ：
> 谷歌：我们90％的工程师使用您编写的软件(Homebrew)，但是您却无法在面试时在白板上写出翻转二叉树这道题，这太糟糕了。

[回到顶部](#菜单)

---
## [#231 2的幂](https://leetcode-cn.com/problems/power-of-two)
给定一个整数，编写一个函数来判断它是否是 2 的幂次方。

**示例 1:**
```
输入: 1
输出: true
解释: 2^0 = 1
```
**示例 2:**
```
输入: 16
输出: true
解释: 2^4 = 16
```
**示例 3:**
```
输入: 218
输出: false
```
[回到顶部](#菜单)

---
## [#232 用栈实现队列](https://leetcode-cn.com/problems/implement-queue-using-stacks)
使用栈实现队列的下列操作：
- push(x) -- 将一个元素放入队列的尾部。
- pop() -- 从队列首部移除元素。
- peek() -- 返回队列首部的元素。
- empty() -- 返回队列是否为空。

**示例:**
```
MyQueue queue = new MyQueue();

queue.push(1);
queue.push(2);  
queue.peek();  // 返回 1
queue.pop();   // 返回 1
queue.empty(); // 返回 false
```
**说明:**
- 你只能使用标准的栈操作 -- 也就是只有 `push to top`, `peek/pop from top`, `size`, 和 `is empty` 操作是合法的。
- 你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。
- 假设所有操作都是有效的 （例如，一个空的队列不会调用 pop 或者 peek 操作）。

[回到顶部](#菜单)

---
## [#234 回文链表](https://leetcode-cn.com/problems/palindrome-linked-list)
请判断一个链表是否为回文链表。

**示例 1:**
```
输入: 1->2
输出: false
```
**示例 2:**
```
输入: 1->2->2->1
输出: true
```
**进阶:**

你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？

[回到顶部](#菜单)

---
## [#235 二叉搜索树的最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree)
给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。

[百度百科](https://baike.baidu.com/item/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/8918834?fr=aladdin)中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（**一个节点也可以是它自己的祖先**）。”

例如，给定如下二叉搜索树:  root = [6,2,8,0,4,7,9,null,null,3,5]

![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/binarysearchtree_improved.png)

**示例 1:**
```
输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8
输出: 6
解释: 节点 2 和节点 8 的最近公共祖先是 6。
```
**示例 2:**
```
输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4
输出: 2
解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。
```
**说明:**
- 所有节点的值都是唯一的。
- p、q 为不同节点且均存在于给定的二叉搜索树中。

[回到顶部](#菜单)

---
## [#237 删除链表中的节点](https://leetcode-cn.com/problems/delete-node-in-a-linked-list)
请编写一个函数，使其可以删除某个链表中给定的（非末尾）节点，你将只被给定要求被删除的节点。

现有一个链表 -- head = [4,5,1,9]，它可以表示为:

![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/01/19/237_example.png)

**示例 1:**
```
输入: head = [4,5,1,9], node = 5
输出: [4,1,9]
解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -> 1 -> 9.
```
**示例 2:**
```
输入: head = [4,5,1,9], node = 1
输出: [4,5,9]
解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -> 5 -> 9.
```
**说明:**
- 链表至少包含两个节点。
- 链表中所有节点的值都是唯一的。
- 给定的节点为非末尾节点并且一定是链表中的一个有效节点。
- 不要从你的函数中返回任何结果。

[回到顶部](#菜单)

---
## [#238 除自身以外数组的乘积](https://leetcode-cn.com/problems/product-of-array-except-self)
给你一个长度为 *n* 的整数数组 `nums`，其中 *n* > 1，返回输出数组 `output` ，其中 `output[i]` 等于 `nums` 中除 `nums[i]` 之外其余各元素的乘积。

**示例:**
```
输入: [1,2,3,4]
输出: [24,12,8,6]
```
**提示:** 题目数据保证数组之中任意元素的全部前缀元素和后缀（甚至是整个数组）的乘积都在 32 位整数范围内。

**说明:** 请不要使用**除法**，且在 O(n) 时间复杂度内完成此题。

**进阶:**

你可以在常数空间复杂度内完成这个题目吗？（ 出于对空间复杂度分析的目的，输出数组**不被视为**额外空间。）

[回到顶部](#菜单)

---
## [#242 有效的字母异位词](https://leetcode-cn.com/problems/valid-anagram)
给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。

**示例 1:**
```
输入: s = "anagram", t = "nagaram"
输出: true
```
**示例 2:**
```
输入: s = "rat", t = "car"
输出: false
```
**说明:**

你可以假设字符串只包含小写字母。

**进阶:**

如果输入字符串包含 unicode 字符怎么办？你能否调整你的解法来应对这种情况？

[回到顶部](#菜单)

---
## [#257 二叉树的所有路径](https://leetcode-cn.com/problems/binary-tree-paths)
给定一个二叉树，返回所有从根节点到叶子节点的路径。

**说明:** 叶子节点是指没有子节点的节点。

**示例:**
```
输入:

   1
 /   \
2     3
 \
  5

输出: ["1->2->5", "1->3"]

解释: 所有根节点到叶子节点的路径为: 1->2->5, 1->3
```
[回到顶部](#菜单)

---
## [#258 各位相加](https://leetcode-cn.com/problems/add-digits)
给定一个非负整数 `num`，反复将各个位上的数字相加，直到结果为一位数。

**示例:**
```
输入: 38
输出: 2
解释: 各位相加的过程为：3 + 8 = 11, 1 + 1 = 2。 由于 2 是一位数，所以返回 2。
```
**进阶:**

你可以不使用循环或者递归，且在 O(1) 时间复杂度内解决这个问题吗？

[回到顶部](#菜单)

---
## [#263 丑数](https://leetcode-cn.com/problems/ugly-number)
编写一个程序判断给定的数是否为丑数。

丑数就是只包含质因数 `2, 3, 5` 的**正整数**。

**示例 1:**
```
输入: 6
输出: true
解释: 6 = 2 × 3
```
**示例 2:**
```
输入: 8
输出: true
解释: 8 = 2 × 2 × 2
```
**示例 3:**
```
输入: 14
输出: false
解释: 14 不是丑数，因为它包含了另外一个质因数 7。
```
**说明:**
1. `1` 是丑数。
2. 输入不会超过 32 位有符号整数的范围: [−2^31,  2^31 − 1]。

[回到顶部](#菜单)

---
## [#268 丢失的数字](https://leetcode-cn.com/problems/missing-number)
给定一个包含 `[0, n]` 中 `n` 个数的数组 `nums` ，找出 `[0, n]` 这个范围内没有出现在数组中的那个数。

**进阶:**
- 你能否实现线性时间复杂度、仅使用额外常数空间的算法解决此问题?

**示例 1:**
```
输入：nums = [3,0,1]
输出：2
解释：n = 3，因为有 3 个数字，所以所有的数字都在范围 [0,3] 内。2 是丢失的数字，因为它没有出现在 nums 中。
```
**示例 2:**
```
输入：nums = [0,1]
输出：2
解释：n = 2，因为有 2 个数字，所以所有的数字都在范围 [0,2] 内。2 是丢失的数字，因为它没有出现在 nums 中。
```
**示例 3:**
```
输入：nums = [9,6,4,2,3,5,7,0,1]
输出：8
解释：n = 9，因为有 9 个数字，所以所有的数字都在范围 [0,9] 内。8 是丢失的数字，因为它没有出现在 nums 中。
```
**示例 4:**
```
输入：nums = [0]
输出：1
解释：n = 1，因为有 1 个数字，所以所有的数字都在范围 [0,1] 内。1 是丢失的数字，因为它没有出现在 nums 中。
```
**提示:**
- `n == nums.length`
- `1 <= n <= 10^4`
- `0 <= nums[i] <= n`
- `nums` 中的所有数字都 **独一无二**

[回到顶部](#菜单)

---
## [#278 第一个错误的版本](https://leetcode-cn.com/problems/first-bad-version)
你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。

假设你有 `n` 个版本 `[1, 2, ..., n]`，你想找出导致之后所有版本出错的第一个错误的版本。

你可以通过调用 `bool isBadVersion(version)` 接口来判断版本号 `version` 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。

**示例:**
```
给定 n = 5，并且 version = 4 是第一个错误的版本。

调用 isBadVersion(3) -> false
调用 isBadVersion(5) -> true
调用 isBadVersion(4) -> true

所以，4 是第一个错误的版本。
```
[回到顶部](#菜单)

---
## [#283 移动零](https://leetcode-cn.com/problems/move-zeroes)
给定一个数组 `nums`，编写一个函数将所有 `0` 移动到数组的末尾，同时保持非零元素的相对顺序。

**示例:**
```
输入: [0,1,0,3,12]
输出: [1,3,12,0,0]
```
**说明:**
1. 必须在原数组上操作，不能拷贝额外的数组。
2. 尽量减少操作次数。

[回到顶部](#菜单)

---
## [#290 单词规律](https://leetcode-cn.com/problems/word-pattern)
给定一种规律 `pattern` 和一个字符串 `str` ，判断 `str` 是否遵循相同的规律。

这里的 **遵循** 指完全匹配，例如， `pattern` 里的每个字母和字符串 `str` 中的每个非空单词之间存在着双向连接的对应规律。

**示例1:**
```
输入: pattern = "abba", str = "dog cat cat dog"
输出: true
```
**示例2:**
```
输入:pattern = "abba", str = "dog cat cat fish"
输出: false
```
**示例3:**
```
输入: pattern = "aaaa", str = "dog cat cat dog"
输出: false
```
**示例4:**
```
输入: pattern = "abba", str = "dog dog dog dog"
输出: false
```
**说明:**

你可以假设 `pattern` 只包含小写字母， `str` 包含了由单个空格分隔的小写字母。

[回到顶部](#菜单)

---
## [#292 Nim 游戏](https://leetcode-cn.com/problems/nim-game)
你和你的朋友，两个人一起玩 [Nim 游戏](https://baike.baidu.com/item/Nim%E6%B8%B8%E6%88%8F/6737105)：桌子上有一堆石头，每次你们轮流拿掉 1 - 3 块石头。 拿掉最后一块石头的人就是获胜者。你作为先手。

你们是聪明人，每一步都是最优解。 编写一个函数，来判断你是否可以在给定石头数量的情况下赢得游戏。

**示例:**
```
输入: 4
输出: false
解释: 如果堆中有 4 块石头，那么你永远不会赢得比赛；
     因为无论你拿走 1 块、2 块 还是 3 块石头，最后一块石头总是会被你的朋友拿走。
```
[回到顶部](#菜单)

---
## [#300 最长上升子序列](https://leetcode-cn.com/problems/longest-increasing-subsequence)
给定一个无序的整数数组，找到其中最长上升子序列的长度。

**示例:**
```
输入: [10,9,2,5,3,7,101,18]
输出: 4
解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。
```
**说明:**
- 可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。
- 你算法的时间复杂度应该为 O(n2) 。

**进阶**: 你能将算法的时间复杂度降低到 O(n log n) 吗?

[回到顶部](#菜单)

---
## [#322 零钱兑换](https://leetcode-cn.com/problems/coin-change)
给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。

你可以认为每种硬币的数量是无限的。

**示例 1:**
```
输入：coins = [1, 2, 5], amount = 11
输出：3
解释：11 = 5 + 5 + 1
```
**示例 2:**
```
输入：coins = [2], amount = 3
输出：-1
```
**示例 3:**
```
输入：coins = [1], amount = 0
输出：0
```
**示例 4:**
```
输入：coins = [1], amount = 1
输出：1
```
**示例 5:**
```
输入：coins = [1], amount = 2
输出：2
```
**提示:**
- `1 <= coins.length <= 12`
- `1 <= coins[i] <= 2^31 - 1`
- `0 <= amount <= 10^4`

[回到顶部](#菜单)

---
## [#328 奇偶链表](https://leetcode-cn.com/problems/odd-even-linked-list)
给定一个单链表，把所有的奇数节点和偶数节点分别排在一起。请注意，这里的奇数节点和偶数节点指的是节点编号的奇偶性，而不是节点的值的奇偶性。

请尝试使用原地算法完成。你的算法的空间复杂度应为 O(1)，时间复杂度应为 O(nodes)，nodes 为节点总数。

**示例 1:**
```
输入: 1->2->3->4->5->NULL
输出: 1->3->5->2->4->NULL
```
**示例 2:**
```
输入: 2->1->3->5->6->4->7->NULL
输出: 2->3->6->7->1->5->4->NULL
```
**说明:**
- 应当保持奇数节点和偶数节点的相对顺序。
- 链表的第一个节点视为奇数节点，第二个节点视为偶数节点，以此类推。

[回到顶部](#菜单)

---
## [#354 俄罗斯套娃信封问题](https://leetcode-cn.com/problems/russian-doll-envelopes)
给你一个二维整数数组 `envelopes` ，其中 `envelopes[i] = [wi, hi]` ，表示第 `i` 个信封的宽度和高度。

当另一个信封的宽度和高度都比这个信封大的时候，这个信封就可以放进另一个信封里，如同俄罗斯套娃一样。

请计算 **最多能有多少个** 信封能组成一组“俄罗斯套娃”信封（即可以把一个信封放到另一个信封里面）。

**注意：**不允许旋转信封。

**示例 1:**
```
输入：envelopes = [[5,4],[6,4],[6,7],[2,3]]
输出：3
解释：最多信封的个数为 3, 组合为: [2,3] => [5,4] => [6,7]。
```
**示例 2:**
```
输入：envelopes = [[1,1],[1,1],[1,1]]
输出：1
```
**提示:**
  - `1 <= envelopes.length <= 5000`
  - `envelopes[i].length == 2`
  - `1 <= wi, hi <= 10^4`

[回到顶部](#菜单)

---
## [#367 有效的完全平方数](https://leetcode-cn.com/problems/valid-perfect-square)
给定一个正整数 num，编写一个函数，如果 num 是一个完全平方数，则返回 True，否则返回 False。

**说明:** 不要使用任何内置的库函数，如  `sqrt`。

**示例 1:**
```
输入：16
输出：True
```
**示例 2:**
```
输入：14
输出：False
```

[回到顶部](#菜单)

---
## [#376 摆动序列](https://leetcode-cn.com/problems/wiggle-subsequence)
如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为**摆动序列**。第一个差（如果存在的话）可能是正数或负数。少于两个元素的序列也是摆动序列。

例如， `[1,7,4,9,2,5]` 是一个摆动序列，因为差值 `(6,-3,5,-7,3)` 是正负交替出现的。相反, `[1,4,7,2,5]` 和 `[1,7,4,5,5]` 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。

给定一个整数序列，返回作为摆动序列的最长子序列的长度。 通过从原始序列中删除一些（也可以不删除）元素来获得子序列，剩下的元素保持其原始顺序。

**示例 1:**
```
输入: [1,7,4,9,2,5]
输出: 6 
解释: 整个序列均为摆动序列。
```
**示例 2:**
```
输入: [1,17,5,10,13,15,10,5,16,8]
输出: 7
解释: 这个序列包含几个长度为 7 摆动序列，其中一个可为[1,17,10,13,10,16,8]。
```
**示例 3:**
```
输入: [1,2,3,4,5,6,7,8,9]
输出: 2
```
**进阶:**
你能否用 O(*n*) 时间复杂度完成此题?

[回到顶部](#菜单)

---
## [#383 赎金信](https://leetcode-cn.com/problems/ransom-note)
给定一个赎金信 (`ransom`) 字符串和一个杂志(`magazine`)字符串，判断第一个字符串 `ransom` 能不能由第二个字符串 `magazines` 里面的字符构成。如果可以构成，返回 `true` ；否则返回 `false`。

(题目说明：为了不暴露赎金信字迹，要从杂志上搜索各个需要的字母，组成单词来表达意思。杂志字符串中的每个字符只能在赎金信字符串中使用一次。)

**注意:**

你可以假设两个字符串均只含有小写字母。
```
canConstruct("a", "b") -> false
canConstruct("aa", "ab") -> false
canConstruct("aa", "aab") -> true
```
[回到顶部](#菜单)

---
## [#387 字符串中的第一个唯一字符](https://leetcode-cn.com/problems/first-unique-character-in-a-string)
给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1。

**案例:**
```
s = "leetcode"
返回 0.

s = "loveleetcode",
返回 2.
```
**注意事项:** 您可以假定该字符串只包含小写字母。

[回到顶部](#菜单)

---
## [#402 移掉K位数字](https://leetcode-cn.com/problems/remove-k-digits)
给定一个以字符串表示的非负整数 num，移除这个数中的 k 位数字，使得剩下的数字最小。

**注意:**
- num 的长度小于 10002 且 ≥ k。
- num 不会包含任何前导零。

**示例 1:**
```
输入: num = "1432219", k = 3
输出: "1219"
解释: 移除掉三个数字 4, 3, 和 2 形成一个新的最小的数字 1219。
```
**示例 2:**
```
输入: num = "10200", k = 1
输出: "200"
解释: 移掉首位的 1 剩下的数字为 200. 注意输出不能有任何前导零。
```
**示例 3:**
```
输入: num = "10", k = 2
输出: "0"
解释: 从原数字移除所有的数字，剩余为空就是0。
```

[回到顶部](#菜单)

---
## [#417 太平洋大西洋水流问题](https://leetcode-cn.com/problems/pacific-atlantic-water-flow)
给定一个 `m x n` 的非负整数矩阵来表示一片大陆上各个单元格的高度。“太平洋”处于大陆的左边界和上边界，而“大西洋”处于大陆的右边界和下边界。

规定水流只能按照上、下、左、右四个方向流动，且只能从高到低或者在同等高度上流动。

请找出那些水流既可以流动到“太平洋”，又能流动到“大西洋”的陆地单元的坐标。

**提示:**
  1. 输出坐标的顺序不重要
  2. *m* 和 *n* 都小于150

**示例:**
```
给定下面的 5x5 矩阵:

  太平洋 ~   ~   ~   ~   ~ 
       ~  1   2   2   3  (5) *
       ~  3   2   3  (4) (4) *
       ~  2   4  (5)  3   1  *
       ~ (6) (7)  1   4   5  *
       ~ (5)  1   1   2   4  *
          *   *   *   *   * 大西洋

返回:

[[0, 4], [1, 3], [1, 4], [2, 2], [3, 0], [3, 1], [4, 0]] (上图中带括号的单元).
```

[回到顶部](#菜单)

---
## [#423 从英文中重建数字](https://leetcode-cn.com/problems/reconstruct-original-digits-from-english)
给定一个**非空**字符串，其中包含字母顺序打乱的英文单词表示的数字`0-9`。按升序输出原始的数字。

**注意:**
  1. 输入只包含小写英文字母。
  2. 输入保证合法并可以转换为原始的数字，这意味着像 "abc" 或 "zerone" 的输入是不允许的。
  3. 输入字符串的长度小于 50,000。

**示例 1:**
```
输入: "owoztneoer"

输出: "012" (zeroonetwo)
```
**示例 2:**
```
输入: "fviefuro"

输出: "45" (fourfive)
```
[回到顶部](#菜单)

---
## [#434 字符串中的单词数](https://leetcode-cn.com/problems/number-of-segments-in-a-string)
统计字符串中的单词个数，这里的单词指的是连续的不是空格的字符。

请注意，你可以假定字符串里不包括任何不可打印的字符。

**示例:**
```
输入: "Hello, my name is John"
输出: 5
```
[回到顶部](#菜单)

---
## [#438 找到字符串中所有字母异位词](https://leetcode-cn.com/problems/find-all-anagrams-in-a-string)
给定一个字符串 **s** 和一个非空字符串 **p**，找到 **s** 中所有是 **p** 的字母异位词的子串，返回这些子串的起始索引。

字符串只包含小写英文字母，并且字符串 **s** 和 **p** 的长度都不超过 20100。

**说明:**
- 字母异位词指字母相同，但排列不同的字符串。
- 不考虑答案输出的顺序。

**示例 1:**
```
输入:
s: "cbaebabacd" p: "abc"

输出:
[0, 6]

解释:
起始索引等于 0 的子串是 "cba", 它是 "abc" 的字母异位词。
起始索引等于 6 的子串是 "bac", 它是 "abc" 的字母异位词。
```
**示例 2:**
```
输入:
s: "abab" p: "ab"

输出:
[0, 1, 2]

解释:
起始索引等于 0 的子串是 "ab", 它是 "ab" 的字母异位词。
起始索引等于 1 的子串是 "ba", 它是 "ab" 的字母异位词。
起始索引等于 2 的子串是 "ab", 它是 "ab" 的字母异位词。
```
[回到顶部](#菜单)

---
## [#467 环绕字符串中唯一的子字符串](https://leetcode-cn.com/problems/unique-substrings-in-wraparound-string)
把字符串 `s` 看作是“abcdefghijklmnopqrstuvwxyz”的无限环绕字符串，所以 `s` 看起来是这样的："...zabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcd....".

现在我们有了另一个字符串 `p` 。你需要的是找出 `s` 中有多少个唯一的 `p` 的非空子串，尤其是当你的输入是字符串 `p` ，你需要输出字符串 `s` 中 `p` 的不同的非空子串的数目。

注意: `p` 仅由小写的英文字母组成，p 的大小可能超过 10000。

**示例 1:**
```
输入: "a"
输出: 1
解释: 字符串 S 中只有一个"a"子字符。
```
**示例 2:**
```
输入: "cac"
输出: 2
解释: 字符串 S 中的字符串“cac”只有两个子串“a”、“c”。.
```
**示例 3:**
```
输入: "zab"
输出: 6
解释: 在字符串 S 中有六个子串“z”、“a”、“b”、“za”、“ab”、“zab”。.
```

[回到顶部](#菜单)

---
## [#474 一和零](https://leetcode-cn.com/problems/ones-and-zeroes)
给你一个二进制字符串数组 `strs` 和两个整数 `m` 和 `n` 。

请你找出并返回 `strs` 的最大子集的大小，该子集中 **最多** 有 `m` 个 `0` 和 `n` 个 `1` 。

如果 `x` 的所有元素也是 `y` 的元素，集合 `x` 是集合 `y` 的 **子集** 。

**示例 1:**
```
输入：strs = ["10", "0001", "111001", "1", "0"], m = 5, n = 3
输出：4
解释：最多有 5 个 0 和 3 个 1 的最大子集是 {"10","0001","1","0"} ，因此答案是 4 。
其他满足题意但较小的子集包括 {"0001","1"} 和 {"10","1","0"} 。{"111001"} 不满足题意，因为它含 4 个 1 ，大于 n 的值 3 。
```
**示例 2:**
```
输入：strs = ["10", "0", "1"], m = 1, n = 1
输出：2
解释：最大的子集是 {"0", "1"} ，所以答案是 2 。
```
**提示:**
  - `1 <= strs.length <= 600`
  - `1 <= strs[i].length <= 100`
  - `strs[i]` 仅由 `'0'` 和 `'1'` 组成
  - `1 <= m, n <= 100`

[回到顶部](#菜单)

---
## [#476 数字的补数](https://leetcode-cn.com/problems/number-complement)
给定一个正整数，输出它的补数。补数是对该数的二进制表示取反。

**示例 1:**
```
输入: 5
输出: 2
解释: 5 的二进制表示为 101（没有前导零位），其补数为 010。所以你需要输出 2 。
```
**示例 2:**
```
输入: 1
输出: 0
解释: 1 的二进制表示为 1（没有前导零位），其补数为 0。所以你需要输出 0 。
```
**注意:**
1. 给定的整数保证在 32 位带符号整数的范围内。
2. 你可以假定二进制数不包含前导零位。
3. 本题与 1009 <https://leetcode-cn.com/problems/complement-of-base-10-integer/> 相同

[回到顶部](#菜单)

---
## [#478 在圆内随机生成点](https://leetcode-cn.com/problems/generate-random-point-in-a-circle)
给定圆的半径和圆心的 x、y 坐标，写一个在圆中产生均匀随机点的函数 `randPoint` 。

说明:

  1. 输入值和输出值都将是[浮点数](https://baike.baidu.com/item/%E6%B5%AE%E7%82%B9%E6%95%B0/6162520)。
  2. 圆的半径和圆心的 x、y 坐标将作为参数传递给类的构造函数。
  3. 圆周上的点也认为是在圆中。
  4. `randPoint` 返回一个包含随机点的x坐标和y坐标的大小为2的数组。

**示例 1:**
```
输入: 
["Solution","randPoint","randPoint","randPoint"]
[[1,0,0],[],[],[]]
输出: [null,[-0.72939,-0.65505],[-0.78502,-0.28626],[-0.83119,-0.19803]]
```
**示例 2:**
```
输入: 
["Solution","randPoint","randPoint","randPoint"]
[[10,5,-7.5],[],[],[]]
输出: [null,[11.52438,-8.33273],[2.46992,-16.21705],[11.13430,-12.42337]]
```
**输入语法说明:**
输入是两个列表：调用成员函数名和调用的参数。`Solution` 的构造函数有三个参数，圆的半径、圆心的 x 坐标、圆心的 y 坐标。`randPoint` 没有参数。输入参数是一个列表，即使参数为空，也会输入一个 [] 空列表。

[回到顶部](#菜单)

---
## [#506 相对名次](https://leetcode-cn.com/problems/relative-ranks)
给出 **N** 名运动员的成绩，找出他们的相对名次并授予前三名对应的奖牌。前三名运动员将会被分别授予 “金牌”，“银牌” 和“ 铜牌”（"Gold Medal", "Silver Medal", "Bronze Medal"）。

(注：分数越高的选手，排名越靠前。)


**示例 1:**
```
输入: [5, 4, 3, 2, 1]
输出: ["Gold Medal", "Silver Medal", "Bronze Medal", "4", "5"]
解释: 前三名运动员的成绩为前三高的，因此将会分别被授予 “金牌”，“银牌”和“铜牌” ("Gold Medal", "Silver Medal" and "Bronze Medal").
余下的两名运动员，我们只需要通过他们的成绩计算将其相对名次即可。
```

**提示:**
1. N 是一个正整数并且不会超过 10000。
2. 所有运动员的成绩都不相同。

[回到顶部](#菜单)

---
## [#535 TinyURL 的加密与解密](https://leetcode-cn.com/problems/encode-and-decode-tinyurl)
TinyURL是一种URL简化服务， 比如：当你输入一个URL `https://leetcode.com/problems/design-tinyurl` 时，它将返回一个简化的URL `http://tinyurl.com/4e9iAk`.

要求：设计一个 TinyURL 的加密 `encode` 和解密 `decode` 的方法。你的加密和解密算法如何设计和运作是没有限制的，你只需要保证一个URL可以被加密成一个TinyURL，并且这个TinyURL可以用解密方法恢复成原本的URL。

[回到顶部](#菜单)

---
## [#540 有序数组中的单一元素](https://leetcode-cn.com/problems/single-element-in-a-sorted-array)
给定一个只包含整数的有序数组，每个元素都会出现两次，唯有一个数只会出现一次，找出这个数。

**示例 1:**
```
输入: [1,1,2,3,3,4,4,8,8]
输出: 2
```
**示例 2:**
```
输入: [3,3,7,7,10,11,11]
输出: 10
```
**注意:** 您的方案应该在 O(log n)时间复杂度和 O(1)空间复杂度中运行。

[回到顶部](#菜单)

---
## [#547 省份数量](https://leetcode-cn.com/problems/number-of-provinces)
有 `n` 个城市，其中一些彼此相连，另一些没有相连。如果城市 `a` 与城市 `b` 直接相连，且城市 `b` 与城市 `c` 直接相连，那么城市 `a` 与城市 `c` 间接相连。

**省份** 是一组直接或间接相连的城市，组内不含其他没有相连的城市。

给你一个 `n x n` 的矩阵 `isConnected` ，其中 `isConnected[i][j] = 1` 表示第 `i` 个城市和第 `j` 个城市直接相连，而 `isConnected[i][j] = 0` 表示二者不直接相连。

返回矩阵中 **省份** 的数量。

**示例 1:**

![](https://assets.leetcode.com/uploads/2020/12/24/graph1.jpg)
```
输入: isConnected = [[1,1,0],[1,1,0],[0,0,1]]
输出: 2
```
**示例 2:**

![](https://assets.leetcode.com/uploads/2020/12/24/graph2.jpg)
```
输入: isConnected = [[1,0,0],[0,1,0],[0,0,1]]
输出: 3
```
**提示:**
- `1 <= n <= 200`
- `n == isConnected.length`
- `n == isConnected[i].length`
- `isConnected[i][j]` 为 `1` 或 `0`.
- `isConnected[i][i] == 1`
- `isConnected[i][j] == isConnected[j][i]`

[回到顶部](#菜单)

---
## [#560 和为K的子数组](https://leetcode-cn.com/problems/subarray-sum-equals-k)
给定一个整数数组和一个整数 **k**，你需要找到该数组中和为 **k** 的连续的子数组的个数。

**示例 1:**
```
输入:nums = [1,1,1], k = 2
输出: 2 , [1,1] 与 [1,1] 为两种不同的情况。
```
**说明:**
1. 数组的长度为 [1, 20,000]。
2. 数组中元素的范围是 [-1000, 1000] ，且整数 **k** 的范围是 [-1e7, 1e7]。

[回到顶部](#菜单)

---
## [#567 字符串的排列](https://leetcode-cn.com/problems/permutation-in-string)
给定两个字符串 **s1** 和 **s2**，写一个函数来判断 **s2** 是否包含 **s1** 的排列。

换句话说，第一个字符串的排列之一是第二个字符串的子串。

**示例1:**
```
输入: s1 = "ab" s2 = "eidbaooo"
输出: True
解释: s2 包含 s1 的排列之一 ("ba").
```
**示例2:**
```
输入: s1= "ab" s2 = "eidboaoo"
输出: False
```
**注意:**
1. 输入的字符串只包含小写字母
2. 两个字符串的长度都在 [1, 10,000] 之间

[回到顶部](#菜单)

---
## [#575 分糖果](https://leetcode-cn.com/problems/distribute-candies)
给定一个**偶数**长度的数组，其中不同的数字代表着不同种类的糖果，每一个数字代表一个糖果。你需要把这些糖果**平均**分给一个弟弟和一个妹妹。返回妹妹可以获得的最大糖果的种类数。

**示例1:**
```
输入: candies = [1,1,2,2,3,3]
输出: 3
解析: 一共有三种种类的糖果，每一种都有两个。
     最优分配方案：妹妹获得[1,2,3],弟弟也获得[1,2,3]。这样使妹妹获得糖果的种类数最多。
```
**示例2:**
```
输入: candies = [1,1,2,3]
输出: 2
解析: 妹妹获得糖果[2,3],弟弟获得糖果[1,1]，妹妹有两种不同的糖果，弟弟只有一种。这样使得妹妹可以获得的糖果种类数最多。
```
**注意:**
1. 数组的长度为[2, 10,000]，并且确定为偶数。
2. 数组中数字的大小在范围[-100,000, 100,000]内。

[回到顶部](#菜单)

---
## [#645 错误的集合](https://leetcode-cn.com/problems/set-mismatch)
集合 `s` 包含从 `1` 到 `n` 的整数。不幸的是，因为数据错误，导致集合里面某一个数字复制了成了集合里面的另外一个数字的值，导致集合 **丢失了一个数字** 并且 **有一个数字重复** 。

给定一个数组 `nums` 代表了集合 `S` 发生错误后的结果。

请你找出重复出现的整数，再找到丢失的整数，将它们以数组的形式返回。

**示例1:**
```
输入：nums = [1,2,2,4]
输出：[2,3]
```
**示例2:**
```
输入：nums = [1,1]
输出：[1,2]
```
**提示:**
- `2 <= nums.length <= 10^4`
- `1 <= nums[i] <= 10^4`

[回到顶部](#菜单)

---
## [#678 有效的括号字符串](https://leetcode-cn.com/problems/valid-parenthesis-string)
给定一个只包含三种字符的字符串：`（` ，`）` 和 `*`，写一个函数来检验这个字符串是否为有效字符串。有效字符串具有如下规则：
1. 任何左括号 `(` 必须有相应的右括号 `)`。
2. 任何右括号 `)` 必须有相应的左括号 `(` 。
3. 左括号 `(` 必须在对应的右括号之前 `)`。
4. `*` 可以被视为单个右括号 `)` ，或单个左括号 `(` ，或一个空字符串。
5. 一个空字符串也被视为有效字符串。

**示例 1:**
```
输入: "()"
输出: True
```
**示例 2:**
```
输入: "(*)"
输出: True
```
**示例 3:**
```
输入: "(*))"
输出: True
```
**注意:**
1. 字符串大小将在 [1，100] 范围内。

[回到顶部](#菜单)

---
## [#714 买卖股票的最佳时机含手续费](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee)
给定一个整数数组 `prices`，其中第 `i` 个元素代表了第 `i` 天的股票价格 ；非负整数 `fee` 代表了交易股票的手续费用。

你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。

返回获得利润的最大值。

**注意：**这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。

**示例 1:**
```
输入: prices = [1, 3, 2, 8, 4, 9], fee = 2
输出: 8
解释: 能够达到的最大利润:  
在此处买入 prices[0] = 1
在此处卖出 prices[3] = 8
在此处买入 prices[4] = 4
在此处卖出 prices[5] = 9
总利润: ((8 - 1) - 2) + ((9 - 4) - 2) = 8.
```
**注意:**
- `0 < prices.length <= 50000`.
- `0 < prices[i] < 50000`.
- `0 <= fee < 50000`.

[回到顶部](#菜单)

---
## [#720 词典中最长的单词](https://leetcode-cn.com/problems/longest-word-in-dictionary)
给出一个字符串数组 `words` 组成的一本英语词典。从中找出最长的一个单词，该单词是由 `words` 词典中其他单词逐步添加一个字母组成。若其中有多个可行的答案，则返回答案中字典序最小的单词。

若无答案，则返回空字符串。

**示例 1:**
```
输入: words = ["w","wo","wor","worl", "world"]
输出: "world"
解释: 单词"world"可由"w", "wo", "wor", 和 "worl"添加一个字母组成。
```
**示例 2:**
```
输入: words = ["a", "banana", "app", "appl", "ap", "apply", "apple"]"(*)"
输出: "apple"
解释: "apply"和"apple"都能由词典中的单词组成。但是"apple"的字典序小于"apply"。
```
**提示:**
- 所有输入的字符串都只包含小写字母。
- `words` 数组长度范围为 `[1,1000]` 。
- `words[i]` 的长度范围为 `[1,30]` 。

[回到顶部](#菜单)

---
## [#733 图像渲染](https://leetcode-cn.com/problems/flood-fill)
有一幅以二维整数数组表示的图画，每一个整数表示该图画的像素值大小，数值在 0 到 65535 之间。

给你一个坐标 `(sr, sc)` 表示图像渲染开始的像素值（行 ，列）和一个新的颜色值 `newColor`，让你重新上色这幅图像。
为了完成上色工作，从初始坐标开始，记录初始坐标的上下左右四个方向上像素值与初始坐标相同的相连像素点，接着再记录这四个方向上符合条件的像素点与他们对应四个方向上像素值与初始坐标相同的相连像素点，……，重复该过程。将所有有记录的像素点的颜色值改为新的颜色值。

最后返回经过上色渲染后的图像。

**示例 1:**
```
输入:
image = [[1,1,1],[1,1,0],[1,0,1]]
sr = 1, sc = 1, newColor = 2
输出: [[2,2,2],[2,2,0],[2,0,1]]
解析:
在图像的正中间，(坐标(sr,sc)=(1,1)),
在路径上所有符合条件的像素点的颜色都被更改成2。
注意，右下角的像素没有更改为2，
因为它不是在上下左右四个方向上与初始点相连的像素点。
```
**注意:**
- `image` 和 `image[0]` 的长度在范围 `[1, 50]` 内。
- 给出的初始点将满足 `0 <= sr < image.length` 和 `0 <= sc < image[0].length`。
- `image[i][j]` 和 `newColor` 表示的颜色值在范围 `[0, 65535]`内。

[回到顶部](#菜单)

---
## [#747 至少是其他数字两倍的最大数](https://leetcode-cn.com/problems/largest-number-at-least-twice-of-others)
在一个给定的数组`nums`中，总是存在一个最大元素 。

查找数组中的最大元素是否至少是数组中每个其他数字的两倍。

如果是，则返回最大元素的索引，否则返回-1。

**示例 1:**
```
输入: nums = [3, 6, 1, 0]
输出: 1
解释: 6是最大的整数, 对于数组中的其他整数,
6大于数组中其他元素的两倍。6的索引是1, 所以我们返回1.
```
**示例 2:**
```
输入: nums = [1, 2, 3, 4]
输出: -1
解释: 4没有超过3的两倍大, 所以我们返回 -1.
```
**提示:**
  1.`nums` 的长度范围在`[1, 50]`.
  2.每个 `nums[i]` 的整数范围在 `[0, 99]`.

[回到顶部](#菜单)

---
## [#781 森林中的兔子](https://leetcode-cn.com/problems/rabbits-in-forest)
森林中，每个兔子都有颜色。其中一些兔子（可能是全部）告诉你还有多少其他的兔子和自己有相同的颜色。我们将这些回答放在 answers 数组里。

返回森林中兔子的最少数量。

**示例 1:**
```
输入: answers = [1, 1, 2]
输出: 5
解释:
两只回答了 "1" 的兔子可能有相同的颜色，设为红色。
之后回答了 "2" 的兔子不会是红色，否则他们的回答会相互矛盾。
设回答了 "2" 的兔子为蓝色。
此外，森林中还应有另外 2 只蓝色兔子的回答没有包含在数组中。
因此森林中兔子的最少数量是 5: 3 只回答的和 2 只没有回答的
```
**示例 2:**
```
输入: answers = [10, 10, 10]
输出: 11
```
**示例 3:**
```
输入: answers = []
输出: 0
```
**说明:**
1. `answers` 的长度最大为`1000`。
2. `answers[i]` 是在 `[0, 999]` 范围内的整数。

[回到顶部](#菜单)

---
## [#771 宝石与石头](https://leetcode-cn.com/problems/jewels-and-stones)
给定字符串`J` 代表石头中宝石的类型，和字符串`S` 代表你拥有的石头。 `S` 中每个字符代表了一种你拥有的石头的类型，你想知道你拥有的石头中有多少是宝石。

`J` 中的字母不重复，`J` 和 `S`中的所有字符都是字母。字母区分大小写，因此`"a"`和`"A"`是不同类型的石头。

**示例 1:**
```
输入: J = "aA", S = "aAAbbbb"
输出: 3
```
**示例 2:**
```
输入: J = "z", S = "ZZ"
输出: 0
```
**注意:**
- `S` 和 `J` 最多含有50个字母。
- `J` 中的字符不重复。

[回到顶部](#菜单)

---
## [#823 带因子的二叉树](https://leetcode-cn.com/problems/binary-trees-with-factors)
给出一个含有不重复整数元素的数组，每个整数均大于 1。

我们用这些整数来构建二叉树，每个整数可以使用任意次数。

其中：每个非叶结点的值应等于它的两个子结点的值的乘积。

满足条件的二叉树一共有多少个？返回的结果应模除 10 ** 9 + 7。

**示例 1:**
```
输入: A = [2, 4]
输出: 3
解释: 我们可以得到这些二叉树: [2], [4], [4, 2, 2]
```
**示例 2:**
```
输入: A = [2, 4, 5, 10]
输出: 7
解释: 我们可以得到这些二叉树: [2], [4], [5], [10], [4, 2, 2], [10, 2, 5], [10, 5, 2].
```
**提示:**
- `1 <= A.length <= 1000`.
- `2 <= A[i] <= 10 ^ 9`.

[回到顶部](#菜单)

---
## [#844 比较含退格的字符串](https://leetcode-cn.com/problems/reordered-power-of-2)
给定 `S` 和 `T` 两个字符串，当它们分别被输入到空白的文本编辑器后，判断二者是否相等，并返回结果。 `#` 代表退格字符。

**示例 1:**
```
输入：S = "ab#c", T = "ad#c"
输出：true
解释：S 和 T 都会变成 “ac”。
```
**示例 2:**
```
输入：S = "ab##", T = "c#d#"
输出：true
解释：S 和 T 都会变成 “”。
```
**示例 3:**
```
输入：S = "a##c", T = "#a#c"
输出：true
解释：S 和 T 都会变成 “c”。
```
**示例 4:**
```
输入：S = "a#c", T = "b"
输出：false
解释：S 会变成 “c”，但 T 仍然是 “b”。
```
**提示:**
1. `1 <= S.length <= 200`
2. `1 <= T.length <= 200`
3. `S` 和 `T` 只含有小写字母以及字符 `'#'`。

[回到顶部](#菜单)

---
## [#851 喧闹和富有](https://leetcode-cn.com/problems/loud-and-rich)
在一组 N 个人（编号为 `0, 1, 2, ..., N-1`）中，每个人都有不同数目的钱，以及不同程度的安静（quietness）。

为了方便起见，我们将编号为 `x` 的人简称为 "person `x` "。

如果能够肯定 person `x` 比 person `y` 更有钱的话，我们会说 `richer[i] = [x, y]` 。注意 `richer` 可能只是有效观察的一个子集。

另外，如果 person `x` 的安静程度为 `q` ，我们会说 `quiet[x] = q` 。

现在，返回答案 `answer` ，其中 `answer[x] = y` 的前提是，在所有拥有的钱不少于 person `x` 的人中，person `y` 是最安静的人（也就是安静值 `quiet[y]` 最小的人）。

**示例:**
```
输入：richer = [[1,0],[2,1],[3,1],[3,7],[4,3],[5,3],[6,3]], quiet = [3,2,5,4,6,1,7,0]
输出：[5,5,2,5,4,5,6,7]
解释： 
answer[0] = 5，
person 5 比 person 3 有更多的钱，person 3 比 person 1 有更多的钱，person 1 比 person 0 有更多的钱。
唯一较为安静（有较低的安静值 quiet[x]）的人是 person 7，
但是目前还不清楚他是否比 person 0 更有钱。

answer[7] = 7，
在所有拥有的钱肯定不少于 person 7 的人中(这可能包括 person 3，4，5，6 以及 7)，
最安静(有较低安静值 quiet[x])的人是 person 7。

其他的答案也可以用类似的推理来解释。
```
**提示:**
  1. `1 <= quiet.length = N <= 500`
  2. `0 <= quiet[i] < N`，所有 `quiet[i]` 都不相同。
  3. `0 <= richer.length <= N * (N-1) / 2`
  4. `0 <= richer[i][j] < N`
  5. `richer[i][0] != richer[i][1]`
  6. `richer[i]` 都是不同的。
  7. 对 `richer` 的观察在逻辑上是一致的。

[回到顶部](#菜单)

---
## [#869 重新排序得到 2 的幂](https://leetcode-cn.com/problems/reordered-power-of-2)
从正整数 `N` 开始，我们按任何顺序（包括原始顺序）将数字重新排序，注意其前导数字不能为零。

如果我们可以通过上述方式得到 2 的幂，返回 `true`；否则，返回 `false`。

**Example(示例) 1:**
```
输入: 1
输出: true
```
**示例 2:**
```
输入: 10
输出: false
```
**示例 3:**
```
输入: 16
输出: true
```
**示例 4:**
```
输入: 24
输出: false
```
**示例 5:**
```
输入: 46
输出: true
```
**提示:**
  1. `1 <= N <= 10^9`

[回到顶部](#菜单)

---
## [#870 优势洗牌](https://leetcode-cn.com/problems/advantage-shuffle)
给定两个大小相等的数组 `A` 和 `B`，A 相对于 B 的*优势*可以用满足 `A[i] > B[i]` 的索引 `i` 的数目来描述。

返回 `A` 的**任意**排列，使其相对于 `B` 的优势最大化。

**示例 1:**
```
输入：A = [2,7,11,15], B = [1,10,4,11]
输出：[2,11,7,15]
```
**示例 2:**
```
输入：A = [12,24,8,32], B = [13,25,32,11]
输出：[24,32,8,12]
```
**提示:**
  1. `1 <= A.length = B.length <= 10000`
  2. `0 <= A[i] <= 10^9`
  3. `0 <= B[i] <= 10^9`

[回到顶部](#菜单)

---
## [#876 链表的中间结点](https://leetcode-cn.com/problems/middle-of-the-linked-list/)
给定一个带有头结点 `head` 的非空单链表，返回链表的中间结点。

如果有两个中间结点，则返回第二个中间结点。

**示例 1:**
```
输入：[1,2,3,4,5]
输出：此列表中的结点 3 (序列化形式：[3,4,5])
返回的结点值为 3 。 (测评系统对该结点序列化表述是 [3,4,5])。
注意，我们返回了一个 ListNode 类型的对象 ans，这样：
ans.val = 3, ans.next.val = 4, ans.next.next.val = 5, 以及 ans.next.next.next = NULL.
```
**示例 2:**
```
输入：[1,2,3,4,5,6]
输出：此列表中的结点 4 (序列化形式：[4,5,6])
由于该列表有两个中间结点，值分别为 3 和 4，我们返回第二个结点。
```
**提示:**
- 给定链表的结点数介于 `1` 和 `100` 之间。

[回到顶部](#菜单)

---
## [#916 单词子集](https://leetcode-cn.com/problems/word-subsets)
我们给出两个单词数组 `A` 和 `B`。每个单词都是一串小写字母。

现在，如果 `b` 中的每个字母都出现在 `a` 中，**包括重复出现的字母**，那么称单词 `b` 是单词 `a` 的子集。 例如，“wrr” 是 “warrior” 的子集，但不是 “world” 的子集。

如果对 `B` 中的每一个单词 `b`，`b` 都是 `a` 的子集，那么我们称 `A` 中的单词 `a` 是通用的。

你可以按任意顺序以列表形式返回 `A` 中所有的通用单词。

**示例 1:**
```
输入：A = ["amazon","apple","facebook","google","leetcode"], B = ["e","o"]
输出：["facebook","google","leetcode"]
```
**示例 2:**
```
输入：A = ["amazon","apple","facebook","google","leetcode"], B = ["l","e"]
输出：["apple","google","leetcode"]
```
**示例 3:**
```
输入：A = ["amazon","apple","facebook","google","leetcode"], B = ["e","oo"]
输出：["facebook","google"]
```
**示例 4:**
```
输入：A = ["amazon","apple","facebook","google","leetcode"], B = ["lo","eo"]
输出：["google","leetcode"]
```
**示例 5:**
```
输入：A = ["amazon","apple","facebook","google","leetcode"], B = ["ec","oc","ceo"]
输出：["facebook","leetcode"]
```
**提示:**
1. `1 <= A.length`, `B.length <= 10000`
2. `1 <= A[i].length`, `B[i].length <= 10`
3. `A[i]` 和 `B[i]` 只由小写字母组成。
4. `A[i]` 中所有的单词都是独一无二的，也就是说不存在 `i != j` 使得 `A[i] == A[j]`。

[回到顶部](#菜单)

---
## [#918 环形子数组的最大和](https://leetcode-cn.com/problems/maximum-sum-circular-subarray)
给定一个由整数数组 `A` 表示的**环形数组** `C`，求 `C` 的非空子数组的最大可能和。

在此处，环形数组意味着数组的末端将会与开头相连呈环状。（形式上，当`0 <= i < A.length` 时 `C[i] = A[i]`，而当 `i >= 0` 时 `C[i+A.length] = C[i]`）

此外，子数组最多只能包含固定缓冲区 `A` 中的每个元素一次。（形式上，对于子数组 `C[i], C[i+1], ..., C[j]`，不存在 `i <= k1, k2 <= j` 其中 `k1 % A.length = k2 % A.length`）

**示例 1:**
```
输入：[1,-2,3,-2]
输出：3
解释：从子数组 [3] 得到最大和 3
```
**示例 2:**
```
输入：[5,-3,5]
输出：10
解释：从子数组 [5,5] 得到最大和 5 + 5 = 10
```
**示例 3:**
```
输入：[3,-1,2,-1]
输出：4
解释：从子数组 [2,-1,3] 得到最大和 2 + (-1) + 3 = 4
```
**示例 4:**
```
输入：[3,-2,2,-3]
输出：3
解释：从子数组 [3] 和 [3,-2,2] 都可以得到最大和 3
```
**示例 5:**
```
输入：[-2,-3,-1]
输出：-1
解释：从子数组 [-1] 得到最大和 -1
```
**提示:**
1. `-30000 <= A[i] <= 30000`
2. `1 <= A.length <= 30000`

[回到顶部](#菜单)

---
## [#971 翻转二叉树以匹配先序遍历](https://leetcode-cn.com/problems/flip-binary-tree-to-match-preorder-traversal)
给你一棵二叉树的根节点 `root` ，树中有 `n` 个节点，每个节点都有一个不同于其他节点且处于 `1` 到 `n` 之间的值。

另给你一个由 `n` 个值组成的行程序列 `voyage` ，表示 **预期** 的二叉树 [先序遍历](https://baike.baidu.com/item/%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86/6442839?fr=aladdin) 结果。

通过交换节点的左右子树，可以 **翻转** 该二叉树中的任意节点。例，翻转节点 1 的效果如下：

![](https://assets.leetcode.com/uploads/2021/02/15/fliptree.jpg)

请翻转 **最少** 的树中节点，使二叉树的 **先序遍历** 与预期的遍历行程 `voyage` **相匹配** 。 

如果可以，则返回 **翻转的** 所有节点的值的列表。你可以按任何顺序返回答案。如果不能，则返回列表 `[-1]`。

**示例 1:**

![](https://assets.leetcode.com/uploads/2019/01/02/1219-01.png)
```
输入：root = [1,2], voyage = [2,1]
输出：[-1]
解释：翻转节点无法令先序遍历匹配预期行程。
```
**示例 2:**

![](https://assets.leetcode.com/uploads/2019/01/02/1219-02.png)
```
输入：root = [1,2,3], voyage = [1,3,2]
输出：[1]
解释：交换节点 2 和 3 来翻转节点 1 ，先序遍历可以匹配预期行程。
```
**示例 3:**

![](https://assets.leetcode.com/uploads/2019/01/02/1219-02.png)
```
输入：root = [1,2,3], voyage = [1,2,3]
输出：[]
解释：先序遍历已经匹配预期行程，所以不需要翻转节点。
```

**提示:**
  - 树中的节点数目为 n
  - n == voyage.length
  - 1 <= n <= 100
  - 1 <= Node.val, voyage[i] <= n
  - 树中的所有值 互不相同
  - voyage 中的所有值 互不相同

[回到顶部](#菜单)

---
## [#992 K 个不同整数的子数组](https://leetcode-cn.com/problems/subarrays-with-k-different-integers)
给定一个正整数数组 `A`，如果 `A` 的某个子数组中不同整数的个数恰好为 `K`，则称 `A` 的这个连续、不一定独立的子数组为好子数组。

(例如，`[1,2,3,1,2]` 中有 `3` 个不同的整数：`1`，`2`，以及 `3`。)

返回 `A` 中好子数组的数目。

**示例 1:**
```
输出：A = [1,2,1,2,3], K = 2
输入：7
解释：恰好由 2 个不同整数组成的子数组：[1,2], [2,1], [1,2], [2,3], [1,2,1], [2,1,2], [1,2,1,2].
```
**示例 2:**
```
输入：A = [1,2,1,3,4], K = 3
输出：3
解释：恰好由 3 个不同整数组成的子数组：[1,2,1,3], [2,1,3], [1,3,4].
```
**提示:**
  1. `1 <= A.length <= 20000`
  2. `1 <= A[i] <= A.length`
  3. `1 <= K <= A.length`

[回到顶部](#菜单)

---
## [#993 二叉树的堂兄弟节点](https://leetcode-cn.com/problems/cousins-in-binary-tree)
在二叉树中，根节点位于深度 `0` 处，每个深度为 `k` 的节点的子节点位于深度 `k+1` 处。

如果二叉树的两个节点深度相同，但**父节点不同**，则它们是一对堂兄弟节点。

我们给出了具有唯一值的二叉树的根节点 `root`，以及树中两个不同节点的值 `x` 和 `y`。

只有与值 `x` 和 `y` 对应的节点是堂兄弟节点时，才返回 `true`。否则，返回 `false`。

**示例 1:**

![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/16/q1248-01.png)
```
输入：root = [1,2,3,4], x = 4, y = 3
输出：false
```
**示例 2:**

![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/16/q1248-02.png)
```
输入：root = [1,2,3,null,4,null,5], x = 5, y = 4
输出：true
```
**示例 3:**

![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/16/q1248-03.png)
```
输入：root = [1,2,3,null,4], x = 2, y = 3
输出：false
```
**提示:**
1. 二叉树的节点数介于 `2` 到 `100` 之间。
2. 每个节点的值都是唯一的、范围为 `1` 到 `100` 的整数。

[回到顶部](#菜单)

---
## [#997 找到小镇的法官](https://leetcode-cn.com/problems/find-the-town-judge)
在一个小镇里，按从 `1` 到 `N` 标记了 `N` 个人。传言称，这些人中有一个是小镇上的秘密法官。

如果小镇的法官真的存在，那么：
1. 小镇的法官不相信任何人。
2. 每个人（除了小镇法官外）都信任小镇的法官。
3. 只有一个人同时满足属性 1 和属性 2 。

给定数组 `trust`，该数组由信任对 `trust[i] = [a, b]` 组成，表示标记为 `a` 的人信任标记为 `b` 的人。

如果小镇存在秘密法官并且可以确定他的身份，请返回该法官的标记。否则，返回 `-1`。

**示例 1:**
```
输入：N = 2, trust = [[1,2]]
输出：2
```
**示例 2:**
```
输入：N = 3, trust = [[1,3],[2,3]]
输出：3
```
**示例 3:**
```
输入：N = 3, trust = [[1,3],[2,3],[3,1]]
输出：-1
```
**示例 4:**
```
输入：N = 3, trust = [[1,2],[2,3]]
输出：-1
```
**示例 5:**
```
输入：N = 4, trust = [[1,3],[1,4],[2,3],[2,4],[4,3]]
输出：3
```
**提示:**
1. `1 <= N <= 1000`
2. `trust.length <= 10000`
3. `trust[i]` 是完全不同的
4. `trust[i][0] != trust[i][1]`
5. `1 <= trust[i][0], trust[i][1] <= N`

[回到顶部](#菜单)

---
## [#1008 先序遍历构造二叉树](https://leetcode-cn.com/problems/construct-binary-search-tree-from-preorder-traversal)
返回与给定先序遍历 `preorder` 相匹配的二叉搜索树（binary **search** tree）的根结点。

*(回想一下，二叉搜索树是二叉树的一种，其每个节点都满足以下规则，对于 `node.left` 的任何后代，值总 `<` `node.val`，而 `node.right` 的任何后代，值总 `>` `node.val`。此外，先序遍历首先显示节点的值，然后遍历 `node.left`，接着遍历 `node.right`。）*

**示例:**
```
输入：[8,5,1,7,10,12]
输出：[8,5,10,1,7,null,12]
```
![输出](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/03/08/1266.png)

**提示:**
1. `1 <= preorder.length <= 100`
2. 先序 `preorder` 中的值是不同的。

[回到顶部](#菜单)

---
## [#1022 从根到叶的二进制数之和](https://leetcode-cn.com/problems/sum-of-root-to-leaf-binary-numbers)
给出一棵二叉树，其上每个结点的值都是 `0` 或 `1` 。每一条从根到叶的路径都代表一个从最高有效位开始的二进制数。例如，如果路径为 `0 -> 1 -> 1 -> 0 -> 1`，那么它表示二进制数 `01101`，也就是 `13` 。

对树上的每一片叶子，我们都要找出从根到该叶子的路径所表示的数字。

返回这些数字之和。题目数据保证答案是一个 **32 位** 整数。

**示例1:**

![](https://assets.leetcode.com/uploads/2019/04/04/sum-of-root-to-leaf-binary-numbers.png)
```
输入：root = [1,0,1,0,1,0,1]
输出：22
解释：(100) + (101) + (110) + (111) = 4 + 5 + 6 + 7 = 22
```
**示例2:**
```
输入：root = [0]
输出：0
```
**示例3:**
```
输入：root = [1]
输出：1
```
**示例4:**
```
输入：root = [1,1]
输出：3
```

**提示:**
- 树中的结点数介于 `1` 和 `1000` 之间。
- `Node.val` 为 `0` 或 `1` 。

[回到顶部](#菜单)

---
## [#1046 最后一块石头的重量](https://leetcode-cn.com/problems/last-stone-weight)
有一堆石头，每块石头的重量都是正整数。

每一回合，从中选出两块 **最重的** 石头，然后将它们一起粉碎。假设石头的重量分别为 `x` 和 `y`，且 `x <= y`。那么粉碎的可能结果如下：
- 如果 `x == y`，那么两块石头都会被完全粉碎；
- 如果 `x != y`，那么重量为 `x` 的石头将会完全粉碎，而重量为 `y` 的石头新重量为 `y-x`。
最后，最多只会剩下一块石头。返回此石头的重量。如果没有石头剩下，就返回 `0`。

**示例:**
```
输入：[2,7,4,1,8,1]
输出：1
解释：
先选出 7 和 8，得到 1，所以数组转换为 [2,4,1,1,1]，
再选出 2 和 4，得到 2，所以数组转换为 [2,1,1,1]，
接着是 2 和 1，得到 1，所以数组转换为 [1,1,1]，
最后选出 1 和 1，得到 0，最终数组转换为 [1]，这就是最后剩下那块石头的重量。
```
**提示:**
1. `1 <= stones.length <= 30`
2. `1 <= stones[i] <= 1000`

[回到顶部](#菜单)

---
## [#1143 最长公共子序列](https://leetcode-cn.com/problems/longest-common-subsequence)
给定两个字符串 `text1` 和 `text2，返回这两个字符串的最长公共子序列的长度。`

一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。

例如，"ace" 是 "abcde" 的子序列，但 "aec" 不是 "abcde" 的子序列。两个字符串的「公共子序列」是这两个字符串所共同拥有的子序列。

若这两个字符串没有公共子序列，则返回 0。

**示例 1:**
```
输入：text1 = "abcde", text2 = "ace"
输出：3  
解释：最长公共子序列是 "ace"，它的长度为 3。
```
**示例 2:**
```
输入：text1 = "abc", text2 = "abc"
输出：3
解释：最长公共子序列是 "abc"，它的长度为 3。
```
**示例 3:**
```
输入：text1 = "abc", text2 = "def"
输出：0
解释：两个字符串没有公共子序列，返回 0。
```

**提示:**
- `1 <= text1.length <= 1000`
- `1 <= text2.length <= 1000`
- 输入的字符串只含有小写英文字符。

[回到顶部](#菜单)

---
## [#1147 段式回文](https://leetcode-cn.com/problems/longest-chunked-palindrome-decomposition)
段式回文 其实与 一般回文 类似，只不过是最小的单位是 一段字符 而不是 单个字母。

举个例子，对于一般回文 "`abcba`" 是回文，而 "`volvo`" 不是，但如果我们把 "`volvo`" 分为 "`vo`"、"`l`"、"`vo`" 三段，则可以认为 “`(vo)(l)(vo)`” 是段式回文（分为 3 段）。

给你一个字符串 `text`，在确保它满足段式回文的前提下，请你返回 **段** 的 **最大数量** `k`。

如果段的最大数量为 `k`，那么存在满足以下条件的 `a_1, a_2, ..., a_k`：
- 每个 `a_i` 都是一个非空字符串；
- 将这些字符串首位相连的结果 `a_1 + a_2 + ... + a_k` 和原始字符串 `text` 相同；
- 对于所有`1 <= i <= k`，都有 `a_i = a_{k+1 - i}`。

**示例 1:**
```
输入：text = "ghiabcdefhelloadamhelloabcdefghi"
输出：7
解释：我们可以把字符串拆分成 "(ghi)(abcdef)(hello)(adam)(hello)(abcdef)(ghi)"。
```
**示例 2:**
```
输入：text = "merchant"
输出：1
解释：我们可以把字符串拆分成 "(merchant)"。
```
**示例 3:**
```
输入：text = "antaprezatepzapreanta"
输出：11
解释：我们可以把字符串拆分成 "(a)(nt)(a)(pre)(za)(tpe)(za)(pre)(a)(nt)(a)"。
```
**示例 4:**
```
输入：text = "aaa"
输出：3
解释：我们可以把字符串拆分成 "(a)(a)(a)"。
```

**提示:**
- `text` 仅由小写英文字符组成。
- `1 <= text.length <= 1000`

[回到顶部](#菜单)

---
## [#1232 缀点成线](https://leetcode-cn.com/problems/check-if-it-is-a-straight-line)
在一个 XY 坐标系中有一些点，我们用数组 `coordinates` 来分别记录它们的坐标，其中 `coordinates[i] = [x, y]` 表示横坐标为 `x`、纵坐标为 `y` 的点。

请你来判断，这些点是否在该坐标系中属于同一条直线上，是则返回 `true`，否则请返回 `false`。

**示例 1:**

![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/10/19/untitled-diagram-2.jpg)
```
输入：coordinates = [[1,2],[2,3],[3,4],[4,5],[5,6],[6,7]]
输出：true
```
**示例 2:**

![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/10/19/untitled-diagram-1.jpg)
```
输入：coordinates = [[1,1],[2,2],[3,4],[4,5],[5,6],[7,7]]
输出：false
```
**提示:**
- `2 <= coordinates.length <= 1000`
- `coordinates[i].length == 2`
- `-10^4 <= coordinates[i][0], coordinates[i][1] <= 10^4`
- `coordinates` 中不含重复的点

[回到顶部](#菜单)

---
## [#1302 层数最深叶子节点的和](https://leetcode-cn.com/problems/deepest-leaves-sum)
给你一棵二叉树，请你返回层数最深的叶子节点的和。

**示例 1:**

![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/12/28/1483_ex1.png)
```
输入：root = [1,2,3,4,5,null,6,7,null,null,null,null,8]
输出：15
```
**提示:**
- 树中节点数目在 `1` 到 `10^4` 之间。
- 每个节点的值在 `1` 到 `100` 之间。

[回到顶部](#菜单)

---
## [#1306 跳跃游戏 III](https://leetcode-cn.com/problems/jump-game-iii)
这里有一个非负整数数组 arr，你最开始位于该数组的起始下标 start 处。当你位于下标 i 处时，你可以跳到 i + arr[i] 或者 i - arr[i]。

请你判断自己是否能够跳到对应元素值为 0 的 任一 下标处。

注意，不管是什么情况下，你都无法跳到数组之外。

**示例 1:**
```
输入：arr = [4,2,3,0,3,1,2], start = 5
输出：true
解释：
到达值为 0 的下标 3 有以下可能方案： 
下标 5 -> 下标 4 -> 下标 1 -> 下标 3 
下标 5 -> 下标 6 -> 下标 4 -> 下标 1 -> 下标 3 
```
**示例 2:**
```
输入：arr = [4,2,3,0,3,1,2], start = 0
输出：true 
解释：
到达值为 0 的下标 3 有以下可能方案： 
下标 0 -> 下标 4 -> 下标 1 -> 下标 3
```
**示例 3:**
```
输入：arr = [3,0,2,1,2], start = 2
输出：false
解释：无法到达值为 0 的下标 1 处。
```
**提示:**
  - `1 <= arr.length <= 5 * 10^4`
  - `0 <= arr[i] < arr.length`
  - `0 <= start < arr.length`

[回到顶部](#菜单)

---
## [#1337 矩阵中战斗力最弱的 K 行](https://leetcode-cn.com/problems/the-k-weakest-rows-in-a-matrix)
给你一个大小为 `m * n` 的矩阵 `mat`，矩阵由若干军人和平民组成，分别用 1 和 0 表示。

请你返回矩阵中战斗力最弱的 `k` 行的索引，按从最弱到最强排序。

如果第 ***i*** 行的军人数量少于第 ***j*** 行，或者两行军人数量相同但 ***i*** 小于 ***j***，那么我们认为第 ***i*** 行的战斗力比第 ***j*** 行弱。

军人 **总是** 排在一行中的靠前位置，也就是说 1 总是出现在 0 之前。

**示例 1:**
```
输入：
mat =
[[1,1,0,0,0],
 [1,1,1,1,0],
 [1,0,0,0,0],
 [1,1,0,0,0],
 [1,1,1,1,1]],
k = 3
输出：[2,0,3]
解释：
每行中的军人数目：
行 0 -> 2
行 1 -> 4
行 2 -> 1
行 3 -> 2
行 4 -> 5
从最弱到最强对这些行排序后得到 [2,0,3,1,4]
```
**示例 2:**
```
输入mat =
[[1,0,0,0],
 [1,1,1,1],
 [1,0,0,0],
 [1,0,0,0]],
k = 2
输出：[0,2]
解释：
每行中的军人数目：
行 0 -> 1
行 1 -> 4
行 2 -> 1
行 3 -> 1
从最弱到最强对这些行排序后得到 [0,2,3,1]
```
**提示:**
- `m == mat.length`
- `n == mat[i].length`
- `2 <= n, m <= 100`
- `1 <= k <= m`
- `matrix[i][j]` 不是 0 就是 1

[回到顶部](#菜单)

---
## [#1695 删除子数组的最大得分](https://leetcode-cn.com/problems/maximum-erasure-value)
给你一个正整数数组 `nums` ，请你从中删除一个含有 **若干不同元素** 的子数组。删除子数组的 **得分** 就是子数组各元素之 **和** 。

返回 **只删除一个** 子数组可获得的 **最大得分** 。

如果数组 `b` 是数组 `a` 的一个连续子序列，即如果它等于 `a[l],a[l+1],...,a[r]` ，那么它就是 `a` 的一个子数组。

**示例 1:**
```
输入：nums = [4,2,4,5,6]
输出：17
解释：最优子数组是 [2,4,5,6]
```
**示例 2:**
```
输入：nums = [5,2,1,2,5,2,1,2,5]
输出：8
解释：最优子数组是 [5,2,1] 或 [1,2,5]
```
**提示:**
- `1 <= nums.length <= 10^5`
- `1 <= nums[i] <= 10^4`

[回到顶部](#菜单)

---
## [#1704 判断字符串的两半是否相似](https://leetcode-cn.com/problems/determine-if-string-halves-are-alike)
给你一个偶数长度的字符串 `s` 。将其拆分成长度相同的两半，前一半为 `a` ，后一半为 `b` 。

两个字符串 **相似** 的前提是它们都含有相同数目的元音（`'a'`，`'e'`，`'i'`，`'o'`，`'u'`，`'A'`，`'E'`，`'I'`，`'O'`，`'U'`）。注意，`s` 可能同时含有大写和小写字母。

如果 `a` 和 `b` 相似，返回 `true` ；否则，返回 `false` 。

**示例 1:**
```
输入：s = "book"
输出：true
解释：a = "bo" 且 b = "ok" 。a 中有 1 个元音，b 也有 1 个元音。所以，a 和 b 相似。
```
**示例 2:**
```
输入：s = "textbook"
输出：false
解释：a = "text" 且 b = "book" 。a 中有 1 个元音，b 中有 2 个元音。因此，a 和 b 不相似。
注意，元音 o 在 b 中出现两次，记为 2 个。
```
**示例 3:**
```
输入：s = "MerryChristmas"
输出：false
```
**示例 4:**
```
输入：s = "AbCdEfGh"
输出：true
```
**提示:**
  - `2 <= s.length <= 1000`
  - `s.length` 是偶数
  - `s` 由 **大写和小写** 字母组成

[回到顶部](#菜单)

---
## [#1721 交换链表中的节点](https://leetcode-cn.com/problems/swapping-nodes-in-a-linked-list)
给你链表的头节点 head 和一个整数 k 。

交换 链表正数第 k 个节点和倒数第 k 个节点的值后，返回链表的头节点（链表 从 1 开始索引）。

**示例 1:**

![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/01/10/linked1.jpg)
```
输入：head = [1,2,3,4,5], k = 2
输出：[1,4,3,2,5]
```
**示例 2:**
```
输入：head = [7,9,6,6,7,8,3,0,9,5], k = 5
输出：[7,9,6,6,8,7,3,0,9,5]
```
**示例 3:**
```
输入：head = [1], k = 1
输出：[1]
```
**示例 4:**
```
输入：head = [1,2], k = 1
输出：[2,1]
```
**示例 5:**
```
输入：head = [1,2,3], k = 2
输出：[1,2,3]
```
**提示:**
- 链表中节点的数目是 `n`
- `1 <= k <= n <= 10^5`
- `0 <= Node.val <= 100`

[回到顶部](#菜单)

---
## [#1732 找到最高海拔](https://leetcode-cn.com/problems/find-the-highest-altitude)
有一个自行车手打算进行一场公路骑行，这条路线总共由 n + 1 个不同海拔的点组成。自行车手从海拔为 0 的点 0 开始骑行。

给你一个长度为 n 的整数数组 gain ，其中 gain[i] 是点 i 和点 i + 1 的 净海拔高度差（0 <= i < n）。请你返回 最高点的海拔 。

**示例 1:**
```
输入：gain = [-5,1,5,0,-7]
输出：1
解释：海拔高度依次为 [0,-5,-4,1,1,-6] 。最高海拔为 1 。
```
**示例 2:**
```
输入：gain = [-4,-3,-2,-1,4,3,2]
输出：0
解释：海拔高度依次为 [0,-4,-7,-9,-10,-6,-3,-1] 。最高海拔为 0 。
```
**提示:**
- `n == gain.length`
- `1 <= n <= 100`
- `-100 <= gain[i] <= 100`

[回到顶部](#菜单)

---

来源：力扣（LeetCode）

链接：https://leetcode-cn.com

著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
